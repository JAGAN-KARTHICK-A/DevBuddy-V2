var MyApp = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
      var is = require_is();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
      var ResponseError = class _ResponseError extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, _ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports.ResponseError = ResponseError;
      var ParameterStructures = class _ParameterStructures {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.NotificationType9 = NotificationType9;
      var Message2;
      (function(Message3) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message3.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message3.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message3.isResponse = isResponse;
      })(Message2 || (exports.Message = Message2 = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
      "use strict";
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch || (exports.Touch = Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports.LRUCache = LRUCache;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Disposable = void 0;
      var Disposable4;
      (function(Disposable5) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable5.create = create;
      })(Disposable4 || (exports.Disposable = Disposable4 = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports.default = RAL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Emitter = exports.Event = void 0;
      var ral_1 = require_ral();
      var Event;
      (function(Event2) {
        const _disposable = { dispose() {
        } };
        Event2.None = function() {
          return _disposable;
        };
      })(Event || (exports.Event = Event = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter = class _Emitter {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = _Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports.Emitter = Emitter;
      Emitter._noop = function() {
      };
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CancellationTokenSource = exports.CancellationToken = void 0;
      var ral_1 = require_ral();
      var Is2 = require_is();
      var events_1 = require_events();
      var CancellationToken;
      (function(CancellationToken2) {
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken2.is = is;
      })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports.CancellationTokenSource = CancellationTokenSource;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
  var require_sharedArrayCancellation = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
      var cancellation_1 = require_cancellation();
      var CancellationState;
      (function(CancellationState2) {
        CancellationState2.Continue = 0;
        CancellationState2.Cancelled = 1;
      })(CancellationState || (CancellationState = {}));
      var SharedArraySenderStrategy = class {
        constructor() {
          this.buffers = /* @__PURE__ */ new Map();
        }
        enableCancellation(request) {
          if (request.id === null) {
            return;
          }
          const buffer = new SharedArrayBuffer(4);
          const data = new Int32Array(buffer, 0, 1);
          data[0] = CancellationState.Continue;
          this.buffers.set(request.id, buffer);
          request.$cancellationData = buffer;
        }
        async sendCancellation(_conn, id) {
          const buffer = this.buffers.get(id);
          if (buffer === void 0) {
            return;
          }
          const data = new Int32Array(buffer, 0, 1);
          Atomics.store(data, 0, CancellationState.Cancelled);
        }
        cleanup(id) {
          this.buffers.delete(id);
        }
        dispose() {
          this.buffers.clear();
        }
      };
      exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
      var SharedArrayBufferCancellationToken = class {
        constructor(buffer) {
          this.data = new Int32Array(buffer, 0, 1);
        }
        get isCancellationRequested() {
          return Atomics.load(this.data, 0) === CancellationState.Cancelled;
        }
        get onCancellationRequested() {
          throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
        }
      };
      var SharedArrayBufferCancellationTokenSource = class {
        constructor(buffer) {
          this.token = new SharedArrayBufferCancellationToken(buffer);
        }
        cancel() {
        }
        dispose() {
        }
      };
      var SharedArrayReceiverStrategy = class {
        constructor() {
          this.kind = "request";
        }
        createCancellationTokenSource(request) {
          const buffer = request.$cancellationData;
          if (buffer === void 0) {
            return new cancellation_1.CancellationTokenSource();
          }
          return new SharedArrayBufferCancellationTokenSource(buffer);
        }
      };
      exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Semaphore = void 0;
      var ral_1 = require_ral();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports.Semaphore = Semaphore;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
      var ral_1 = require_ral();
      var Is2 = require_is();
      var events_1 = require_events();
      var semaphore_1 = require_semaphore();
      var MessageReader2;
      (function(MessageReader3) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
        }
        MessageReader3.is = is;
      })(MessageReader2 || (exports.MessageReader = MessageReader2 = {}));
      var AbstractMessageReader2 = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageReader = AbstractMessageReader2;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader2 {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.readSemaphore = new semaphore_1.Semaphore(1);
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          try {
            this.buffer.append(data);
            while (true) {
              if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders(true);
                if (!headers) {
                  return;
                }
                const contentLength = headers.get("content-length");
                if (!contentLength) {
                  this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                  return;
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                  this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                  return;
                }
                this.nextMessageLength = length;
              }
              const body = this.buffer.tryReadBody(this.nextMessageLength);
              if (body === void 0) {
                this.setPartialMessageTimer();
                return;
              }
              this.clearPartialMessageTimer();
              this.nextMessageLength = -1;
              this.readSemaphore.lock(async () => {
                const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                this.callback(message);
              }).catch((error) => {
                this.fireError(error);
              });
            }
          } catch (error) {
            this.fireError(error);
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
      var ral_1 = require_ral();
      var Is2 = require_is();
      var semaphore_1 = require_semaphore();
      var events_1 = require_events();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter2;
      (function(MessageWriter3) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
        }
        MessageWriter3.is = is;
      })(MessageWriter2 || (exports.MessageWriter = MessageWriter2 = {}));
      var AbstractMessageWriter2 = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageWriter = AbstractMessageWriter2;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter2 {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders(lowerCaseKeys = false) {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
              const value = chunk[offset];
              switch (value) {
                case CR:
                  switch (state) {
                    case 0:
                      state = 1;
                      break;
                    case 2:
                      state = 3;
                      break;
                    default:
                      state = 0;
                  }
                  break;
                case LF:
                  switch (state) {
                    case 1:
                      state = 2;
                      break;
                    case 3:
                      state = 4;
                      offset++;
                      break row;
                    default:
                      state = 0;
                  }
                  break;
                default:
                  state = 0;
              }
              offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error(`Message header must separate key and value using ':'
${header}`);
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
      var ral_1 = require_ral();
      var Is2 = require_is();
      var messages_1 = require_messages();
      var linkedMap_1 = require_linkedMap();
      var events_1 = require_events();
      var cancellation_1 = require_cancellation();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is2.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace || (exports.Trace = Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues || (exports.TraceValues = TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString;
      })(Trace || (exports.Trace = Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
      var ConnectionError = class _ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ConnectionError.prototype);
        }
      };
      exports.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
      var IdCancellationReceiverStrategy;
      (function(IdCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
        }
        IdCancellationReceiverStrategy2.is = is;
      })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
      var RequestCancellationReceiverStrategy;
      (function(RequestCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && candidate.kind === "request" && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
        }
        RequestCancellationReceiverStrategy2.is = is;
      })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
      var MessageStrategy;
      (function(MessageStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.handleMessage);
        }
        MessageStrategy2.is = is;
      })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection2(messageReader, messageWriter, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader.onClose(closeHandler);
        messageReader.onError(readErrorHandler);
        messageWriter.onClose(closeHandler);
        messageWriter.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer || messageQueue.size === 0) {
            return;
          }
          timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = void 0;
            processMessageQueue();
          });
        }
        function handleMessage(message) {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
              messageStrategy.handleMessage(message, handleMessage);
            } else {
              handleMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is2.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is2.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch((error) => {
              logger.error(`Sending notification failed.`);
              throw error;
            });
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is2.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is2.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              const last = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last)) {
                paramEnd = paramEnd - 1;
                token = last;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === "function") {
              cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              try {
                responsePromises.set(id, responsePromise);
                await messageWriter.write(requestMessage);
              } catch (error) {
                responsePromises.delete(id);
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
                logger.error(`Sending request failed.`);
                throw error;
              }
            });
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is2.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is2.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is2.func(messageWriter.dispose)) {
              messageWriter.dispose();
            }
            if (Is2.func(messageReader.dispose)) {
              messageReader.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection;
      }
      exports.createMessageConnection = createMessageConnection2;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
      exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
      var messages_1 = require_messages();
      Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap();
      Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable();
      Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events();
      Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation();
      Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var sharedArrayCancellation_1 = require_sharedArrayCancellation();
      Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArraySenderStrategy;
      } });
      Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
      } });
      var messageReader_1 = require_messageReader();
      Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter();
      Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var messageBuffer_1 = require_messageBuffer();
      Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
        return messageBuffer_1.AbstractMessageBuffer;
      } });
      var connection_1 = require_connection();
      Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
        return connection_1.MessageStrategy;
      } });
      var ral_1 = require_ral();
      exports.RAL = ral_1.default;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var api_1 = require_api();
      var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return _MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          api_1.RAL.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports.default = RIL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
      var ril_1 = require_ril();
      ril_1.default.install();
      var api_1 = require_api();
      __exportStar2(require_api(), exports);
      var BrowserMessageReader = class extends api_1.AbstractMessageReader {
        constructor(port) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          port.addEventListener("error", (event) => this.fireError(event));
          port.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports.BrowserMessageReader = BrowserMessageReader;
      var BrowserMessageWriter = class extends api_1.AbstractMessageWriter {
        constructor(port) {
          super();
          this.port = port;
          this.errorCount = 0;
          port.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.port.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports.BrowserMessageWriter = BrowserMessageWriter;
      function createMessageConnection2(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports.createMessageConnection = createMessageConnection2;
    }
  });

  // node_modules/tslib/tslib.es6.mjs
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __addDisposableResource: () => __addDisposableResource,
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldIn: () => __classPrivateFieldIn,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __disposeResources: () => __disposeResources,
    __esDecorate: () => __esDecorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __propKey: () => __propKey,
    __read: () => __read,
    __rest: () => __rest,
    __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
    __runInitializers: () => __runInitializers,
    __setFunctionName: () => __setFunctionName,
    __spread: () => __spread,
    __spreadArray: () => __spreadArray,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values,
    default: () => tslib_es6_default
  });
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
  }
  function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }
  function __disposeResources(env) {
    function fail(e) {
      env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  }
  function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
        return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
      });
    }
    return path;
  }
  var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
  var init_tslib_es6 = __esm({
    "node_modules/tslib/tslib.es6.mjs"() {
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      };
      ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
      };
      tslib_es6_default = {
        __extends,
        __assign,
        __rest,
        __decorate,
        __param,
        __esDecorate,
        __runInitializers,
        __propKey,
        __setFunctionName,
        __metadata,
        __awaiter,
        __generator,
        __createBinding,
        __exportStar,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar,
        __importDefault,
        __classPrivateFieldGet,
        __classPrivateFieldSet,
        __classPrivateFieldIn,
        __addDisposableResource,
        __disposeResources,
        __rewriteRelativeImportExtension
      };
    }
  });

  // node_modules/vscode-languageserver-textdocument/lib/umd/main.js
  var require_main2 = __commonJS({
    "node_modules/vscode-languageserver-textdocument/lib/umd/main.js"(exports, module) {
      (function(factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          var v = factory(__require, exports);
          if (v !== void 0) module.exports = v;
        } else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
        }
      })(function(require2, exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TextDocument = void 0;
        class FullTextDocument2 {
          constructor(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          get uri() {
            return this._uri;
          }
          get languageId() {
            return this._languageId;
          }
          get version() {
            return this._version;
          }
          getText(range) {
            if (range) {
              const start = this.offsetAt(range.start);
              const end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          }
          update(changes, version) {
            for (let change of changes) {
              if (FullTextDocument2.isIncremental(change)) {
                const range = getWellformedRange(change.range);
                const startOffset = this.offsetAt(range.start);
                const endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                const startLine = Math.max(range.start.line, 0);
                const endLine = Math.max(range.end.line, 0);
                let lineOffsets = this._lineOffsets;
                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                  for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                    lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                  }
                } else {
                  if (addedLineOffsets.length < 1e4) {
                    lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                  } else {
                    this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                  }
                }
                const diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                  for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                    lineOffsets[i] = lineOffsets[i] + diff;
                  }
                }
              } else if (FullTextDocument2.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = void 0;
              } else {
                throw new Error("Unknown change event received");
              }
            }
            this._version = version;
          }
          getLineOffsets() {
            if (this._lineOffsets === void 0) {
              this._lineOffsets = computeLineOffsets(this._content, true);
            }
            return this._lineOffsets;
          }
          positionAt(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            let lineOffsets = this.getLineOffsets();
            let low = 0, high = lineOffsets.length;
            if (high === 0) {
              return { line: 0, character: offset };
            }
            while (low < high) {
              let mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            let line = low - 1;
            return { line, character: offset - lineOffsets[line] };
          }
          offsetAt(position) {
            let lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            let lineOffset = lineOffsets[position.line];
            let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          }
          get lineCount() {
            return this.getLineOffsets().length;
          }
          static isIncremental(event) {
            let candidate = event;
            return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
          }
          static isFull(event) {
            let candidate = event;
            return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
          }
        }
        var TextDocument2;
        (function(TextDocument3) {
          function create(uri, languageId, version, content) {
            return new FullTextDocument2(uri, languageId, version, content);
          }
          TextDocument3.create = create;
          function update(document2, changes, version) {
            if (document2 instanceof FullTextDocument2) {
              document2.update(changes, version);
              return document2;
            } else {
              throw new Error("TextDocument.update: document must be created by TextDocument.create");
            }
          }
          TextDocument3.update = update;
          function applyEdits(document2, edits) {
            let text = document2.getText();
            let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
              let diff = a.range.start.line - b.range.start.line;
              if (diff === 0) {
                return a.range.start.character - b.range.start.character;
              }
              return diff;
            });
            let lastModifiedOffset = 0;
            const spans = [];
            for (const e of sortedEdits) {
              let startOffset = document2.offsetAt(e.range.start);
              if (startOffset < lastModifiedOffset) {
                throw new Error("Overlapping edit");
              } else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
              }
              if (e.newText.length) {
                spans.push(e.newText);
              }
              lastModifiedOffset = document2.offsetAt(e.range.end);
            }
            spans.push(text.substr(lastModifiedOffset));
            return spans.join("");
          }
          TextDocument3.applyEdits = applyEdits;
        })(TextDocument2 = exports2.TextDocument || (exports2.TextDocument = {}));
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          const p = data.length / 2 | 0;
          const left = data.slice(0, p);
          const right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          let leftIdx = 0;
          let rightIdx = 0;
          let i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            let ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
        function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
          const result = isAtLineStart ? [textOffset] : [];
          for (let i = 0; i < text.length; i++) {
            let ch = text.charCodeAt(i);
            if (ch === 13 || ch === 10) {
              if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
                i++;
              }
              result.push(textOffset + i + 1);
            }
          }
          return result;
        }
        function getWellformedRange(range) {
          const start = range.start;
          const end = range.end;
          if (start.line > end.line || start.line === end.line && start.character > end.character) {
            return { start: end, end: start };
          }
          return range;
        }
        function getWellformedEdit(textEdit) {
          const range = getWellformedRange(textEdit.range);
          if (range !== textEdit.range) {
            return { newText: textEdit.newText, range };
          }
          return textEdit;
        }
      });
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports.default = RAL;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Disposable = void 0;
      var Disposable4;
      (function(Disposable5) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable5.create = create;
      })(Disposable4 = exports.Disposable || (exports.Disposable = {}));
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Emitter = exports.Event = void 0;
      var ral_1 = require_ral2();
      var Event;
      (function(Event2) {
        const _disposable = { dispose() {
        } };
        Event2.None = function() {
          return _disposable;
        };
      })(Event = exports.Event || (exports.Event = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter = class _Emitter {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = _Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports.Emitter = Emitter;
      Emitter._noop = function() {
      };
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders() {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
              const value = chunk[offset];
              switch (value) {
                case CR:
                  switch (state) {
                    case 0:
                      state = 1;
                      break;
                    case 2:
                      state = 3;
                      break;
                    default:
                      state = 0;
                  }
                  break;
                case LF:
                  switch (state) {
                    case 1:
                      state = 2;
                      break;
                    case 3:
                      state = 4;
                      offset++;
                      break row;
                    default:
                      state = 0;
                  }
                  break;
                default:
                  state = 0;
              }
              offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error("Message header must separate key and value using :");
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ral_1 = require_ral2();
      var disposable_1 = require_disposable2();
      var events_1 = require_events2();
      var messageBuffer_1 = require_messageBuffer2();
      var MessageBuffer = class _MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return _MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new events_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, ral_1.default)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          ral_1.default.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports.default = RIL;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
      var is = require_is2();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
      var ResponseError = class _ResponseError extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, _ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports.ResponseError = ResponseError;
      var ParameterStructures = class _ParameterStructures {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.NotificationType9 = NotificationType9;
      var Message2;
      (function(Message3) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message3.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message3.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message3.isResponse = isResponse;
      })(Message2 = exports.Message || (exports.Message = {}));
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
      "use strict";
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch = exports.Touch || (exports.Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports.LRUCache = LRUCache;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CancellationTokenSource = exports.CancellationToken = void 0;
      var ral_1 = require_ral2();
      var Is2 = require_is2();
      var events_1 = require_events2();
      var CancellationToken;
      (function(CancellationToken2) {
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken2.is = is;
      })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports.CancellationTokenSource = CancellationTokenSource;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
      var ral_1 = require_ral2();
      var Is2 = require_is2();
      var events_1 = require_events2();
      var MessageReader2;
      (function(MessageReader3) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
        }
        MessageReader3.is = is;
      })(MessageReader2 = exports.MessageReader || (exports.MessageReader = {}));
      var AbstractMessageReader2 = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageReader = AbstractMessageReader2;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader2 {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders();
              if (!headers) {
                return;
              }
              const contentLength = headers.get("Content-Length");
              if (!contentLength) {
                throw new Error("Header must provide a Content-Length property.");
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                throw new Error("Content-Length value must be a number.");
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== void 0) {
              p = this.options.contentDecoder.decode(body);
            } else {
              p = Promise.resolve(body);
            }
            p.then((value) => {
              this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                this.callback(msg);
              }, (error) => {
                this.fireError(error);
              });
            }, (error) => {
              this.fireError(error);
            });
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Semaphore = void 0;
      var ral_1 = require_ral2();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports.Semaphore = Semaphore;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
      var ral_1 = require_ral2();
      var Is2 = require_is2();
      var semaphore_1 = require_semaphore2();
      var events_1 = require_events2();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter2;
      (function(MessageWriter3) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
        }
        MessageWriter3.is = is;
      })(MessageWriter2 = exports.MessageWriter || (exports.MessageWriter = {}));
      var AbstractMessageWriter2 = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageWriter = AbstractMessageWriter2;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter2 {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
      var ral_1 = require_ral2();
      var Is2 = require_is2();
      var messages_1 = require_messages2();
      var linkedMap_1 = require_linkedMap2();
      var events_1 = require_events2();
      var cancellation_1 = require_cancellation2();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken = exports.ProgressToken || (exports.ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is2.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace = exports.Trace || (exports.Trace = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString;
      })(Trace = exports.Trace || (exports.Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
      var ConnectionError = class _ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ConnectionError.prototype);
        }
      };
      exports.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.createCancellationTokenSource);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection2(messageReader, messageWriter, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader.onClose(closeHandler);
        messageReader.onError(readErrorHandler);
        messageWriter.onClose(closeHandler);
        messageWriter.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer || messageQueue.size === 0) {
            return;
          }
          timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = void 0;
            processMessageQueue();
          });
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            if (messages_1.Message.isRequest(message)) {
              handleRequest(message);
            } else if (messages_1.Message.isNotification(message)) {
              handleNotification(message);
            } else if (messages_1.Message.isResponse(message)) {
              handleResponse(message);
            } else {
              handleInvalidMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is2.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is2.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is2.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is2.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              const last = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last)) {
                paramEnd = paramEnd - 1;
                token = last;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const result = new Promise((resolve, reject) => {
              const requestMessage = {
                jsonrpc: version,
                id,
                method,
                params: messageParams
              };
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              traceSendingRequest(requestMessage);
              try {
                messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
              } catch (e) {
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
                responsePromise = null;
              }
              if (responsePromise) {
                responsePromises.set(id, responsePromise);
              }
            });
            return result;
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is2.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is2.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is2.func(messageWriter.dispose)) {
              messageWriter.dispose();
            }
            if (Is2.func(messageReader.dispose)) {
              messageReader.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection;
      }
      exports.createMessageConnection = createMessageConnection2;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api2 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
      exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = void 0;
      var messages_1 = require_messages2();
      Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap2();
      Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable2();
      Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events2();
      Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation2();
      Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var messageReader_1 = require_messageReader2();
      Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter2();
      Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var connection_1 = require_connection2();
      Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      var ral_1 = require_ral2();
      exports.RAL = ral_1.default;
    }
  });

  // node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main3 = __commonJS({
    "node_modules/monaco-languageclient/node_modules/vscode-jsonrpc/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
      var ril_1 = require_ril2();
      ril_1.default.install();
      var api_1 = require_api2();
      __exportStar2(require_api2(), exports);
      var BrowserMessageReader = class extends api_1.AbstractMessageReader {
        constructor(context) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          context.addEventListener("error", (event) => this.fireError(event));
          context.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports.BrowserMessageReader = BrowserMessageReader;
      var BrowserMessageWriter = class extends api_1.AbstractMessageWriter {
        constructor(context) {
          super();
          this.context = context;
          this.errorCount = 0;
          context.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.context.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports.BrowserMessageWriter = BrowserMessageWriter;
      function createMessageConnection2(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports.createMessageConnection = createMessageConnection2;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
      var is = require_is3();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
      var ResponseError = class _ResponseError extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, _ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports.ResponseError = ResponseError;
      var ParameterStructures = class _ParameterStructures {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.NotificationType9 = NotificationType9;
      var Message2;
      (function(Message3) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message3.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message3.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message3.isResponse = isResponse;
      })(Message2 || (exports.Message = Message2 = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
      "use strict";
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch || (exports.Touch = Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports.LRUCache = LRUCache;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Disposable = void 0;
      var Disposable4;
      (function(Disposable5) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable5.create = create;
      })(Disposable4 || (exports.Disposable = Disposable4 = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports.default = RAL;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Emitter = exports.Event = void 0;
      var ral_1 = require_ral3();
      var Event;
      (function(Event2) {
        const _disposable = { dispose() {
        } };
        Event2.None = function() {
          return _disposable;
        };
      })(Event || (exports.Event = Event = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter = class _Emitter {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = _Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports.Emitter = Emitter;
      Emitter._noop = function() {
      };
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CancellationTokenSource = exports.CancellationToken = void 0;
      var ral_1 = require_ral3();
      var Is2 = require_is3();
      var events_1 = require_events3();
      var CancellationToken;
      (function(CancellationToken2) {
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken2.is = is;
      })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports.CancellationTokenSource = CancellationTokenSource;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
  var require_sharedArrayCancellation2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
      var cancellation_1 = require_cancellation3();
      var CancellationState;
      (function(CancellationState2) {
        CancellationState2.Continue = 0;
        CancellationState2.Cancelled = 1;
      })(CancellationState || (CancellationState = {}));
      var SharedArraySenderStrategy = class {
        constructor() {
          this.buffers = /* @__PURE__ */ new Map();
        }
        enableCancellation(request) {
          if (request.id === null) {
            return;
          }
          const buffer = new SharedArrayBuffer(4);
          const data = new Int32Array(buffer, 0, 1);
          data[0] = CancellationState.Continue;
          this.buffers.set(request.id, buffer);
          request.$cancellationData = buffer;
        }
        async sendCancellation(_conn, id) {
          const buffer = this.buffers.get(id);
          if (buffer === void 0) {
            return;
          }
          const data = new Int32Array(buffer, 0, 1);
          Atomics.store(data, 0, CancellationState.Cancelled);
        }
        cleanup(id) {
          this.buffers.delete(id);
        }
        dispose() {
          this.buffers.clear();
        }
      };
      exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
      var SharedArrayBufferCancellationToken = class {
        constructor(buffer) {
          this.data = new Int32Array(buffer, 0, 1);
        }
        get isCancellationRequested() {
          return Atomics.load(this.data, 0) === CancellationState.Cancelled;
        }
        get onCancellationRequested() {
          throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
        }
      };
      var SharedArrayBufferCancellationTokenSource = class {
        constructor(buffer) {
          this.token = new SharedArrayBufferCancellationToken(buffer);
        }
        cancel() {
        }
        dispose() {
        }
      };
      var SharedArrayReceiverStrategy = class {
        constructor() {
          this.kind = "request";
        }
        createCancellationTokenSource(request) {
          const buffer = request.$cancellationData;
          if (buffer === void 0) {
            return new cancellation_1.CancellationTokenSource();
          }
          return new SharedArrayBufferCancellationTokenSource(buffer);
        }
      };
      exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Semaphore = void 0;
      var ral_1 = require_ral3();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports.Semaphore = Semaphore;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
      var ral_1 = require_ral3();
      var Is2 = require_is3();
      var events_1 = require_events3();
      var semaphore_1 = require_semaphore3();
      var MessageReader2;
      (function(MessageReader3) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
        }
        MessageReader3.is = is;
      })(MessageReader2 || (exports.MessageReader = MessageReader2 = {}));
      var AbstractMessageReader2 = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageReader = AbstractMessageReader2;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader2 {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.readSemaphore = new semaphore_1.Semaphore(1);
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          try {
            this.buffer.append(data);
            while (true) {
              if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders(true);
                if (!headers) {
                  return;
                }
                const contentLength = headers.get("content-length");
                if (!contentLength) {
                  this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                  return;
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                  this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                  return;
                }
                this.nextMessageLength = length;
              }
              const body = this.buffer.tryReadBody(this.nextMessageLength);
              if (body === void 0) {
                this.setPartialMessageTimer();
                return;
              }
              this.clearPartialMessageTimer();
              this.nextMessageLength = -1;
              this.readSemaphore.lock(async () => {
                const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                this.callback(message);
              }).catch((error) => {
                this.fireError(error);
              });
            }
          } catch (error) {
            this.fireError(error);
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
      var ral_1 = require_ral3();
      var Is2 = require_is3();
      var semaphore_1 = require_semaphore3();
      var events_1 = require_events3();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter2;
      (function(MessageWriter3) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
        }
        MessageWriter3.is = is;
      })(MessageWriter2 || (exports.MessageWriter = MessageWriter2 = {}));
      var AbstractMessageWriter2 = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageWriter = AbstractMessageWriter2;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter2 {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders(lowerCaseKeys = false) {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
              const value = chunk[offset];
              switch (value) {
                case CR:
                  switch (state) {
                    case 0:
                      state = 1;
                      break;
                    case 2:
                      state = 3;
                      break;
                    default:
                      state = 0;
                  }
                  break;
                case LF:
                  switch (state) {
                    case 1:
                      state = 2;
                      break;
                    case 3:
                      state = 4;
                      offset++;
                      break row;
                    default:
                      state = 0;
                  }
                  break;
                default:
                  state = 0;
              }
              offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error(`Message header must separate key and value using ':'
${header}`);
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
      var ral_1 = require_ral3();
      var Is2 = require_is3();
      var messages_1 = require_messages3();
      var linkedMap_1 = require_linkedMap3();
      var events_1 = require_events3();
      var cancellation_1 = require_cancellation3();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is2.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace || (exports.Trace = Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues || (exports.TraceValues = TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString;
      })(Trace || (exports.Trace = Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
      var ConnectionError = class _ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ConnectionError.prototype);
        }
      };
      exports.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
      var IdCancellationReceiverStrategy;
      (function(IdCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
        }
        IdCancellationReceiverStrategy2.is = is;
      })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
      var RequestCancellationReceiverStrategy;
      (function(RequestCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && candidate.kind === "request" && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
        }
        RequestCancellationReceiverStrategy2.is = is;
      })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
      var MessageStrategy;
      (function(MessageStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.handleMessage);
        }
        MessageStrategy2.is = is;
      })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection2(messageReader, messageWriter, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader.onClose(closeHandler);
        messageReader.onError(readErrorHandler);
        messageWriter.onClose(closeHandler);
        messageWriter.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer || messageQueue.size === 0) {
            return;
          }
          timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = void 0;
            processMessageQueue();
          });
        }
        function handleMessage(message) {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
              messageStrategy.handleMessage(message, handleMessage);
            } else {
              handleMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is2.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is2.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch((error) => {
              logger.error(`Sending notification failed.`);
              throw error;
            });
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is2.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is2.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              const last = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last)) {
                paramEnd = paramEnd - 1;
                token = last;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === "function") {
              cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              try {
                await messageWriter.write(requestMessage);
                responsePromises.set(id, responsePromise);
              } catch (error) {
                logger.error(`Sending request failed.`);
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
                throw error;
              }
            });
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is2.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is2.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is2.func(messageWriter.dispose)) {
              messageWriter.dispose();
            }
            if (Is2.func(messageReader.dispose)) {
              messageReader.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection;
      }
      exports.createMessageConnection = createMessageConnection2;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
      exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
      var messages_1 = require_messages3();
      Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap3();
      Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable3();
      Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events3();
      Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation3();
      Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var sharedArrayCancellation_1 = require_sharedArrayCancellation2();
      Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArraySenderStrategy;
      } });
      Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
      } });
      var messageReader_1 = require_messageReader3();
      Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter3();
      Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var messageBuffer_1 = require_messageBuffer3();
      Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
        return messageBuffer_1.AbstractMessageBuffer;
      } });
      var connection_1 = require_connection3();
      Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
        return connection_1.MessageStrategy;
      } });
      var ral_1 = require_ral3();
      exports.RAL = ral_1.default;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var api_1 = require_api3();
      var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return _MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          api_1.RAL.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports.default = RIL;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main4 = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
      var ril_1 = require_ril3();
      ril_1.default.install();
      var api_1 = require_api3();
      __exportStar2(require_api3(), exports);
      var BrowserMessageReader = class extends api_1.AbstractMessageReader {
        constructor(port) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          port.addEventListener("error", (event) => this.fireError(event));
          port.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports.BrowserMessageReader = BrowserMessageReader;
      var BrowserMessageWriter = class extends api_1.AbstractMessageWriter {
        constructor(port) {
          super();
          this.port = port;
          this.errorCount = 0;
          port.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.port.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports.BrowserMessageWriter = BrowserMessageWriter;
      function createMessageConnection2(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports.createMessageConnection = createMessageConnection2;
    }
  });

  // node_modules/vscode-languageserver-types/lib/esm/main.js
  var main_exports = {};
  __export(main_exports, {
    AnnotatedTextEdit: () => AnnotatedTextEdit,
    ChangeAnnotation: () => ChangeAnnotation,
    ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
    CodeAction: () => CodeAction,
    CodeActionContext: () => CodeActionContext,
    CodeActionKind: () => CodeActionKind,
    CodeActionTriggerKind: () => CodeActionTriggerKind,
    CodeDescription: () => CodeDescription,
    CodeLens: () => CodeLens,
    Color: () => Color,
    ColorInformation: () => ColorInformation,
    ColorPresentation: () => ColorPresentation,
    Command: () => Command,
    CompletionItem: () => CompletionItem,
    CompletionItemKind: () => CompletionItemKind,
    CompletionItemLabelDetails: () => CompletionItemLabelDetails,
    CompletionItemTag: () => CompletionItemTag,
    CompletionList: () => CompletionList,
    CreateFile: () => CreateFile,
    DeleteFile: () => DeleteFile,
    Diagnostic: () => Diagnostic,
    DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
    DiagnosticSeverity: () => DiagnosticSeverity,
    DiagnosticTag: () => DiagnosticTag,
    DocumentHighlight: () => DocumentHighlight,
    DocumentHighlightKind: () => DocumentHighlightKind,
    DocumentLink: () => DocumentLink,
    DocumentSymbol: () => DocumentSymbol,
    DocumentUri: () => DocumentUri,
    EOL: () => EOL,
    FoldingRange: () => FoldingRange,
    FoldingRangeKind: () => FoldingRangeKind,
    FormattingOptions: () => FormattingOptions,
    Hover: () => Hover,
    InlayHint: () => InlayHint,
    InlayHintKind: () => InlayHintKind,
    InlayHintLabelPart: () => InlayHintLabelPart,
    InlineCompletionContext: () => InlineCompletionContext,
    InlineCompletionItem: () => InlineCompletionItem,
    InlineCompletionList: () => InlineCompletionList,
    InlineCompletionTriggerKind: () => InlineCompletionTriggerKind,
    InlineValueContext: () => InlineValueContext,
    InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression,
    InlineValueText: () => InlineValueText,
    InlineValueVariableLookup: () => InlineValueVariableLookup,
    InsertReplaceEdit: () => InsertReplaceEdit,
    InsertTextFormat: () => InsertTextFormat,
    InsertTextMode: () => InsertTextMode,
    Location: () => Location,
    LocationLink: () => LocationLink,
    MarkedString: () => MarkedString,
    MarkupContent: () => MarkupContent,
    MarkupKind: () => MarkupKind,
    OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
    ParameterInformation: () => ParameterInformation,
    Position: () => Position,
    Range: () => Range,
    RenameFile: () => RenameFile,
    SelectedCompletionInfo: () => SelectedCompletionInfo,
    SelectionRange: () => SelectionRange,
    SemanticTokenModifiers: () => SemanticTokenModifiers,
    SemanticTokenTypes: () => SemanticTokenTypes,
    SemanticTokens: () => SemanticTokens,
    SignatureInformation: () => SignatureInformation,
    StringValue: () => StringValue,
    SymbolInformation: () => SymbolInformation,
    SymbolKind: () => SymbolKind,
    SymbolTag: () => SymbolTag,
    TextDocument: () => TextDocument,
    TextDocumentEdit: () => TextDocumentEdit,
    TextDocumentIdentifier: () => TextDocumentIdentifier,
    TextDocumentItem: () => TextDocumentItem,
    TextEdit: () => TextEdit,
    URI: () => URI,
    VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
    WorkspaceChange: () => WorkspaceChange,
    WorkspaceEdit: () => WorkspaceEdit,
    WorkspaceFolder: () => WorkspaceFolder,
    WorkspaceSymbol: () => WorkspaceSymbol,
    integer: () => integer,
    uinteger: () => uinteger
  });
  var DocumentUri, URI, integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItemLabelDetails, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, WorkspaceSymbol, DocumentSymbol, CodeActionKind, CodeActionTriggerKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, SemanticTokenTypes, SemanticTokenModifiers, SemanticTokens, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext, InlayHintKind, InlayHintLabelPart, InlayHint, StringValue, InlineCompletionItem, InlineCompletionList, InlineCompletionTriggerKind, SelectedCompletionInfo, InlineCompletionContext, WorkspaceFolder, EOL, TextDocument, FullTextDocument, Is;
  var init_main = __esm({
    "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
      "use strict";
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (DocumentUri = {}));
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI || (URI = {}));
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (integer = {}));
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (uinteger = {}));
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position || (Position = {}));
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
          }
        }
        Range2.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (Range = {}));
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (Location = {}));
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (LocationLink = {}));
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (Color = {}));
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (ColorInformation = {}));
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (ColorPresentation = {}));
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (FoldingRangeKind = {}));
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          const result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (FoldingRange = {}));
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (DiagnosticSeverity = {}));
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (DiagnosticTag = {}));
      (function(CodeDescription2) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (CodeDescription = {}));
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          let result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          let candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (Diagnostic = {}));
      (function(Command2) {
        function create(title, command, ...args) {
          let result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (Command = {}));
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (TextEdit = {}));
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          const result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (ChangeAnnotation = {}));
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          const candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          const candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (TextDocumentEdit = {}));
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          let result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (CreateFile = {}));
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          let result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (RenameFile = {}));
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          let result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (DeleteFile = {}));
      (function(WorkspaceEdit2) {
        function is(value) {
          let candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (WorkspaceEdit = {}));
      TextEditChangeImpl = class {
        constructor(edits, changeAnnotations) {
          this.edits = edits;
          this.changeAnnotations = changeAnnotations;
        }
        insert(position, newText, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit.insert(position, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        replace(range, newText, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit.replace(range, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        delete(range, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit.del(range);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        add(edit) {
          this.edits.push(edit);
        }
        all() {
          return this.edits;
        }
        clear() {
          this.edits.splice(0, this.edits.length);
        }
        assertChangeAnnotations(value) {
          if (value === void 0) {
            throw new Error(`Text edit change is not configured to manage change annotations.`);
          }
        }
      };
      ChangeAnnotations = class {
        constructor(annotations) {
          this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
          this._counter = 0;
          this._size = 0;
        }
        all() {
          return this._annotations;
        }
        get size() {
          return this._size;
        }
        manage(idOrAnnotation, annotation) {
          let id;
          if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
          } else {
            id = this.nextId();
            annotation = idOrAnnotation;
          }
          if (this._annotations[id] !== void 0) {
            throw new Error(`Id ${id} is already in use.`);
          }
          if (annotation === void 0) {
            throw new Error(`No annotation provided for id ${id}`);
          }
          this._annotations[id] = annotation;
          this._size++;
          return id;
        }
        nextId() {
          this._counter++;
          return this._counter.toString();
        }
      };
      WorkspaceChange = class {
        constructor(workspaceEdit) {
          this._textEditChanges = /* @__PURE__ */ Object.create(null);
          if (workspaceEdit !== void 0) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
              this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
              workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              workspaceEdit.documentChanges.forEach((change) => {
                if (TextDocumentEdit.is(change)) {
                  const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                  this._textEditChanges[change.textDocument.uri] = textEditChange;
                }
              });
            } else if (workspaceEdit.changes) {
              Object.keys(workspaceEdit.changes).forEach((key) => {
                const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                this._textEditChanges[key] = textEditChange;
              });
            }
          } else {
            this._workspaceEdit = {};
          }
        }
        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */
        get edit() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        }
        getTextEditChange(key) {
          if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            const textDocument = { uri: key.uri, version: key.version };
            let result = this._textEditChanges[textDocument.uri];
            if (!result) {
              const edits = [];
              const textDocumentEdit = {
                textDocument,
                edits
              };
              this._workspaceEdit.documentChanges.push(textDocumentEdit);
              result = new TextEditChangeImpl(edits, this._changeAnnotations);
              this._textEditChanges[textDocument.uri] = result;
            }
            return result;
          } else {
            this.initChanges();
            if (this._workspaceEdit.changes === void 0) {
              throw new Error("Workspace edit is not configured for normal text edit changes.");
            }
            let result = this._textEditChanges[key];
            if (!result) {
              let edits = [];
              this._workspaceEdit.changes[key] = edits;
              result = new TextEditChangeImpl(edits);
              this._textEditChanges[key] = result;
            }
            return result;
          }
        }
        initDocumentChanges() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        }
        initChanges() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
          }
        }
        createFile(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = CreateFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
        renameFile(oldUri, newUri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = RenameFile.create(oldUri, newUri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
        deleteFile(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = DeleteFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
      };
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (TextDocumentItem = {}));
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          const candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (MarkupKind = {}));
      (function(MarkupContent2) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (MarkupContent = {}));
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (CompletionItemKind = {}));
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (InsertTextFormat = {}));
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (CompletionItemTag = {}));
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          const candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (InsertReplaceEdit = {}));
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (InsertTextMode = {}));
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          const candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (CompletionItem = {}));
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (CompletionList = {}));
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          const candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (MarkedString = {}));
      (function(Hover2) {
        function is(value) {
          let candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (Hover = {}));
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (ParameterInformation = {}));
      (function(SignatureInformation2) {
        function create(label, documentation, ...parameters) {
          let result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (SignatureInformation = {}));
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (DocumentHighlightKind = {}));
      (function(DocumentHighlight2) {
        function create(range, kind) {
          let result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (DocumentHighlight = {}));
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (SymbolKind = {}));
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (SymbolTag = {}));
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          let result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (SymbolInformation = {}));
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (WorkspaceSymbol = {}));
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          let result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          let candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (DocumentSymbol = {}));
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (CodeActionKind = {}));
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          let result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (CodeActionContext = {}));
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          let result = { title };
          let checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          let candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (CodeAction = {}));
      (function(CodeLens2) {
        function create(range, data) {
          let result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (CodeLens = {}));
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (FormattingOptions = {}));
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (DocumentLink = {}));
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (SelectionRange = {}));
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (SemanticTokenTypes = {}));
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
      (function(SemanticTokens2) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (SemanticTokens = {}));
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (InlineValueText = {}));
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          const candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (InlineValueContext = {}));
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (InlayHintKind = {}));
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (InlayHintLabelPart = {}));
      (function(InlayHint2) {
        function create(position, label, kind) {
          const result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (InlayHint = {}));
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (StringValue = {}));
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (InlineCompletionItem = {}));
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (InlineCompletionList = {}));
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (InlineCompletionContext = {}));
      (function(WorkspaceFolder2) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (WorkspaceFolder = {}));
      EOL = ["\n", "\r\n", "\r"];
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document2, edits) {
          let text = document2.getText();
          let sortedEdits = mergeSort(edits, (a, b) => {
            let diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          let lastModifiedOffset = text.length;
          for (let i = sortedEdits.length - 1; i >= 0; i--) {
            let e = sortedEdits[i];
            let startOffset = document2.offsetAt(e.range.start);
            let endOffset = document2.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          const p = data.length / 2 | 0;
          const left = data.slice(0, p);
          const right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          let leftIdx = 0;
          let rightIdx = 0;
          let i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            let ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument || (TextDocument = {}));
      FullTextDocument = class {
        constructor(uri, languageId, version, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version;
          this._content = content;
          this._lineOffsets = void 0;
        }
        get uri() {
          return this._uri;
        }
        get languageId() {
          return this._languageId;
        }
        get version() {
          return this._version;
        }
        getText(range) {
          if (range) {
            let start = this.offsetAt(range.start);
            let end = this.offsetAt(range.end);
            return this._content.substring(start, end);
          }
          return this._content;
        }
        update(event, version) {
          this._content = event.text;
          this._version = version;
          this._lineOffsets = void 0;
        }
        getLineOffsets() {
          if (this._lineOffsets === void 0) {
            let lineOffsets = [];
            let text = this._content;
            let isLineStart = true;
            for (let i = 0; i < text.length; i++) {
              if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
              }
              let ch = text.charAt(i);
              isLineStart = ch === "\r" || ch === "\n";
              if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                i++;
              }
            }
            if (isLineStart && text.length > 0) {
              lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
          }
          return this._lineOffsets;
        }
        positionAt(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          let lineOffsets = this.getLineOffsets();
          let low = 0, high = lineOffsets.length;
          if (high === 0) {
            return Position.create(0, offset);
          }
          while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          let line = low - 1;
          return Position.create(line, offset - lineOffsets[line]);
        }
        offsetAt(position) {
          let lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          let lineOffset = lineOffsets[position.line];
          let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        }
        get lineCount() {
          return this.getLineOffsets().length;
        }
      };
      (function(Is2) {
        const toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/messages.js
  var require_messages4 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
      var vscode_jsonrpc_1 = require_main4();
      var MessageDirection;
      (function(MessageDirection2) {
        MessageDirection2["clientToServer"] = "clientToServer";
        MessageDirection2["serverToClient"] = "serverToClient";
        MessageDirection2["both"] = "both";
      })(MessageDirection || (exports.MessageDirection = MessageDirection = {}));
      var RegistrationType = class {
        constructor(method) {
          this.method = method;
        }
      };
      exports.RegistrationType = RegistrationType;
      var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
        constructor(method) {
          super(method);
        }
      };
      exports.ProtocolRequestType0 = ProtocolRequestType0;
      var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports.ProtocolRequestType = ProtocolRequestType;
      var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
        constructor(method) {
          super(method);
        }
      };
      exports.ProtocolNotificationType0 = ProtocolNotificationType0;
      var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports.ProtocolNotificationType = ProtocolNotificationType;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
  var require_is4 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports.typedArray = typedArray;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      exports.objectLiteral = objectLiteral;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
  var require_protocol_implementation = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ImplementationRequest = void 0;
      var messages_1 = require_messages4();
      var ImplementationRequest;
      (function(ImplementationRequest2) {
        ImplementationRequest2.method = "textDocument/implementation";
        ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
      })(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
  var require_protocol_typeDefinition = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeDefinitionRequest = void 0;
      var messages_1 = require_messages4();
      var TypeDefinitionRequest;
      (function(TypeDefinitionRequest2) {
        TypeDefinitionRequest2.method = "textDocument/typeDefinition";
        TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
      })(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
  var require_protocol_workspaceFolder = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
      var messages_1 = require_messages4();
      var WorkspaceFoldersRequest;
      (function(WorkspaceFoldersRequest2) {
        WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
        WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
      })(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
      var DidChangeWorkspaceFoldersNotification;
      (function(DidChangeWorkspaceFoldersNotification2) {
        DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
        DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
      })(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
  var require_protocol_configuration = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConfigurationRequest = void 0;
      var messages_1 = require_messages4();
      var ConfigurationRequest;
      (function(ConfigurationRequest2) {
        ConfigurationRequest2.method = "workspace/configuration";
        ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
      })(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
  var require_protocol_colorProvider = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
      var messages_1 = require_messages4();
      var DocumentColorRequest;
      (function(DocumentColorRequest2) {
        DocumentColorRequest2.method = "textDocument/documentColor";
        DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
      })(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));
      var ColorPresentationRequest;
      (function(ColorPresentationRequest2) {
        ColorPresentationRequest2.method = "textDocument/colorPresentation";
        ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
      })(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
  var require_protocol_foldingRange = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = void 0;
      var messages_1 = require_messages4();
      var FoldingRangeRequest;
      (function(FoldingRangeRequest2) {
        FoldingRangeRequest2.method = "textDocument/foldingRange";
        FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
      })(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));
      var FoldingRangeRefreshRequest;
      (function(FoldingRangeRefreshRequest2) {
        FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
        FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
      })(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
  var require_protocol_declaration = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeclarationRequest = void 0;
      var messages_1 = require_messages4();
      var DeclarationRequest;
      (function(DeclarationRequest2) {
        DeclarationRequest2.method = "textDocument/declaration";
        DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
      })(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
  var require_protocol_selectionRange = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectionRangeRequest = void 0;
      var messages_1 = require_messages4();
      var SelectionRangeRequest;
      (function(SelectionRangeRequest2) {
        SelectionRangeRequest2.method = "textDocument/selectionRange";
        SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
      })(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
  var require_protocol_progress = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
      var vscode_jsonrpc_1 = require_main4();
      var messages_1 = require_messages4();
      var WorkDoneProgress;
      (function(WorkDoneProgress2) {
        WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
        function is(value) {
          return value === WorkDoneProgress2.type;
        }
        WorkDoneProgress2.is = is;
      })(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));
      var WorkDoneProgressCreateRequest;
      (function(WorkDoneProgressCreateRequest2) {
        WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
        WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
      })(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
      var WorkDoneProgressCancelNotification;
      (function(WorkDoneProgressCancelNotification2) {
        WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
        WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
      })(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
  var require_protocol_callHierarchy = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages4();
      var CallHierarchyPrepareRequest;
      (function(CallHierarchyPrepareRequest2) {
        CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
        CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
      })(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
      var CallHierarchyIncomingCallsRequest;
      (function(CallHierarchyIncomingCallsRequest2) {
        CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
        CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
      })(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
      var CallHierarchyOutgoingCallsRequest;
      (function(CallHierarchyOutgoingCallsRequest2) {
        CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
        CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
      })(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
  var require_protocol_semanticTokens = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
      var messages_1 = require_messages4();
      var TokenFormat;
      (function(TokenFormat2) {
        TokenFormat2.Relative = "relative";
      })(TokenFormat || (exports.TokenFormat = TokenFormat = {}));
      var SemanticTokensRegistrationType;
      (function(SemanticTokensRegistrationType2) {
        SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
        SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
      })(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
      var SemanticTokensRequest;
      (function(SemanticTokensRequest2) {
        SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
        SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
        SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));
      var SemanticTokensDeltaRequest;
      (function(SemanticTokensDeltaRequest2) {
        SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
        SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
        SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
      var SemanticTokensRangeRequest;
      (function(SemanticTokensRangeRequest2) {
        SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
        SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
        SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
      var SemanticTokensRefreshRequest;
      (function(SemanticTokensRefreshRequest2) {
        SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
        SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
      })(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
  var require_protocol_showDocument = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShowDocumentRequest = void 0;
      var messages_1 = require_messages4();
      var ShowDocumentRequest;
      (function(ShowDocumentRequest2) {
        ShowDocumentRequest2.method = "window/showDocument";
        ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
      })(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
  var require_protocol_linkedEditingRange = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LinkedEditingRangeRequest = void 0;
      var messages_1 = require_messages4();
      var LinkedEditingRangeRequest;
      (function(LinkedEditingRangeRequest2) {
        LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
        LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
      })(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
  var require_protocol_fileOperations = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
      var messages_1 = require_messages4();
      var FileOperationPatternKind;
      (function(FileOperationPatternKind2) {
        FileOperationPatternKind2.file = "file";
        FileOperationPatternKind2.folder = "folder";
      })(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));
      var WillCreateFilesRequest;
      (function(WillCreateFilesRequest2) {
        WillCreateFilesRequest2.method = "workspace/willCreateFiles";
        WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
      })(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));
      var DidCreateFilesNotification;
      (function(DidCreateFilesNotification2) {
        DidCreateFilesNotification2.method = "workspace/didCreateFiles";
        DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
      })(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));
      var WillRenameFilesRequest;
      (function(WillRenameFilesRequest2) {
        WillRenameFilesRequest2.method = "workspace/willRenameFiles";
        WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
      })(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));
      var DidRenameFilesNotification;
      (function(DidRenameFilesNotification2) {
        DidRenameFilesNotification2.method = "workspace/didRenameFiles";
        DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
      })(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));
      var DidDeleteFilesNotification;
      (function(DidDeleteFilesNotification2) {
        DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
        DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
      })(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
      var WillDeleteFilesRequest;
      (function(WillDeleteFilesRequest2) {
        WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
        WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
      })(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
  var require_protocol_moniker = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
      var messages_1 = require_messages4();
      var UniquenessLevel;
      (function(UniquenessLevel2) {
        UniquenessLevel2.document = "document";
        UniquenessLevel2.project = "project";
        UniquenessLevel2.group = "group";
        UniquenessLevel2.scheme = "scheme";
        UniquenessLevel2.global = "global";
      })(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));
      var MonikerKind;
      (function(MonikerKind2) {
        MonikerKind2.$import = "import";
        MonikerKind2.$export = "export";
        MonikerKind2.local = "local";
      })(MonikerKind || (exports.MonikerKind = MonikerKind = {}));
      var MonikerRequest;
      (function(MonikerRequest2) {
        MonikerRequest2.method = "textDocument/moniker";
        MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
      })(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
  var require_protocol_typeHierarchy = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages4();
      var TypeHierarchyPrepareRequest;
      (function(TypeHierarchyPrepareRequest2) {
        TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
        TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
      })(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
      var TypeHierarchySupertypesRequest;
      (function(TypeHierarchySupertypesRequest2) {
        TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
        TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
      })(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
      var TypeHierarchySubtypesRequest;
      (function(TypeHierarchySubtypesRequest2) {
        TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
        TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
      })(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
  var require_protocol_inlineValue = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
      var messages_1 = require_messages4();
      var InlineValueRequest;
      (function(InlineValueRequest2) {
        InlineValueRequest2.method = "textDocument/inlineValue";
        InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
      })(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));
      var InlineValueRefreshRequest;
      (function(InlineValueRefreshRequest2) {
        InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
        InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
      })(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
  var require_protocol_inlayHint = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
      var messages_1 = require_messages4();
      var InlayHintRequest;
      (function(InlayHintRequest2) {
        InlayHintRequest2.method = "textDocument/inlayHint";
        InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
      })(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));
      var InlayHintResolveRequest;
      (function(InlayHintResolveRequest2) {
        InlayHintResolveRequest2.method = "inlayHint/resolve";
        InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
      })(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));
      var InlayHintRefreshRequest;
      (function(InlayHintRefreshRequest2) {
        InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
        InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
      })(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
  var require_protocol_diagnostic = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
      var vscode_jsonrpc_1 = require_main4();
      var Is2 = require_is4();
      var messages_1 = require_messages4();
      var DiagnosticServerCancellationData;
      (function(DiagnosticServerCancellationData2) {
        function is(value) {
          const candidate = value;
          return candidate && Is2.boolean(candidate.retriggerRequest);
        }
        DiagnosticServerCancellationData2.is = is;
      })(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
      var DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2.Full = "full";
        DocumentDiagnosticReportKind2.Unchanged = "unchanged";
      })(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
      var DocumentDiagnosticRequest;
      (function(DocumentDiagnosticRequest2) {
        DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
        DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
        DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
      var WorkspaceDiagnosticRequest;
      (function(WorkspaceDiagnosticRequest2) {
        WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
        WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
        WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
      var DiagnosticRefreshRequest;
      (function(DiagnosticRefreshRequest2) {
        DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
        DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
      })(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
  var require_protocol_notebook = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
      var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
      var Is2 = require_is4();
      var messages_1 = require_messages4();
      var NotebookCellKind;
      (function(NotebookCellKind2) {
        NotebookCellKind2.Markup = 1;
        NotebookCellKind2.Code = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        NotebookCellKind2.is = is;
      })(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
      var ExecutionSummary;
      (function(ExecutionSummary2) {
        function create(executionOrder, success) {
          const result = { executionOrder };
          if (success === true || success === false) {
            result.success = success;
          }
          return result;
        }
        ExecutionSummary2.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
        }
        ExecutionSummary2.is = is;
        function equals(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          return one.executionOrder === other.executionOrder && one.success === other.success;
        }
        ExecutionSummary2.equals = equals;
      })(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));
      var NotebookCell;
      (function(NotebookCell2) {
        function create(kind, document2) {
          return { kind, document: document2 };
        }
        NotebookCell2.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
        }
        NotebookCell2.is = is;
        function diff(one, two) {
          const result = /* @__PURE__ */ new Set();
          if (one.document !== two.document) {
            result.add("document");
          }
          if (one.kind !== two.kind) {
            result.add("kind");
          }
          if (one.executionSummary !== two.executionSummary) {
            result.add("executionSummary");
          }
          if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add("metadata");
          }
          if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add("executionSummary");
          }
          return result;
        }
        NotebookCell2.diff = diff;
        function equalsMetadata(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          if (typeof one !== typeof other) {
            return false;
          }
          if (typeof one !== "object") {
            return false;
          }
          const oneArray = Array.isArray(one);
          const otherArray = Array.isArray(other);
          if (oneArray !== otherArray) {
            return false;
          }
          if (oneArray && otherArray) {
            if (one.length !== other.length) {
              return false;
            }
            for (let i = 0; i < one.length; i++) {
              if (!equalsMetadata(one[i], other[i])) {
                return false;
              }
            }
          }
          if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
              return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
              return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
              const prop = oneKeys[i];
              if (!equalsMetadata(one[prop], other[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      })(NotebookCell || (exports.NotebookCell = NotebookCell = {}));
      var NotebookDocument;
      (function(NotebookDocument2) {
        function create(uri, notebookType, version, cells) {
          return { uri, notebookType, version, cells };
        }
        NotebookDocument2.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
        }
        NotebookDocument2.is = is;
      })(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));
      var NotebookDocumentSyncRegistrationType;
      (function(NotebookDocumentSyncRegistrationType2) {
        NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
        NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
        NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
      })(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
      var DidOpenNotebookDocumentNotification;
      (function(DidOpenNotebookDocumentNotification2) {
        DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
        DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
        DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
      var NotebookCellArrayChange;
      (function(NotebookCellArrayChange2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
        }
        NotebookCellArrayChange2.is = is;
        function create(start, deleteCount, cells) {
          const result = { start, deleteCount };
          if (cells !== void 0) {
            result.cells = cells;
          }
          return result;
        }
        NotebookCellArrayChange2.create = create;
      })(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));
      var DidChangeNotebookDocumentNotification;
      (function(DidChangeNotebookDocumentNotification2) {
        DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
        DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
        DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
      var DidSaveNotebookDocumentNotification;
      (function(DidSaveNotebookDocumentNotification2) {
        DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
        DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
        DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
      var DidCloseNotebookDocumentNotification;
      (function(DidCloseNotebookDocumentNotification2) {
        DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
        DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
        DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
  var require_protocol_inlineCompletion = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InlineCompletionRequest = void 0;
      var messages_1 = require_messages4();
      var InlineCompletionRequest;
      (function(InlineCompletionRequest2) {
        InlineCompletionRequest2.method = "textDocument/inlineCompletion";
        InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
      })(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.js
  var require_protocol = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
      exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
      exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages4();
      var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
      var Is2 = require_is4();
      var protocol_implementation_1 = require_protocol_implementation();
      Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
        return protocol_implementation_1.ImplementationRequest;
      } });
      var protocol_typeDefinition_1 = require_protocol_typeDefinition();
      Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
        return protocol_typeDefinition_1.TypeDefinitionRequest;
      } });
      var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
      Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
      } });
      Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
      } });
      var protocol_configuration_1 = require_protocol_configuration();
      Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
        return protocol_configuration_1.ConfigurationRequest;
      } });
      var protocol_colorProvider_1 = require_protocol_colorProvider();
      Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.DocumentColorRequest;
      } });
      Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.ColorPresentationRequest;
      } });
      var protocol_foldingRange_1 = require_protocol_foldingRange();
      Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRequest;
      } });
      Object.defineProperty(exports, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRefreshRequest;
      } });
      var protocol_declaration_1 = require_protocol_declaration();
      Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
        return protocol_declaration_1.DeclarationRequest;
      } });
      var protocol_selectionRange_1 = require_protocol_selectionRange();
      Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
        return protocol_selectionRange_1.SelectionRangeRequest;
      } });
      var protocol_progress_1 = require_protocol_progress();
      Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgress;
      } });
      Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCreateRequest;
      } });
      Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCancelNotification;
      } });
      var protocol_callHierarchy_1 = require_protocol_callHierarchy();
      Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
      } });
      Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
      } });
      Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
      } });
      var protocol_semanticTokens_1 = require_protocol_semanticTokens();
      Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.TokenFormat;
      } });
      Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRequest;
      } });
      Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
      } });
      Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
      } });
      Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
      } });
      Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
      } });
      var protocol_showDocument_1 = require_protocol_showDocument();
      Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
        return protocol_showDocument_1.ShowDocumentRequest;
      } });
      var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
      Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
      } });
      var protocol_fileOperations_1 = require_protocol_fileOperations();
      Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
        return protocol_fileOperations_1.FileOperationPatternKind;
      } });
      Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidCreateFilesNotification;
      } });
      Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillCreateFilesRequest;
      } });
      Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidRenameFilesNotification;
      } });
      Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillRenameFilesRequest;
      } });
      Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidDeleteFilesNotification;
      } });
      Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillDeleteFilesRequest;
      } });
      var protocol_moniker_1 = require_protocol_moniker();
      Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
        return protocol_moniker_1.UniquenessLevel;
      } });
      Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerKind;
      } });
      Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerRequest;
      } });
      var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
      Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
      } });
      Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
      } });
      Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
      } });
      var protocol_inlineValue_1 = require_protocol_inlineValue();
      Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRequest;
      } });
      Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRefreshRequest;
      } });
      var protocol_inlayHint_1 = require_protocol_inlayHint();
      Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRequest;
      } });
      Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintResolveRequest;
      } });
      Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRefreshRequest;
      } });
      var protocol_diagnostic_1 = require_protocol_diagnostic();
      Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticServerCancellationData;
      } });
      Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
      } });
      Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticRequest;
      } });
      Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
      } });
      Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticRefreshRequest;
      } });
      var protocol_notebook_1 = require_protocol_notebook();
      Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellKind;
      } });
      Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function() {
        return protocol_notebook_1.ExecutionSummary;
      } });
      Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCell;
      } });
      Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocument;
      } });
      Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
      } });
      Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
      } });
      Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellArrayChange;
      } });
      Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
      } });
      Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
      } });
      Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
      } });
      var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
      Object.defineProperty(exports, "InlineCompletionRequest", { enumerable: true, get: function() {
        return protocol_inlineCompletion_1.InlineCompletionRequest;
      } });
      var TextDocumentFilter;
      (function(TextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is2.string(candidate) || (Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
        }
        TextDocumentFilter2.is = is;
      })(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
      var NotebookDocumentFilter;
      (function(NotebookDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
        }
        NotebookDocumentFilter2.is = is;
      })(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
      var NotebookCellTextDocumentFilter;
      (function(NotebookCellTextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
        }
        NotebookCellTextDocumentFilter2.is = is;
      })(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
      var DocumentSelector;
      (function(DocumentSelector2) {
        function is(value) {
          if (!Array.isArray(value)) {
            return false;
          }
          for (let elem of value) {
            if (!Is2.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
              return false;
            }
          }
          return true;
        }
        DocumentSelector2.is = is;
      })(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
      var RegistrationRequest;
      (function(RegistrationRequest2) {
        RegistrationRequest2.method = "client/registerCapability";
        RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
      })(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
      var UnregistrationRequest;
      (function(UnregistrationRequest2) {
        UnregistrationRequest2.method = "client/unregisterCapability";
        UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
      })(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
      var ResourceOperationKind;
      (function(ResourceOperationKind2) {
        ResourceOperationKind2.Create = "create";
        ResourceOperationKind2.Rename = "rename";
        ResourceOperationKind2.Delete = "delete";
      })(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
      var FailureHandlingKind;
      (function(FailureHandlingKind2) {
        FailureHandlingKind2.Abort = "abort";
        FailureHandlingKind2.Transactional = "transactional";
        FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
        FailureHandlingKind2.Undo = "undo";
      })(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
      var PositionEncodingKind;
      (function(PositionEncodingKind2) {
        PositionEncodingKind2.UTF8 = "utf-8";
        PositionEncodingKind2.UTF16 = "utf-16";
        PositionEncodingKind2.UTF32 = "utf-32";
      })(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
      var StaticRegistrationOptions;
      (function(StaticRegistrationOptions2) {
        function hasId(value) {
          const candidate = value;
          return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
        }
        StaticRegistrationOptions2.hasId = hasId;
      })(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
      var TextDocumentRegistrationOptions;
      (function(TextDocumentRegistrationOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
        }
        TextDocumentRegistrationOptions2.is = is;
      })(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
      var WorkDoneProgressOptions;
      (function(WorkDoneProgressOptions2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
        }
        WorkDoneProgressOptions2.is = is;
        function hasWorkDoneProgress(value) {
          const candidate = value;
          return candidate && Is2.boolean(candidate.workDoneProgress);
        }
        WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
      })(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
      var InitializeRequest;
      (function(InitializeRequest2) {
        InitializeRequest2.method = "initialize";
        InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
      })(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
      var InitializeErrorCodes;
      (function(InitializeErrorCodes2) {
        InitializeErrorCodes2.unknownProtocolVersion = 1;
      })(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
      var InitializedNotification;
      (function(InitializedNotification2) {
        InitializedNotification2.method = "initialized";
        InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
      })(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
      var ShutdownRequest;
      (function(ShutdownRequest2) {
        ShutdownRequest2.method = "shutdown";
        ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
      })(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
      var ExitNotification;
      (function(ExitNotification2) {
        ExitNotification2.method = "exit";
        ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
      })(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
      var DidChangeConfigurationNotification;
      (function(DidChangeConfigurationNotification2) {
        DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
        DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
      })(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
      var MessageType;
      (function(MessageType2) {
        MessageType2.Error = 1;
        MessageType2.Warning = 2;
        MessageType2.Info = 3;
        MessageType2.Log = 4;
        MessageType2.Debug = 5;
      })(MessageType || (exports.MessageType = MessageType = {}));
      var ShowMessageNotification;
      (function(ShowMessageNotification2) {
        ShowMessageNotification2.method = "window/showMessage";
        ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
      })(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
      var ShowMessageRequest;
      (function(ShowMessageRequest2) {
        ShowMessageRequest2.method = "window/showMessageRequest";
        ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
      })(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
      var LogMessageNotification;
      (function(LogMessageNotification2) {
        LogMessageNotification2.method = "window/logMessage";
        LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
      })(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
      var TelemetryEventNotification;
      (function(TelemetryEventNotification2) {
        TelemetryEventNotification2.method = "telemetry/event";
        TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
      })(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
      var TextDocumentSyncKind;
      (function(TextDocumentSyncKind2) {
        TextDocumentSyncKind2.None = 0;
        TextDocumentSyncKind2.Full = 1;
        TextDocumentSyncKind2.Incremental = 2;
      })(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));
      var DidOpenTextDocumentNotification;
      (function(DidOpenTextDocumentNotification2) {
        DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
        DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
      })(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
      var TextDocumentContentChangeEvent;
      (function(TextDocumentContentChangeEvent2) {
        function isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        TextDocumentContentChangeEvent2.isIncremental = isIncremental;
        function isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
        TextDocumentContentChangeEvent2.isFull = isFull;
      })(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
      var DidChangeTextDocumentNotification;
      (function(DidChangeTextDocumentNotification2) {
        DidChangeTextDocumentNotification2.method = "textDocument/didChange";
        DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
      })(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
      var DidCloseTextDocumentNotification;
      (function(DidCloseTextDocumentNotification2) {
        DidCloseTextDocumentNotification2.method = "textDocument/didClose";
        DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
      })(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
      var DidSaveTextDocumentNotification;
      (function(DidSaveTextDocumentNotification2) {
        DidSaveTextDocumentNotification2.method = "textDocument/didSave";
        DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
      })(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
      var TextDocumentSaveReason;
      (function(TextDocumentSaveReason2) {
        TextDocumentSaveReason2.Manual = 1;
        TextDocumentSaveReason2.AfterDelay = 2;
        TextDocumentSaveReason2.FocusOut = 3;
      })(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
      var WillSaveTextDocumentNotification;
      (function(WillSaveTextDocumentNotification2) {
        WillSaveTextDocumentNotification2.method = "textDocument/willSave";
        WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
      })(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
      var WillSaveTextDocumentWaitUntilRequest;
      (function(WillSaveTextDocumentWaitUntilRequest2) {
        WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
        WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
      })(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
      var DidChangeWatchedFilesNotification;
      (function(DidChangeWatchedFilesNotification2) {
        DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
        DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
      })(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
      var FileChangeType;
      (function(FileChangeType2) {
        FileChangeType2.Created = 1;
        FileChangeType2.Changed = 2;
        FileChangeType2.Deleted = 3;
      })(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
      var RelativePattern;
      (function(RelativePattern2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
        }
        RelativePattern2.is = is;
      })(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
      var WatchKind;
      (function(WatchKind2) {
        WatchKind2.Create = 1;
        WatchKind2.Change = 2;
        WatchKind2.Delete = 4;
      })(WatchKind || (exports.WatchKind = WatchKind = {}));
      var PublishDiagnosticsNotification;
      (function(PublishDiagnosticsNotification2) {
        PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
        PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
      })(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
      var CompletionTriggerKind;
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2.Invoked = 1;
        CompletionTriggerKind2.TriggerCharacter = 2;
        CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
      })(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
      var CompletionRequest;
      (function(CompletionRequest2) {
        CompletionRequest2.method = "textDocument/completion";
        CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
      })(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
      var CompletionResolveRequest;
      (function(CompletionResolveRequest2) {
        CompletionResolveRequest2.method = "completionItem/resolve";
        CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
      })(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
      var HoverRequest;
      (function(HoverRequest2) {
        HoverRequest2.method = "textDocument/hover";
        HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
      })(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
      var SignatureHelpTriggerKind;
      (function(SignatureHelpTriggerKind2) {
        SignatureHelpTriggerKind2.Invoked = 1;
        SignatureHelpTriggerKind2.TriggerCharacter = 2;
        SignatureHelpTriggerKind2.ContentChange = 3;
      })(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
      var SignatureHelpRequest;
      (function(SignatureHelpRequest2) {
        SignatureHelpRequest2.method = "textDocument/signatureHelp";
        SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
      })(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
      var DefinitionRequest;
      (function(DefinitionRequest2) {
        DefinitionRequest2.method = "textDocument/definition";
        DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
      })(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
      var ReferencesRequest;
      (function(ReferencesRequest2) {
        ReferencesRequest2.method = "textDocument/references";
        ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
      })(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
      var DocumentHighlightRequest;
      (function(DocumentHighlightRequest2) {
        DocumentHighlightRequest2.method = "textDocument/documentHighlight";
        DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
      })(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
      var DocumentSymbolRequest;
      (function(DocumentSymbolRequest2) {
        DocumentSymbolRequest2.method = "textDocument/documentSymbol";
        DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
      })(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
      var CodeActionRequest;
      (function(CodeActionRequest2) {
        CodeActionRequest2.method = "textDocument/codeAction";
        CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
      })(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
      var CodeActionResolveRequest;
      (function(CodeActionResolveRequest2) {
        CodeActionResolveRequest2.method = "codeAction/resolve";
        CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
      })(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
      var WorkspaceSymbolRequest;
      (function(WorkspaceSymbolRequest2) {
        WorkspaceSymbolRequest2.method = "workspace/symbol";
        WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
      })(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
      var WorkspaceSymbolResolveRequest;
      (function(WorkspaceSymbolResolveRequest2) {
        WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
        WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
      })(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
      var CodeLensRequest;
      (function(CodeLensRequest2) {
        CodeLensRequest2.method = "textDocument/codeLens";
        CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
      })(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
      var CodeLensResolveRequest;
      (function(CodeLensResolveRequest2) {
        CodeLensResolveRequest2.method = "codeLens/resolve";
        CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
      })(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
      var CodeLensRefreshRequest;
      (function(CodeLensRefreshRequest2) {
        CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
        CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
      })(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
      var DocumentLinkRequest;
      (function(DocumentLinkRequest2) {
        DocumentLinkRequest2.method = "textDocument/documentLink";
        DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
      })(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
      var DocumentLinkResolveRequest;
      (function(DocumentLinkResolveRequest2) {
        DocumentLinkResolveRequest2.method = "documentLink/resolve";
        DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
      })(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
      var DocumentFormattingRequest;
      (function(DocumentFormattingRequest2) {
        DocumentFormattingRequest2.method = "textDocument/formatting";
        DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
      })(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
      var DocumentRangeFormattingRequest;
      (function(DocumentRangeFormattingRequest2) {
        DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
        DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
      })(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
      var DocumentRangesFormattingRequest;
      (function(DocumentRangesFormattingRequest2) {
        DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
        DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
      })(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
      var DocumentOnTypeFormattingRequest;
      (function(DocumentOnTypeFormattingRequest2) {
        DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
        DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
      })(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
      var PrepareSupportDefaultBehavior;
      (function(PrepareSupportDefaultBehavior2) {
        PrepareSupportDefaultBehavior2.Identifier = 1;
      })(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
      var RenameRequest;
      (function(RenameRequest2) {
        RenameRequest2.method = "textDocument/rename";
        RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
      })(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
      var PrepareRenameRequest;
      (function(PrepareRenameRequest2) {
        PrepareRenameRequest2.method = "textDocument/prepareRename";
        PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
      })(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
      var ExecuteCommandRequest;
      (function(ExecuteCommandRequest2) {
        ExecuteCommandRequest2.method = "workspace/executeCommand";
        ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
      })(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
      var ApplyWorkspaceEditRequest;
      (function(ApplyWorkspaceEditRequest2) {
        ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
        ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
      })(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/connection.js
  var require_connection4 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createProtocolConnection = void 0;
      var vscode_jsonrpc_1 = require_main4();
      function createProtocolConnection(input, output, logger, options) {
        if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
      }
      exports.createProtocolConnection = createProtocolConnection;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/api.js
  var require_api4 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
      __exportStar2(require_main4(), exports);
      __exportStar2((init_main(), __toCommonJS(main_exports)), exports);
      __exportStar2(require_messages4(), exports);
      __exportStar2(require_protocol(), exports);
      var connection_1 = require_connection4();
      Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
        return connection_1.createProtocolConnection;
      } });
      var LSPErrorCodes;
      (function(LSPErrorCodes2) {
        LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
        LSPErrorCodes2.RequestFailed = -32803;
        LSPErrorCodes2.ServerCancelled = -32802;
        LSPErrorCodes2.ContentModified = -32801;
        LSPErrorCodes2.RequestCancelled = -32800;
        LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
      })(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));
    }
  });

  // node_modules/monaco-languageclient/lib/services.js
  var require_services = __commonJS({
    "node_modules/monaco-languageclient/lib/services.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConfigurationTarget = exports.DocumentIdentifier = exports.ProgressLocation = exports.VsCodeDiagnosticSeverity = exports.SignatureHelpTriggerKind = exports.Services = exports.TextDocument = exports.Emitter = exports.Event = exports.CancellationToken = exports.Disposable = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var vscode_languageserver_textdocument_1 = require_main2();
      Object.defineProperty(exports, "TextDocument", { enumerable: true, get: function() {
        return vscode_languageserver_textdocument_1.TextDocument;
      } });
      var vscode_jsonrpc_1 = require_main3();
      Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
        return vscode_jsonrpc_1.Disposable;
      } });
      Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
        return vscode_jsonrpc_1.CancellationToken;
      } });
      Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
        return vscode_jsonrpc_1.Event;
      } });
      Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
        return vscode_jsonrpc_1.Emitter;
      } });
      tslib_1.__exportStar(require_api4(), exports);
      var Services;
      (function(Services2) {
        const global = window;
        const symbol = Symbol("Services");
        Services2.get = () => {
          const services = global[symbol];
          if (!services) {
            throw new Error("Language Client services has not been installed");
          }
          return services;
        };
        function install(services) {
          if (global[symbol]) {
            console.warn("Language Client services have been overridden");
          }
          global[symbol] = services;
          return vscode_jsonrpc_1.Disposable.create(() => global[symbol] = void 0);
        }
        Services2.install = install;
      })(Services = exports.Services || (exports.Services = {}));
      var SignatureHelpTriggerKind;
      (function(SignatureHelpTriggerKind2) {
        SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["ContentChange"] = 3] = "ContentChange";
      })(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
      var VsCodeDiagnosticSeverity;
      (function(VsCodeDiagnosticSeverity2) {
        VsCodeDiagnosticSeverity2[VsCodeDiagnosticSeverity2["Error"] = 0] = "Error";
        VsCodeDiagnosticSeverity2[VsCodeDiagnosticSeverity2["Warning"] = 1] = "Warning";
        VsCodeDiagnosticSeverity2[VsCodeDiagnosticSeverity2["Information"] = 2] = "Information";
        VsCodeDiagnosticSeverity2[VsCodeDiagnosticSeverity2["Hint"] = 3] = "Hint";
      })(VsCodeDiagnosticSeverity = exports.VsCodeDiagnosticSeverity || (exports.VsCodeDiagnosticSeverity = {}));
      var ProgressLocation;
      (function(ProgressLocation2) {
        ProgressLocation2[ProgressLocation2["SourceControl"] = 1] = "SourceControl";
        ProgressLocation2[ProgressLocation2["Window"] = 10] = "Window";
        ProgressLocation2[ProgressLocation2["Notification"] = 15] = "Notification";
      })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
      var DocumentIdentifier;
      (function(DocumentIdentifier2) {
        function is(arg) {
          return !!arg && "uri" in arg && "languageId" in arg;
        }
        DocumentIdentifier2.is = is;
      })(DocumentIdentifier = exports.DocumentIdentifier || (exports.DocumentIdentifier = {}));
      var ConfigurationTarget;
      (function(ConfigurationTarget2) {
        ConfigurationTarget2[ConfigurationTarget2["Global"] = 1] = "Global";
        ConfigurationTarget2[ConfigurationTarget2["Workspace"] = 2] = "Workspace";
        ConfigurationTarget2[ConfigurationTarget2["WorkspaceFolder"] = 3] = "WorkspaceFolder";
      })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
    }
  });

  // node_modules/monaco-languageclient/lib/disposable.js
  var require_disposable4 = __commonJS({
    "node_modules/monaco-languageclient/lib/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DisposableCollection = exports.Disposable = void 0;
      var services_1 = require_services();
      Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
        return services_1.Disposable;
      } });
      var DisposableCollection = class {
        constructor() {
          this.disposables = [];
        }
        dispose() {
          while (this.disposables.length !== 0) {
            this.disposables.pop().dispose();
          }
        }
        push(disposable) {
          const disposables = this.disposables;
          disposables.push(disposable);
          return {
            dispose() {
              const index = disposables.indexOf(disposable);
              if (index !== -1) {
                disposables.splice(index, 1);
              }
            }
          };
        }
      };
      exports.DisposableCollection = DisposableCollection;
    }
  });

  // node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/browser.js
  var require_browser = __commonJS({
    "node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/browser.js"(exports, module) {
      "use strict";
      module.exports = require_main4();
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/browser/main.js
  var require_main5 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createProtocolConnection = void 0;
      var browser_1 = require_browser();
      __exportStar2(require_browser(), exports);
      __exportStar2(require_api4(), exports);
      function createProtocolConnection(reader, writer, logger, options) {
        return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports.createProtocolConnection = createProtocolConnection;
    }
  });

  // node_modules/monaco-languageclient/lib/connection.js
  var require_connection5 = __commonJS({
    "node_modules/monaco-languageclient/lib/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createConnection = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var vscode_languageserver_protocol_1 = require_main5();
      var Is2 = tslib_1.__importStar(require_is4());
      function createConnection2(connection, errorHandler, closeHandler) {
        connection.onError((data) => {
          errorHandler(data[0], data[1], data[2]);
        });
        connection.onClose(closeHandler);
        return {
          listen: () => connection.listen(),
          sendRequest: (type, ...params) => connection.sendRequest(Is2.string(type) ? type : type.method, ...params),
          onRequest: (type, handler) => connection.onRequest(Is2.string(type) ? type : type.method, handler),
          sendNotification: async (type, params) => connection.sendNotification(Is2.string(type) ? type : type.method, params),
          onNotification: (type, handler) => connection.onNotification(Is2.string(type) ? type : type.method, handler),
          onProgress: (type, token, handler) => connection.onProgress(type, token, handler),
          sendProgress: async (type, token, value) => connection.sendProgress(type, token, value),
          trace: (value, tracer, sendNotification = false) => connection.trace(value, tracer, sendNotification),
          initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
          shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0),
          exit: async () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
          onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
          onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
          onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
          didChangeConfiguration: async (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
          didChangeWatchedFiles: async (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
          didOpenTextDocument: async (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
          didChangeTextDocument: async (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
          didCloseTextDocument: async (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
          didSaveTextDocument: async (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
          onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
          dispose: () => connection.dispose(),
          end: () => connection.end()
        };
      }
      exports.createConnection = createConnection2;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports.default = RAL;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable5 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Disposable = void 0;
      var Disposable4;
      (function(Disposable5) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable5.create = create;
      })(Disposable4 = exports.Disposable || (exports.Disposable = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Emitter = exports.Event = void 0;
      var ral_1 = require_ral4();
      var Event;
      (function(Event2) {
        const _disposable = { dispose() {
        } };
        Event2.None = function() {
          return _disposable;
        };
      })(Event = exports.Event || (exports.Event = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter = class _Emitter {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = _Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports.Emitter = Emitter;
      Emitter._noop = function() {
      };
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders() {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
              const value = chunk[offset];
              switch (value) {
                case CR:
                  switch (state) {
                    case 0:
                      state = 1;
                      break;
                    case 2:
                      state = 3;
                      break;
                    default:
                      state = 0;
                  }
                  break;
                case LF:
                  switch (state) {
                    case 1:
                      state = 2;
                      break;
                    case 3:
                      state = 4;
                      offset++;
                      break row;
                    default:
                      state = 0;
                  }
                  break;
                default:
                  state = 0;
              }
              offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error("Message header must separate key and value using :");
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ral_1 = require_ral4();
      var disposable_1 = require_disposable5();
      var events_1 = require_events4();
      var messageBuffer_1 = require_messageBuffer4();
      var MessageBuffer = class _MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return _MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new events_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, ral_1.default)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          ral_1.default.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports.default = RIL;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is5 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages5 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
      var is = require_is5();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
      var ResponseError = class _ResponseError extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, _ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports.ResponseError = ResponseError;
      var ParameterStructures = class _ParameterStructures {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.NotificationType9 = NotificationType9;
      var Message2;
      (function(Message3) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message3.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message3.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message3.isResponse = isResponse;
      })(Message2 = exports.Message || (exports.Message = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
      "use strict";
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch = exports.Touch || (exports.Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports.LRUCache = LRUCache;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CancellationTokenSource = exports.CancellationToken = void 0;
      var ral_1 = require_ral4();
      var Is2 = require_is5();
      var events_1 = require_events4();
      var CancellationToken;
      (function(CancellationToken2) {
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken2.is = is;
      })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports.CancellationTokenSource = CancellationTokenSource;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
      var ral_1 = require_ral4();
      var Is2 = require_is5();
      var events_1 = require_events4();
      var MessageReader2;
      (function(MessageReader3) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
        }
        MessageReader3.is = is;
      })(MessageReader2 = exports.MessageReader || (exports.MessageReader = {}));
      var AbstractMessageReader2 = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageReader = AbstractMessageReader2;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader2 {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders();
              if (!headers) {
                return;
              }
              const contentLength = headers.get("Content-Length");
              if (!contentLength) {
                throw new Error("Header must provide a Content-Length property.");
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                throw new Error("Content-Length value must be a number.");
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== void 0) {
              p = this.options.contentDecoder.decode(body);
            } else {
              p = Promise.resolve(body);
            }
            p.then((value) => {
              this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                this.callback(msg);
              }, (error) => {
                this.fireError(error);
              });
            }, (error) => {
              this.fireError(error);
            });
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Semaphore = void 0;
      var ral_1 = require_ral4();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports.Semaphore = Semaphore;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter4 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
      var ral_1 = require_ral4();
      var Is2 = require_is5();
      var semaphore_1 = require_semaphore4();
      var events_1 = require_events4();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter2;
      (function(MessageWriter3) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
        }
        MessageWriter3.is = is;
      })(MessageWriter2 = exports.MessageWriter || (exports.MessageWriter = {}));
      var AbstractMessageWriter2 = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageWriter = AbstractMessageWriter2;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter2 {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection6 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
      var ral_1 = require_ral4();
      var Is2 = require_is5();
      var messages_1 = require_messages5();
      var linkedMap_1 = require_linkedMap4();
      var events_1 = require_events4();
      var cancellation_1 = require_cancellation4();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken = exports.ProgressToken || (exports.ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is2.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace = exports.Trace || (exports.Trace = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString;
      })(Trace = exports.Trace || (exports.Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
      var ConnectionError = class _ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ConnectionError.prototype);
        }
      };
      exports.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.createCancellationTokenSource);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection2(messageReader, messageWriter, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader.onClose(closeHandler);
        messageReader.onError(readErrorHandler);
        messageWriter.onClose(closeHandler);
        messageWriter.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer || messageQueue.size === 0) {
            return;
          }
          timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = void 0;
            processMessageQueue();
          });
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            if (messages_1.Message.isRequest(message)) {
              handleRequest(message);
            } else if (messages_1.Message.isNotification(message)) {
              handleNotification(message);
            } else if (messages_1.Message.isResponse(message)) {
              handleResponse(message);
            } else {
              handleInvalidMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is2.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is2.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is2.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is2.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              const last = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last)) {
                paramEnd = paramEnd - 1;
                token = last;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const result = new Promise((resolve, reject) => {
              const requestMessage = {
                jsonrpc: version,
                id,
                method,
                params: messageParams
              };
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              traceSendingRequest(requestMessage);
              try {
                messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
              } catch (e) {
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
                responsePromise = null;
              }
              if (responsePromise) {
                responsePromises.set(id, responsePromise);
              }
            });
            return result;
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is2.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is2.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is2.func(messageWriter.dispose)) {
              messageWriter.dispose();
            }
            if (Is2.func(messageReader.dispose)) {
              messageReader.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection;
      }
      exports.createMessageConnection = createMessageConnection2;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api5 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
      exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = void 0;
      var messages_1 = require_messages5();
      Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap4();
      Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable5();
      Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events4();
      Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation4();
      Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var messageReader_1 = require_messageReader4();
      Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter4();
      Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var connection_1 = require_connection6();
      Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      var ral_1 = require_ral4();
      exports.RAL = ral_1.default;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main6 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
      var ril_1 = require_ril4();
      ril_1.default.install();
      var api_1 = require_api5();
      __exportStar2(require_api5(), exports);
      var BrowserMessageReader = class extends api_1.AbstractMessageReader {
        constructor(context) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          context.addEventListener("error", (event) => this.fireError(event));
          context.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports.BrowserMessageReader = BrowserMessageReader;
      var BrowserMessageWriter = class extends api_1.AbstractMessageWriter {
        constructor(context) {
          super();
          this.context = context;
          this.errorCount = 0;
          context.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.context.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports.BrowserMessageWriter = BrowserMessageWriter;
      function createMessageConnection2(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports.createMessageConnection = createMessageConnection2;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/browser.js
  var require_browser2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-jsonrpc/browser.js"(exports, module) {
      "use strict";
      module.exports = require_main6();
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-types/lib/umd/main.js
  var require_main7 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module) {
      (function(factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          var v = factory(__require, exports);
          if (v !== void 0) module.exports = v;
        } else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
        }
      })(function(require2, exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TextDocument = exports2.EOL = exports2.WorkspaceFolder = exports2.InlayHint = exports2.InlayHintLabelPart = exports2.InlayHintKind = exports2.InlineValueContext = exports2.InlineValueEvaluatableExpression = exports2.InlineValueVariableLookup = exports2.InlineValueText = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionTriggerKind = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.WorkspaceSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.CompletionItemLabelDetails = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = exports2.URI = exports2.DocumentUri = void 0;
        var DocumentUri2;
        (function(DocumentUri3) {
          function is(value) {
            return typeof value === "string";
          }
          DocumentUri3.is = is;
        })(DocumentUri2 = exports2.DocumentUri || (exports2.DocumentUri = {}));
        var URI2;
        (function(URI3) {
          function is(value) {
            return typeof value === "string";
          }
          URI3.is = is;
        })(URI2 = exports2.URI || (exports2.URI = {}));
        var integer2;
        (function(integer3) {
          integer3.MIN_VALUE = -2147483648;
          integer3.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && integer3.MIN_VALUE <= value && value <= integer3.MAX_VALUE;
          }
          integer3.is = is;
        })(integer2 = exports2.integer || (exports2.integer = {}));
        var uinteger2;
        (function(uinteger3) {
          uinteger3.MIN_VALUE = 0;
          uinteger3.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && uinteger3.MIN_VALUE <= value && value <= uinteger3.MAX_VALUE;
          }
          uinteger3.is = is;
        })(uinteger2 = exports2.uinteger || (exports2.uinteger = {}));
        var Position2;
        (function(Position3) {
          function create(line, character) {
            if (line === Number.MAX_VALUE) {
              line = uinteger2.MAX_VALUE;
            }
            if (character === Number.MAX_VALUE) {
              character = uinteger2.MAX_VALUE;
            }
            return { line, character };
          }
          Position3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.line) && Is2.uinteger(candidate.character);
          }
          Position3.is = is;
        })(Position2 = exports2.Position || (exports2.Position = {}));
        var Range2;
        (function(Range3) {
          function create(one, two, three, four) {
            if (Is2.uinteger(one) && Is2.uinteger(two) && Is2.uinteger(three) && Is2.uinteger(four)) {
              return { start: Position2.create(one, two), end: Position2.create(three, four) };
            } else if (Position2.is(one) && Position2.is(two)) {
              return { start: one, end: two };
            } else {
              throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
            }
          }
          Range3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
          }
          Range3.is = is;
        })(Range2 = exports2.Range || (exports2.Range = {}));
        var Location2;
        (function(Location3) {
          function create(uri, range) {
            return { uri, range };
          }
          Location3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Range2.is(candidate.range) && (Is2.string(candidate.uri) || Is2.undefined(candidate.uri));
          }
          Location3.is = is;
        })(Location2 = exports2.Location || (exports2.Location = {}));
        var LocationLink2;
        (function(LocationLink3) {
          function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
          }
          LocationLink3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Range2.is(candidate.targetRange) && Is2.string(candidate.targetUri) && Range2.is(candidate.targetSelectionRange) && (Range2.is(candidate.originSelectionRange) || Is2.undefined(candidate.originSelectionRange));
          }
          LocationLink3.is = is;
        })(LocationLink2 = exports2.LocationLink || (exports2.LocationLink = {}));
        var Color2;
        (function(Color3) {
          function create(red, green, blue, alpha) {
            return {
              red,
              green,
              blue,
              alpha
            };
          }
          Color3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Is2.numberRange(candidate.red, 0, 1) && Is2.numberRange(candidate.green, 0, 1) && Is2.numberRange(candidate.blue, 0, 1) && Is2.numberRange(candidate.alpha, 0, 1);
          }
          Color3.is = is;
        })(Color2 = exports2.Color || (exports2.Color = {}));
        var ColorInformation2;
        (function(ColorInformation3) {
          function create(range, color) {
            return {
              range,
              color
            };
          }
          ColorInformation3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Range2.is(candidate.range) && Color2.is(candidate.color);
          }
          ColorInformation3.is = is;
        })(ColorInformation2 = exports2.ColorInformation || (exports2.ColorInformation = {}));
        var ColorPresentation2;
        (function(ColorPresentation3) {
          function create(label, textEdit, additionalTextEdits) {
            return {
              label,
              textEdit,
              additionalTextEdits
            };
          }
          ColorPresentation3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.undefined(candidate.textEdit) || TextEdit2.is(candidate)) && (Is2.undefined(candidate.additionalTextEdits) || Is2.typedArray(candidate.additionalTextEdits, TextEdit2.is));
          }
          ColorPresentation3.is = is;
        })(ColorPresentation2 = exports2.ColorPresentation || (exports2.ColorPresentation = {}));
        var FoldingRangeKind2;
        (function(FoldingRangeKind3) {
          FoldingRangeKind3.Comment = "comment";
          FoldingRangeKind3.Imports = "imports";
          FoldingRangeKind3.Region = "region";
        })(FoldingRangeKind2 = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
        var FoldingRange2;
        (function(FoldingRange3) {
          function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
            var result = {
              startLine,
              endLine
            };
            if (Is2.defined(startCharacter)) {
              result.startCharacter = startCharacter;
            }
            if (Is2.defined(endCharacter)) {
              result.endCharacter = endCharacter;
            }
            if (Is2.defined(kind)) {
              result.kind = kind;
            }
            if (Is2.defined(collapsedText)) {
              result.collapsedText = collapsedText;
            }
            return result;
          }
          FoldingRange3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.startLine) && Is2.uinteger(candidate.startLine) && (Is2.undefined(candidate.startCharacter) || Is2.uinteger(candidate.startCharacter)) && (Is2.undefined(candidate.endCharacter) || Is2.uinteger(candidate.endCharacter)) && (Is2.undefined(candidate.kind) || Is2.string(candidate.kind));
          }
          FoldingRange3.is = is;
        })(FoldingRange2 = exports2.FoldingRange || (exports2.FoldingRange = {}));
        var DiagnosticRelatedInformation2;
        (function(DiagnosticRelatedInformation3) {
          function create(location, message) {
            return {
              location,
              message
            };
          }
          DiagnosticRelatedInformation3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Location2.is(candidate.location) && Is2.string(candidate.message);
          }
          DiagnosticRelatedInformation3.is = is;
        })(DiagnosticRelatedInformation2 = exports2.DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = {}));
        var DiagnosticSeverity2;
        (function(DiagnosticSeverity3) {
          DiagnosticSeverity3.Error = 1;
          DiagnosticSeverity3.Warning = 2;
          DiagnosticSeverity3.Information = 3;
          DiagnosticSeverity3.Hint = 4;
        })(DiagnosticSeverity2 = exports2.DiagnosticSeverity || (exports2.DiagnosticSeverity = {}));
        var DiagnosticTag2;
        (function(DiagnosticTag3) {
          DiagnosticTag3.Unnecessary = 1;
          DiagnosticTag3.Deprecated = 2;
        })(DiagnosticTag2 = exports2.DiagnosticTag || (exports2.DiagnosticTag = {}));
        var CodeDescription2;
        (function(CodeDescription3) {
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Is2.string(candidate.href);
          }
          CodeDescription3.is = is;
        })(CodeDescription2 = exports2.CodeDescription || (exports2.CodeDescription = {}));
        var Diagnostic2;
        (function(Diagnostic3) {
          function create(range, message, severity, code, source, relatedInformation) {
            var result = { range, message };
            if (Is2.defined(severity)) {
              result.severity = severity;
            }
            if (Is2.defined(code)) {
              result.code = code;
            }
            if (Is2.defined(source)) {
              result.source = source;
            }
            if (Is2.defined(relatedInformation)) {
              result.relatedInformation = relatedInformation;
            }
            return result;
          }
          Diagnostic3.create = create;
          function is(value) {
            var _a;
            var candidate = value;
            return Is2.defined(candidate) && Range2.is(candidate.range) && Is2.string(candidate.message) && (Is2.number(candidate.severity) || Is2.undefined(candidate.severity)) && (Is2.integer(candidate.code) || Is2.string(candidate.code) || Is2.undefined(candidate.code)) && (Is2.undefined(candidate.codeDescription) || Is2.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is2.string(candidate.source) || Is2.undefined(candidate.source)) && (Is2.undefined(candidate.relatedInformation) || Is2.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation2.is));
          }
          Diagnostic3.is = is;
        })(Diagnostic2 = exports2.Diagnostic || (exports2.Diagnostic = {}));
        var Command2;
        (function(Command3) {
          function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            var result = { title, command };
            if (Is2.defined(args) && args.length > 0) {
              result.arguments = args;
            }
            return result;
          }
          Command3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Is2.string(candidate.title) && Is2.string(candidate.command);
          }
          Command3.is = is;
        })(Command2 = exports2.Command || (exports2.Command = {}));
        var TextEdit2;
        (function(TextEdit3) {
          function replace(range, newText) {
            return { range, newText };
          }
          TextEdit3.replace = replace;
          function insert(position, newText) {
            return { range: { start: position, end: position }, newText };
          }
          TextEdit3.insert = insert;
          function del(range) {
            return { range, newText: "" };
          }
          TextEdit3.del = del;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Is2.string(candidate.newText) && Range2.is(candidate.range);
          }
          TextEdit3.is = is;
        })(TextEdit2 = exports2.TextEdit || (exports2.TextEdit = {}));
        var ChangeAnnotation2;
        (function(ChangeAnnotation3) {
          function create(label, needsConfirmation, description) {
            var result = { label };
            if (needsConfirmation !== void 0) {
              result.needsConfirmation = needsConfirmation;
            }
            if (description !== void 0) {
              result.description = description;
            }
            return result;
          }
          ChangeAnnotation3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
          }
          ChangeAnnotation3.is = is;
        })(ChangeAnnotation2 = exports2.ChangeAnnotation || (exports2.ChangeAnnotation = {}));
        var ChangeAnnotationIdentifier2;
        (function(ChangeAnnotationIdentifier3) {
          function is(value) {
            var candidate = value;
            return Is2.string(candidate);
          }
          ChangeAnnotationIdentifier3.is = is;
        })(ChangeAnnotationIdentifier2 = exports2.ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = {}));
        var AnnotatedTextEdit2;
        (function(AnnotatedTextEdit3) {
          function replace(range, newText, annotation) {
            return { range, newText, annotationId: annotation };
          }
          AnnotatedTextEdit3.replace = replace;
          function insert(position, newText, annotation) {
            return { range: { start: position, end: position }, newText, annotationId: annotation };
          }
          AnnotatedTextEdit3.insert = insert;
          function del(range, annotation) {
            return { range, newText: "", annotationId: annotation };
          }
          AnnotatedTextEdit3.del = del;
          function is(value) {
            var candidate = value;
            return TextEdit2.is(candidate) && (ChangeAnnotation2.is(candidate.annotationId) || ChangeAnnotationIdentifier2.is(candidate.annotationId));
          }
          AnnotatedTextEdit3.is = is;
        })(AnnotatedTextEdit2 = exports2.AnnotatedTextEdit || (exports2.AnnotatedTextEdit = {}));
        var TextDocumentEdit2;
        (function(TextDocumentEdit3) {
          function create(textDocument, edits) {
            return { textDocument, edits };
          }
          TextDocumentEdit3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && OptionalVersionedTextDocumentIdentifier2.is(candidate.textDocument) && Array.isArray(candidate.edits);
          }
          TextDocumentEdit3.is = is;
        })(TextDocumentEdit2 = exports2.TextDocumentEdit || (exports2.TextDocumentEdit = {}));
        var CreateFile2;
        (function(CreateFile3) {
          function create(uri, options, annotation) {
            var result = {
              kind: "create",
              uri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          CreateFile3.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "create" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
          }
          CreateFile3.is = is;
        })(CreateFile2 = exports2.CreateFile || (exports2.CreateFile = {}));
        var RenameFile2;
        (function(RenameFile3) {
          function create(oldUri, newUri, options, annotation) {
            var result = {
              kind: "rename",
              oldUri,
              newUri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          RenameFile3.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "rename" && Is2.string(candidate.oldUri) && Is2.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
          }
          RenameFile3.is = is;
        })(RenameFile2 = exports2.RenameFile || (exports2.RenameFile = {}));
        var DeleteFile2;
        (function(DeleteFile3) {
          function create(uri, options, annotation) {
            var result = {
              kind: "delete",
              uri
            };
            if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          DeleteFile3.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "delete" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is2.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is2.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
          }
          DeleteFile3.is = is;
        })(DeleteFile2 = exports2.DeleteFile || (exports2.DeleteFile = {}));
        var WorkspaceEdit2;
        (function(WorkspaceEdit3) {
          function is(value) {
            var candidate = value;
            return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
              if (Is2.string(change.kind)) {
                return CreateFile2.is(change) || RenameFile2.is(change) || DeleteFile2.is(change);
              } else {
                return TextDocumentEdit2.is(change);
              }
            }));
          }
          WorkspaceEdit3.is = is;
        })(WorkspaceEdit2 = exports2.WorkspaceEdit || (exports2.WorkspaceEdit = {}));
        var TextEditChangeImpl2 = (
          /** @class */
          (function() {
            function TextEditChangeImpl3(edits, changeAnnotations) {
              this.edits = edits;
              this.changeAnnotations = changeAnnotations;
            }
            TextEditChangeImpl3.prototype.insert = function(position, newText, annotation) {
              var edit;
              var id;
              if (annotation === void 0) {
                edit = TextEdit2.insert(position, newText);
              } else if (ChangeAnnotationIdentifier2.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit2.insert(position, newText, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit2.insert(position, newText, id);
              }
              this.edits.push(edit);
              if (id !== void 0) {
                return id;
              }
            };
            TextEditChangeImpl3.prototype.replace = function(range, newText, annotation) {
              var edit;
              var id;
              if (annotation === void 0) {
                edit = TextEdit2.replace(range, newText);
              } else if (ChangeAnnotationIdentifier2.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit2.replace(range, newText, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit2.replace(range, newText, id);
              }
              this.edits.push(edit);
              if (id !== void 0) {
                return id;
              }
            };
            TextEditChangeImpl3.prototype.delete = function(range, annotation) {
              var edit;
              var id;
              if (annotation === void 0) {
                edit = TextEdit2.del(range);
              } else if (ChangeAnnotationIdentifier2.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit2.del(range, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit2.del(range, id);
              }
              this.edits.push(edit);
              if (id !== void 0) {
                return id;
              }
            };
            TextEditChangeImpl3.prototype.add = function(edit) {
              this.edits.push(edit);
            };
            TextEditChangeImpl3.prototype.all = function() {
              return this.edits;
            };
            TextEditChangeImpl3.prototype.clear = function() {
              this.edits.splice(0, this.edits.length);
            };
            TextEditChangeImpl3.prototype.assertChangeAnnotations = function(value) {
              if (value === void 0) {
                throw new Error("Text edit change is not configured to manage change annotations.");
              }
            };
            return TextEditChangeImpl3;
          })()
        );
        var ChangeAnnotations2 = (
          /** @class */
          (function() {
            function ChangeAnnotations3(annotations) {
              this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
              this._counter = 0;
              this._size = 0;
            }
            ChangeAnnotations3.prototype.all = function() {
              return this._annotations;
            };
            Object.defineProperty(ChangeAnnotations3.prototype, "size", {
              get: function() {
                return this._size;
              },
              enumerable: false,
              configurable: true
            });
            ChangeAnnotations3.prototype.manage = function(idOrAnnotation, annotation) {
              var id;
              if (ChangeAnnotationIdentifier2.is(idOrAnnotation)) {
                id = idOrAnnotation;
              } else {
                id = this.nextId();
                annotation = idOrAnnotation;
              }
              if (this._annotations[id] !== void 0) {
                throw new Error("Id ".concat(id, " is already in use."));
              }
              if (annotation === void 0) {
                throw new Error("No annotation provided for id ".concat(id));
              }
              this._annotations[id] = annotation;
              this._size++;
              return id;
            };
            ChangeAnnotations3.prototype.nextId = function() {
              this._counter++;
              return this._counter.toString();
            };
            return ChangeAnnotations3;
          })()
        );
        var WorkspaceChange2 = (
          /** @class */
          (function() {
            function WorkspaceChange3(workspaceEdit) {
              var _this = this;
              this._textEditChanges = /* @__PURE__ */ Object.create(null);
              if (workspaceEdit !== void 0) {
                this._workspaceEdit = workspaceEdit;
                if (workspaceEdit.documentChanges) {
                  this._changeAnnotations = new ChangeAnnotations2(workspaceEdit.changeAnnotations);
                  workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                  workspaceEdit.documentChanges.forEach(function(change) {
                    if (TextDocumentEdit2.is(change)) {
                      var textEditChange = new TextEditChangeImpl2(change.edits, _this._changeAnnotations);
                      _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                  });
                } else if (workspaceEdit.changes) {
                  Object.keys(workspaceEdit.changes).forEach(function(key) {
                    var textEditChange = new TextEditChangeImpl2(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                  });
                }
              } else {
                this._workspaceEdit = {};
              }
            }
            Object.defineProperty(WorkspaceChange3.prototype, "edit", {
              /**
               * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
               * use to be returned from a workspace edit operation like rename.
               */
              get: function() {
                this.initDocumentChanges();
                if (this._changeAnnotations !== void 0) {
                  if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = void 0;
                  } else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                  }
                }
                return this._workspaceEdit;
              },
              enumerable: false,
              configurable: true
            });
            WorkspaceChange3.prototype.getTextEditChange = function(key) {
              if (OptionalVersionedTextDocumentIdentifier2.is(key)) {
                this.initDocumentChanges();
                if (this._workspaceEdit.documentChanges === void 0) {
                  throw new Error("Workspace edit is not configured for document changes.");
                }
                var textDocument = { uri: key.uri, version: key.version };
                var result = this._textEditChanges[textDocument.uri];
                if (!result) {
                  var edits = [];
                  var textDocumentEdit = {
                    textDocument,
                    edits
                  };
                  this._workspaceEdit.documentChanges.push(textDocumentEdit);
                  result = new TextEditChangeImpl2(edits, this._changeAnnotations);
                  this._textEditChanges[textDocument.uri] = result;
                }
                return result;
              } else {
                this.initChanges();
                if (this._workspaceEdit.changes === void 0) {
                  throw new Error("Workspace edit is not configured for normal text edit changes.");
                }
                var result = this._textEditChanges[key];
                if (!result) {
                  var edits = [];
                  this._workspaceEdit.changes[key] = edits;
                  result = new TextEditChangeImpl2(edits);
                  this._textEditChanges[key] = result;
                }
                return result;
              }
            };
            WorkspaceChange3.prototype.initDocumentChanges = function() {
              if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
                this._changeAnnotations = new ChangeAnnotations2();
                this._workspaceEdit.documentChanges = [];
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              }
            };
            WorkspaceChange3.prototype.initChanges = function() {
              if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
                this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
              }
            };
            WorkspaceChange3.prototype.createFile = function(uri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id;
              if (annotation === void 0) {
                operation = CreateFile2.create(uri, options);
              } else {
                id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = CreateFile2.create(uri, options, id);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id !== void 0) {
                return id;
              }
            };
            WorkspaceChange3.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id;
              if (annotation === void 0) {
                operation = RenameFile2.create(oldUri, newUri, options);
              } else {
                id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = RenameFile2.create(oldUri, newUri, options, id);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id !== void 0) {
                return id;
              }
            };
            WorkspaceChange3.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id;
              if (annotation === void 0) {
                operation = DeleteFile2.create(uri, options);
              } else {
                id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = DeleteFile2.create(uri, options, id);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id !== void 0) {
                return id;
              }
            };
            return WorkspaceChange3;
          })()
        );
        exports2.WorkspaceChange = WorkspaceChange2;
        var TextDocumentIdentifier2;
        (function(TextDocumentIdentifier3) {
          function create(uri) {
            return { uri };
          }
          TextDocumentIdentifier3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Is2.string(candidate.uri);
          }
          TextDocumentIdentifier3.is = is;
        })(TextDocumentIdentifier2 = exports2.TextDocumentIdentifier || (exports2.TextDocumentIdentifier = {}));
        var VersionedTextDocumentIdentifier2;
        (function(VersionedTextDocumentIdentifier3) {
          function create(uri, version) {
            return { uri, version };
          }
          VersionedTextDocumentIdentifier3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.integer(candidate.version);
          }
          VersionedTextDocumentIdentifier3.is = is;
        })(VersionedTextDocumentIdentifier2 = exports2.VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = {}));
        var OptionalVersionedTextDocumentIdentifier2;
        (function(OptionalVersionedTextDocumentIdentifier3) {
          function create(uri, version) {
            return { uri, version };
          }
          OptionalVersionedTextDocumentIdentifier3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Is2.string(candidate.uri) && (candidate.version === null || Is2.integer(candidate.version));
          }
          OptionalVersionedTextDocumentIdentifier3.is = is;
        })(OptionalVersionedTextDocumentIdentifier2 = exports2.OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = {}));
        var TextDocumentItem2;
        (function(TextDocumentItem3) {
          function create(uri, languageId, version, text) {
            return { uri, languageId, version, text };
          }
          TextDocumentItem3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.string(candidate.languageId) && Is2.integer(candidate.version) && Is2.string(candidate.text);
          }
          TextDocumentItem3.is = is;
        })(TextDocumentItem2 = exports2.TextDocumentItem || (exports2.TextDocumentItem = {}));
        var MarkupKind2;
        (function(MarkupKind3) {
          MarkupKind3.PlainText = "plaintext";
          MarkupKind3.Markdown = "markdown";
          function is(value) {
            var candidate = value;
            return candidate === MarkupKind3.PlainText || candidate === MarkupKind3.Markdown;
          }
          MarkupKind3.is = is;
        })(MarkupKind2 = exports2.MarkupKind || (exports2.MarkupKind = {}));
        var MarkupContent2;
        (function(MarkupContent3) {
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(value) && MarkupKind2.is(candidate.kind) && Is2.string(candidate.value);
          }
          MarkupContent3.is = is;
        })(MarkupContent2 = exports2.MarkupContent || (exports2.MarkupContent = {}));
        var CompletionItemKind2;
        (function(CompletionItemKind3) {
          CompletionItemKind3.Text = 1;
          CompletionItemKind3.Method = 2;
          CompletionItemKind3.Function = 3;
          CompletionItemKind3.Constructor = 4;
          CompletionItemKind3.Field = 5;
          CompletionItemKind3.Variable = 6;
          CompletionItemKind3.Class = 7;
          CompletionItemKind3.Interface = 8;
          CompletionItemKind3.Module = 9;
          CompletionItemKind3.Property = 10;
          CompletionItemKind3.Unit = 11;
          CompletionItemKind3.Value = 12;
          CompletionItemKind3.Enum = 13;
          CompletionItemKind3.Keyword = 14;
          CompletionItemKind3.Snippet = 15;
          CompletionItemKind3.Color = 16;
          CompletionItemKind3.File = 17;
          CompletionItemKind3.Reference = 18;
          CompletionItemKind3.Folder = 19;
          CompletionItemKind3.EnumMember = 20;
          CompletionItemKind3.Constant = 21;
          CompletionItemKind3.Struct = 22;
          CompletionItemKind3.Event = 23;
          CompletionItemKind3.Operator = 24;
          CompletionItemKind3.TypeParameter = 25;
        })(CompletionItemKind2 = exports2.CompletionItemKind || (exports2.CompletionItemKind = {}));
        var InsertTextFormat2;
        (function(InsertTextFormat3) {
          InsertTextFormat3.PlainText = 1;
          InsertTextFormat3.Snippet = 2;
        })(InsertTextFormat2 = exports2.InsertTextFormat || (exports2.InsertTextFormat = {}));
        var CompletionItemTag2;
        (function(CompletionItemTag3) {
          CompletionItemTag3.Deprecated = 1;
        })(CompletionItemTag2 = exports2.CompletionItemTag || (exports2.CompletionItemTag = {}));
        var InsertReplaceEdit2;
        (function(InsertReplaceEdit3) {
          function create(newText, insert, replace) {
            return { newText, insert, replace };
          }
          InsertReplaceEdit3.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is2.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
          }
          InsertReplaceEdit3.is = is;
        })(InsertReplaceEdit2 = exports2.InsertReplaceEdit || (exports2.InsertReplaceEdit = {}));
        var InsertTextMode2;
        (function(InsertTextMode3) {
          InsertTextMode3.asIs = 1;
          InsertTextMode3.adjustIndentation = 2;
        })(InsertTextMode2 = exports2.InsertTextMode || (exports2.InsertTextMode = {}));
        var CompletionItemLabelDetails2;
        (function(CompletionItemLabelDetails3) {
          function is(value) {
            var candidate = value;
            return candidate && (Is2.string(candidate.detail) || candidate.detail === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
          }
          CompletionItemLabelDetails3.is = is;
        })(CompletionItemLabelDetails2 = exports2.CompletionItemLabelDetails || (exports2.CompletionItemLabelDetails = {}));
        var CompletionItem2;
        (function(CompletionItem3) {
          function create(label) {
            return { label };
          }
          CompletionItem3.create = create;
        })(CompletionItem2 = exports2.CompletionItem || (exports2.CompletionItem = {}));
        var CompletionList2;
        (function(CompletionList3) {
          function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
          }
          CompletionList3.create = create;
        })(CompletionList2 = exports2.CompletionList || (exports2.CompletionList = {}));
        var MarkedString2;
        (function(MarkedString3) {
          function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
          }
          MarkedString3.fromPlainText = fromPlainText;
          function is(value) {
            var candidate = value;
            return Is2.string(candidate) || Is2.objectLiteral(candidate) && Is2.string(candidate.language) && Is2.string(candidate.value);
          }
          MarkedString3.is = is;
        })(MarkedString2 = exports2.MarkedString || (exports2.MarkedString = {}));
        var Hover2;
        (function(Hover3) {
          function is(value) {
            var candidate = value;
            return !!candidate && Is2.objectLiteral(candidate) && (MarkupContent2.is(candidate.contents) || MarkedString2.is(candidate.contents) || Is2.typedArray(candidate.contents, MarkedString2.is)) && (value.range === void 0 || Range2.is(value.range));
          }
          Hover3.is = is;
        })(Hover2 = exports2.Hover || (exports2.Hover = {}));
        var ParameterInformation2;
        (function(ParameterInformation3) {
          function create(label, documentation) {
            return documentation ? { label, documentation } : { label };
          }
          ParameterInformation3.create = create;
        })(ParameterInformation2 = exports2.ParameterInformation || (exports2.ParameterInformation = {}));
        var SignatureInformation2;
        (function(SignatureInformation3) {
          function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              parameters[_i - 2] = arguments[_i];
            }
            var result = { label };
            if (Is2.defined(documentation)) {
              result.documentation = documentation;
            }
            if (Is2.defined(parameters)) {
              result.parameters = parameters;
            } else {
              result.parameters = [];
            }
            return result;
          }
          SignatureInformation3.create = create;
        })(SignatureInformation2 = exports2.SignatureInformation || (exports2.SignatureInformation = {}));
        var DocumentHighlightKind2;
        (function(DocumentHighlightKind3) {
          DocumentHighlightKind3.Text = 1;
          DocumentHighlightKind3.Read = 2;
          DocumentHighlightKind3.Write = 3;
        })(DocumentHighlightKind2 = exports2.DocumentHighlightKind || (exports2.DocumentHighlightKind = {}));
        var DocumentHighlight2;
        (function(DocumentHighlight3) {
          function create(range, kind) {
            var result = { range };
            if (Is2.number(kind)) {
              result.kind = kind;
            }
            return result;
          }
          DocumentHighlight3.create = create;
        })(DocumentHighlight2 = exports2.DocumentHighlight || (exports2.DocumentHighlight = {}));
        var SymbolKind2;
        (function(SymbolKind3) {
          SymbolKind3.File = 1;
          SymbolKind3.Module = 2;
          SymbolKind3.Namespace = 3;
          SymbolKind3.Package = 4;
          SymbolKind3.Class = 5;
          SymbolKind3.Method = 6;
          SymbolKind3.Property = 7;
          SymbolKind3.Field = 8;
          SymbolKind3.Constructor = 9;
          SymbolKind3.Enum = 10;
          SymbolKind3.Interface = 11;
          SymbolKind3.Function = 12;
          SymbolKind3.Variable = 13;
          SymbolKind3.Constant = 14;
          SymbolKind3.String = 15;
          SymbolKind3.Number = 16;
          SymbolKind3.Boolean = 17;
          SymbolKind3.Array = 18;
          SymbolKind3.Object = 19;
          SymbolKind3.Key = 20;
          SymbolKind3.Null = 21;
          SymbolKind3.EnumMember = 22;
          SymbolKind3.Struct = 23;
          SymbolKind3.Event = 24;
          SymbolKind3.Operator = 25;
          SymbolKind3.TypeParameter = 26;
        })(SymbolKind2 = exports2.SymbolKind || (exports2.SymbolKind = {}));
        var SymbolTag2;
        (function(SymbolTag3) {
          SymbolTag3.Deprecated = 1;
        })(SymbolTag2 = exports2.SymbolTag || (exports2.SymbolTag = {}));
        var SymbolInformation2;
        (function(SymbolInformation3) {
          function create(name, kind, range, uri, containerName) {
            var result = {
              name,
              kind,
              location: { uri, range }
            };
            if (containerName) {
              result.containerName = containerName;
            }
            return result;
          }
          SymbolInformation3.create = create;
        })(SymbolInformation2 = exports2.SymbolInformation || (exports2.SymbolInformation = {}));
        var WorkspaceSymbol2;
        (function(WorkspaceSymbol3) {
          function create(name, kind, uri, range) {
            return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
          }
          WorkspaceSymbol3.create = create;
        })(WorkspaceSymbol2 = exports2.WorkspaceSymbol || (exports2.WorkspaceSymbol = {}));
        var DocumentSymbol2;
        (function(DocumentSymbol3) {
          function create(name, detail, kind, range, selectionRange, children) {
            var result = {
              name,
              detail,
              kind,
              range,
              selectionRange
            };
            if (children !== void 0) {
              result.children = children;
            }
            return result;
          }
          DocumentSymbol3.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is2.string(candidate.name) && Is2.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is2.string(candidate.detail)) && (candidate.deprecated === void 0 || Is2.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
          }
          DocumentSymbol3.is = is;
        })(DocumentSymbol2 = exports2.DocumentSymbol || (exports2.DocumentSymbol = {}));
        var CodeActionKind2;
        (function(CodeActionKind3) {
          CodeActionKind3.Empty = "";
          CodeActionKind3.QuickFix = "quickfix";
          CodeActionKind3.Refactor = "refactor";
          CodeActionKind3.RefactorExtract = "refactor.extract";
          CodeActionKind3.RefactorInline = "refactor.inline";
          CodeActionKind3.RefactorRewrite = "refactor.rewrite";
          CodeActionKind3.Source = "source";
          CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
          CodeActionKind3.SourceFixAll = "source.fixAll";
        })(CodeActionKind2 = exports2.CodeActionKind || (exports2.CodeActionKind = {}));
        var CodeActionTriggerKind2;
        (function(CodeActionTriggerKind3) {
          CodeActionTriggerKind3.Invoked = 1;
          CodeActionTriggerKind3.Automatic = 2;
        })(CodeActionTriggerKind2 = exports2.CodeActionTriggerKind || (exports2.CodeActionTriggerKind = {}));
        var CodeActionContext2;
        (function(CodeActionContext3) {
          function create(diagnostics, only, triggerKind) {
            var result = { diagnostics };
            if (only !== void 0 && only !== null) {
              result.only = only;
            }
            if (triggerKind !== void 0 && triggerKind !== null) {
              result.triggerKind = triggerKind;
            }
            return result;
          }
          CodeActionContext3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Is2.typedArray(candidate.diagnostics, Diagnostic2.is) && (candidate.only === void 0 || Is2.typedArray(candidate.only, Is2.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind2.Invoked || candidate.triggerKind === CodeActionTriggerKind2.Automatic);
          }
          CodeActionContext3.is = is;
        })(CodeActionContext2 = exports2.CodeActionContext || (exports2.CodeActionContext = {}));
        var CodeAction2;
        (function(CodeAction3) {
          function create(title, kindOrCommandOrEdit, kind) {
            var result = { title };
            var checkKind = true;
            if (typeof kindOrCommandOrEdit === "string") {
              checkKind = false;
              result.kind = kindOrCommandOrEdit;
            } else if (Command2.is(kindOrCommandOrEdit)) {
              result.command = kindOrCommandOrEdit;
            } else {
              result.edit = kindOrCommandOrEdit;
            }
            if (checkKind && kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          CodeAction3.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is2.string(candidate.title) && (candidate.diagnostics === void 0 || Is2.typedArray(candidate.diagnostics, Diagnostic2.is)) && (candidate.kind === void 0 || Is2.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is2.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit2.is(candidate.edit));
          }
          CodeAction3.is = is;
        })(CodeAction2 = exports2.CodeAction || (exports2.CodeAction = {}));
        var CodeLens2;
        (function(CodeLens3) {
          function create(range, data) {
            var result = { range };
            if (Is2.defined(data)) {
              result.data = data;
            }
            return result;
          }
          CodeLens3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Range2.is(candidate.range) && (Is2.undefined(candidate.command) || Command2.is(candidate.command));
          }
          CodeLens3.is = is;
        })(CodeLens2 = exports2.CodeLens || (exports2.CodeLens = {}));
        var FormattingOptions2;
        (function(FormattingOptions3) {
          function create(tabSize, insertSpaces) {
            return { tabSize, insertSpaces };
          }
          FormattingOptions3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Is2.uinteger(candidate.tabSize) && Is2.boolean(candidate.insertSpaces);
          }
          FormattingOptions3.is = is;
        })(FormattingOptions2 = exports2.FormattingOptions || (exports2.FormattingOptions = {}));
        var DocumentLink2;
        (function(DocumentLink3) {
          function create(range, target, data) {
            return { range, target, data };
          }
          DocumentLink3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Range2.is(candidate.range) && (Is2.undefined(candidate.target) || Is2.string(candidate.target));
          }
          DocumentLink3.is = is;
        })(DocumentLink2 = exports2.DocumentLink || (exports2.DocumentLink = {}));
        var SelectionRange2;
        (function(SelectionRange3) {
          function create(range, parent) {
            return { range, parent };
          }
          SelectionRange3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange3.is(candidate.parent));
          }
          SelectionRange3.is = is;
        })(SelectionRange2 = exports2.SelectionRange || (exports2.SelectionRange = {}));
        var SemanticTokenTypes2;
        (function(SemanticTokenTypes3) {
          SemanticTokenTypes3["namespace"] = "namespace";
          SemanticTokenTypes3["type"] = "type";
          SemanticTokenTypes3["class"] = "class";
          SemanticTokenTypes3["enum"] = "enum";
          SemanticTokenTypes3["interface"] = "interface";
          SemanticTokenTypes3["struct"] = "struct";
          SemanticTokenTypes3["typeParameter"] = "typeParameter";
          SemanticTokenTypes3["parameter"] = "parameter";
          SemanticTokenTypes3["variable"] = "variable";
          SemanticTokenTypes3["property"] = "property";
          SemanticTokenTypes3["enumMember"] = "enumMember";
          SemanticTokenTypes3["event"] = "event";
          SemanticTokenTypes3["function"] = "function";
          SemanticTokenTypes3["method"] = "method";
          SemanticTokenTypes3["macro"] = "macro";
          SemanticTokenTypes3["keyword"] = "keyword";
          SemanticTokenTypes3["modifier"] = "modifier";
          SemanticTokenTypes3["comment"] = "comment";
          SemanticTokenTypes3["string"] = "string";
          SemanticTokenTypes3["number"] = "number";
          SemanticTokenTypes3["regexp"] = "regexp";
          SemanticTokenTypes3["operator"] = "operator";
          SemanticTokenTypes3["decorator"] = "decorator";
        })(SemanticTokenTypes2 = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
        var SemanticTokenModifiers2;
        (function(SemanticTokenModifiers3) {
          SemanticTokenModifiers3["declaration"] = "declaration";
          SemanticTokenModifiers3["definition"] = "definition";
          SemanticTokenModifiers3["readonly"] = "readonly";
          SemanticTokenModifiers3["static"] = "static";
          SemanticTokenModifiers3["deprecated"] = "deprecated";
          SemanticTokenModifiers3["abstract"] = "abstract";
          SemanticTokenModifiers3["async"] = "async";
          SemanticTokenModifiers3["modification"] = "modification";
          SemanticTokenModifiers3["documentation"] = "documentation";
          SemanticTokenModifiers3["defaultLibrary"] = "defaultLibrary";
        })(SemanticTokenModifiers2 = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
        var SemanticTokens2;
        (function(SemanticTokens3) {
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
          }
          SemanticTokens3.is = is;
        })(SemanticTokens2 = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
        var InlineValueText2;
        (function(InlineValueText3) {
          function create(range, text) {
            return { range, text };
          }
          InlineValueText3.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is2.string(candidate.text);
          }
          InlineValueText3.is = is;
        })(InlineValueText2 = exports2.InlineValueText || (exports2.InlineValueText = {}));
        var InlineValueVariableLookup2;
        (function(InlineValueVariableLookup3) {
          function create(range, variableName, caseSensitiveLookup) {
            return { range, variableName, caseSensitiveLookup };
          }
          InlineValueVariableLookup3.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is2.boolean(candidate.caseSensitiveLookup) && (Is2.string(candidate.variableName) || candidate.variableName === void 0);
          }
          InlineValueVariableLookup3.is = is;
        })(InlineValueVariableLookup2 = exports2.InlineValueVariableLookup || (exports2.InlineValueVariableLookup = {}));
        var InlineValueEvaluatableExpression2;
        (function(InlineValueEvaluatableExpression3) {
          function create(range, expression) {
            return { range, expression };
          }
          InlineValueEvaluatableExpression3.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && (Is2.string(candidate.expression) || candidate.expression === void 0);
          }
          InlineValueEvaluatableExpression3.is = is;
        })(InlineValueEvaluatableExpression2 = exports2.InlineValueEvaluatableExpression || (exports2.InlineValueEvaluatableExpression = {}));
        var InlineValueContext2;
        (function(InlineValueContext3) {
          function create(frameId, stoppedLocation) {
            return { frameId, stoppedLocation };
          }
          InlineValueContext3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Range2.is(value.stoppedLocation);
          }
          InlineValueContext3.is = is;
        })(InlineValueContext2 = exports2.InlineValueContext || (exports2.InlineValueContext = {}));
        var InlayHintKind2;
        (function(InlayHintKind3) {
          InlayHintKind3.Type = 1;
          InlayHintKind3.Parameter = 2;
          function is(value) {
            return value === 1 || value === 2;
          }
          InlayHintKind3.is = is;
        })(InlayHintKind2 = exports2.InlayHintKind || (exports2.InlayHintKind = {}));
        var InlayHintLabelPart2;
        (function(InlayHintLabelPart3) {
          function create(value) {
            return { value };
          }
          InlayHintLabelPart3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is2.string(candidate.tooltip) || MarkupContent2.is(candidate.tooltip)) && (candidate.location === void 0 || Location2.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
          }
          InlayHintLabelPart3.is = is;
        })(InlayHintLabelPart2 = exports2.InlayHintLabelPart || (exports2.InlayHintLabelPart = {}));
        var InlayHint2;
        (function(InlayHint3) {
          function create(position, label, kind) {
            var result = { position, label };
            if (kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          InlayHint3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && Position2.is(candidate.position) && (Is2.string(candidate.label) || Is2.typedArray(candidate.label, InlayHintLabelPart2.is)) && (candidate.kind === void 0 || InlayHintKind2.is(candidate.kind)) && candidate.textEdits === void 0 || Is2.typedArray(candidate.textEdits, TextEdit2.is) && (candidate.tooltip === void 0 || Is2.string(candidate.tooltip) || MarkupContent2.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is2.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is2.boolean(candidate.paddingRight));
          }
          InlayHint3.is = is;
        })(InlayHint2 = exports2.InlayHint || (exports2.InlayHint = {}));
        var WorkspaceFolder2;
        (function(WorkspaceFolder3) {
          function is(value) {
            var candidate = value;
            return Is2.objectLiteral(candidate) && URI2.is(candidate.uri) && Is2.string(candidate.name);
          }
          WorkspaceFolder3.is = is;
        })(WorkspaceFolder2 = exports2.WorkspaceFolder || (exports2.WorkspaceFolder = {}));
        exports2.EOL = ["\n", "\r\n", "\r"];
        var TextDocument2;
        (function(TextDocument3) {
          function create(uri, languageId, version, content) {
            return new FullTextDocument2(uri, languageId, version, content);
          }
          TextDocument3.create = create;
          function is(value) {
            var candidate = value;
            return Is2.defined(candidate) && Is2.string(candidate.uri) && (Is2.undefined(candidate.languageId) || Is2.string(candidate.languageId)) && Is2.uinteger(candidate.lineCount) && Is2.func(candidate.getText) && Is2.func(candidate.positionAt) && Is2.func(candidate.offsetAt) ? true : false;
          }
          TextDocument3.is = is;
          function applyEdits(document2, edits) {
            var text = document2.getText();
            var sortedEdits = mergeSort(edits, function(a, b) {
              var diff = a.range.start.line - b.range.start.line;
              if (diff === 0) {
                return a.range.start.character - b.range.start.character;
              }
              return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
              var e = sortedEdits[i];
              var startOffset = document2.offsetAt(e.range.start);
              var endOffset = document2.offsetAt(e.range.end);
              if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
              } else {
                throw new Error("Overlapping edit");
              }
              lastModifiedOffset = startOffset;
            }
            return text;
          }
          TextDocument3.applyEdits = applyEdits;
          function mergeSort(data, compare) {
            if (data.length <= 1) {
              return data;
            }
            var p = data.length / 2 | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort(left, compare);
            mergeSort(right, compare);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
              var ret = compare(left[leftIdx], right[rightIdx]);
              if (ret <= 0) {
                data[i++] = left[leftIdx++];
              } else {
                data[i++] = right[rightIdx++];
              }
            }
            while (leftIdx < left.length) {
              data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
              data[i++] = right[rightIdx++];
            }
            return data;
          }
        })(TextDocument2 = exports2.TextDocument || (exports2.TextDocument = {}));
        var FullTextDocument2 = (
          /** @class */
          (function() {
            function FullTextDocument3(uri, languageId, version, content) {
              this._uri = uri;
              this._languageId = languageId;
              this._version = version;
              this._content = content;
              this._lineOffsets = void 0;
            }
            Object.defineProperty(FullTextDocument3.prototype, "uri", {
              get: function() {
                return this._uri;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(FullTextDocument3.prototype, "languageId", {
              get: function() {
                return this._languageId;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(FullTextDocument3.prototype, "version", {
              get: function() {
                return this._version;
              },
              enumerable: false,
              configurable: true
            });
            FullTextDocument3.prototype.getText = function(range) {
              if (range) {
                var start = this.offsetAt(range.start);
                var end = this.offsetAt(range.end);
                return this._content.substring(start, end);
              }
              return this._content;
            };
            FullTextDocument3.prototype.update = function(event, version) {
              this._content = event.text;
              this._version = version;
              this._lineOffsets = void 0;
            };
            FullTextDocument3.prototype.getLineOffsets = function() {
              if (this._lineOffsets === void 0) {
                var lineOffsets = [];
                var text = this._content;
                var isLineStart = true;
                for (var i = 0; i < text.length; i++) {
                  if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                  }
                  var ch = text.charAt(i);
                  isLineStart = ch === "\r" || ch === "\n";
                  if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                    i++;
                  }
                }
                if (isLineStart && text.length > 0) {
                  lineOffsets.push(text.length);
                }
                this._lineOffsets = lineOffsets;
              }
              return this._lineOffsets;
            };
            FullTextDocument3.prototype.positionAt = function(offset) {
              offset = Math.max(Math.min(offset, this._content.length), 0);
              var lineOffsets = this.getLineOffsets();
              var low = 0, high = lineOffsets.length;
              if (high === 0) {
                return Position2.create(0, offset);
              }
              while (low < high) {
                var mid = Math.floor((low + high) / 2);
                if (lineOffsets[mid] > offset) {
                  high = mid;
                } else {
                  low = mid + 1;
                }
              }
              var line = low - 1;
              return Position2.create(line, offset - lineOffsets[line]);
            };
            FullTextDocument3.prototype.offsetAt = function(position) {
              var lineOffsets = this.getLineOffsets();
              if (position.line >= lineOffsets.length) {
                return this._content.length;
              } else if (position.line < 0) {
                return 0;
              }
              var lineOffset = lineOffsets[position.line];
              var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
              return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
            };
            Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
              get: function() {
                return this.getLineOffsets().length;
              },
              enumerable: false,
              configurable: true
            });
            return FullTextDocument3;
          })()
        );
        var Is2;
        (function(Is3) {
          var toString = Object.prototype.toString;
          function defined(value) {
            return typeof value !== "undefined";
          }
          Is3.defined = defined;
          function undefined2(value) {
            return typeof value === "undefined";
          }
          Is3.undefined = undefined2;
          function boolean(value) {
            return value === true || value === false;
          }
          Is3.boolean = boolean;
          function string(value) {
            return toString.call(value) === "[object String]";
          }
          Is3.string = string;
          function number(value) {
            return toString.call(value) === "[object Number]";
          }
          Is3.number = number;
          function numberRange(value, min, max) {
            return toString.call(value) === "[object Number]" && min <= value && value <= max;
          }
          Is3.numberRange = numberRange;
          function integer3(value) {
            return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
          }
          Is3.integer = integer3;
          function uinteger3(value) {
            return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
          }
          Is3.uinteger = uinteger3;
          function func(value) {
            return toString.call(value) === "[object Function]";
          }
          Is3.func = func;
          function objectLiteral(value) {
            return value !== null && typeof value === "object";
          }
          Is3.objectLiteral = objectLiteral;
          function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
          }
          Is3.typedArray = typedArray;
        })(Is2 || (Is2 = {}));
      });
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/messages.js
  var require_messages6 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
      var vscode_jsonrpc_1 = require_main6();
      var RegistrationType = class {
        constructor(method) {
          this.method = method;
        }
      };
      exports.RegistrationType = RegistrationType;
      var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
        constructor(method) {
          super(method);
        }
      };
      exports.ProtocolRequestType0 = ProtocolRequestType0;
      var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports.ProtocolRequestType = ProtocolRequestType;
      var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
        constructor(method) {
          super(method);
        }
      };
      exports.ProtocolNotificationType0 = ProtocolNotificationType0;
      var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports.ProtocolNotificationType = ProtocolNotificationType;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
  var require_is6 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports.typedArray = typedArray;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      exports.objectLiteral = objectLiteral;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
  var require_protocol_implementation2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ImplementationRequest = void 0;
      var messages_1 = require_messages6();
      var ImplementationRequest;
      (function(ImplementationRequest2) {
        ImplementationRequest2.method = "textDocument/implementation";
        ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
      })(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
  var require_protocol_typeDefinition2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeDefinitionRequest = void 0;
      var messages_1 = require_messages6();
      var TypeDefinitionRequest;
      (function(TypeDefinitionRequest2) {
        TypeDefinitionRequest2.method = "textDocument/typeDefinition";
        TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
      })(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
  var require_protocol_workspaceFolder2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
      var messages_1 = require_messages6();
      var WorkspaceFoldersRequest;
      (function(WorkspaceFoldersRequest2) {
        WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
      })(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
      var DidChangeWorkspaceFoldersNotification;
      (function(DidChangeWorkspaceFoldersNotification2) {
        DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
      })(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
  var require_protocol_configuration2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConfigurationRequest = void 0;
      var messages_1 = require_messages6();
      var ConfigurationRequest;
      (function(ConfigurationRequest2) {
        ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
      })(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
  var require_protocol_colorProvider2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
      var messages_1 = require_messages6();
      var DocumentColorRequest;
      (function(DocumentColorRequest2) {
        DocumentColorRequest2.method = "textDocument/documentColor";
        DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
      })(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
      var ColorPresentationRequest;
      (function(ColorPresentationRequest2) {
        ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
      })(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
  var require_protocol_foldingRange2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FoldingRangeRequest = void 0;
      var messages_1 = require_messages6();
      var FoldingRangeRequest;
      (function(FoldingRangeRequest2) {
        FoldingRangeRequest2.method = "textDocument/foldingRange";
        FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
      })(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
  var require_protocol_declaration2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeclarationRequest = void 0;
      var messages_1 = require_messages6();
      var DeclarationRequest;
      (function(DeclarationRequest2) {
        DeclarationRequest2.method = "textDocument/declaration";
        DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
      })(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
  var require_protocol_selectionRange2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectionRangeRequest = void 0;
      var messages_1 = require_messages6();
      var SelectionRangeRequest;
      (function(SelectionRangeRequest2) {
        SelectionRangeRequest2.method = "textDocument/selectionRange";
        SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
      })(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
  var require_protocol_progress2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
      var vscode_jsonrpc_1 = require_main6();
      var messages_1 = require_messages6();
      var WorkDoneProgress;
      (function(WorkDoneProgress2) {
        WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
        function is(value) {
          return value === WorkDoneProgress2.type;
        }
        WorkDoneProgress2.is = is;
      })(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
      var WorkDoneProgressCreateRequest;
      (function(WorkDoneProgressCreateRequest2) {
        WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
        WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
      })(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
      var WorkDoneProgressCancelNotification;
      (function(WorkDoneProgressCancelNotification2) {
        WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
        WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
      })(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
  var require_protocol_callHierarchy2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages6();
      var CallHierarchyPrepareRequest;
      (function(CallHierarchyPrepareRequest2) {
        CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
        CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
      })(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
      var CallHierarchyIncomingCallsRequest;
      (function(CallHierarchyIncomingCallsRequest2) {
        CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
        CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
      })(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
      var CallHierarchyOutgoingCallsRequest;
      (function(CallHierarchyOutgoingCallsRequest2) {
        CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
        CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
      })(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
  var require_protocol_semanticTokens2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
      var messages_1 = require_messages6();
      var TokenFormat;
      (function(TokenFormat2) {
        TokenFormat2.Relative = "relative";
      })(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
      var SemanticTokensRegistrationType;
      (function(SemanticTokensRegistrationType2) {
        SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
        SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
      })(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
      var SemanticTokensRequest;
      (function(SemanticTokensRequest2) {
        SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
        SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      })(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
      var SemanticTokensDeltaRequest;
      (function(SemanticTokensDeltaRequest2) {
        SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
        SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      })(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
      var SemanticTokensRangeRequest;
      (function(SemanticTokensRangeRequest2) {
        SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
        SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      })(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
      var SemanticTokensRefreshRequest;
      (function(SemanticTokensRefreshRequest2) {
        SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
        SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
      })(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
  var require_protocol_showDocument2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShowDocumentRequest = void 0;
      var messages_1 = require_messages6();
      var ShowDocumentRequest;
      (function(ShowDocumentRequest2) {
        ShowDocumentRequest2.method = "window/showDocument";
        ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
      })(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
  var require_protocol_linkedEditingRange2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LinkedEditingRangeRequest = void 0;
      var messages_1 = require_messages6();
      var LinkedEditingRangeRequest;
      (function(LinkedEditingRangeRequest2) {
        LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
        LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
      })(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
  var require_protocol_fileOperations2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
      var messages_1 = require_messages6();
      var FileOperationPatternKind;
      (function(FileOperationPatternKind2) {
        FileOperationPatternKind2.file = "file";
        FileOperationPatternKind2.folder = "folder";
      })(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
      var WillCreateFilesRequest;
      (function(WillCreateFilesRequest2) {
        WillCreateFilesRequest2.method = "workspace/willCreateFiles";
        WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
      })(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
      var DidCreateFilesNotification;
      (function(DidCreateFilesNotification2) {
        DidCreateFilesNotification2.method = "workspace/didCreateFiles";
        DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
      })(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
      var WillRenameFilesRequest;
      (function(WillRenameFilesRequest2) {
        WillRenameFilesRequest2.method = "workspace/willRenameFiles";
        WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
      })(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
      var DidRenameFilesNotification;
      (function(DidRenameFilesNotification2) {
        DidRenameFilesNotification2.method = "workspace/didRenameFiles";
        DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
      })(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
      var DidDeleteFilesNotification;
      (function(DidDeleteFilesNotification2) {
        DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
        DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
      })(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
      var WillDeleteFilesRequest;
      (function(WillDeleteFilesRequest2) {
        WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
        WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
      })(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
  var require_protocol_moniker2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
      var messages_1 = require_messages6();
      var UniquenessLevel;
      (function(UniquenessLevel2) {
        UniquenessLevel2.document = "document";
        UniquenessLevel2.project = "project";
        UniquenessLevel2.group = "group";
        UniquenessLevel2.scheme = "scheme";
        UniquenessLevel2.global = "global";
      })(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
      var MonikerKind;
      (function(MonikerKind2) {
        MonikerKind2.$import = "import";
        MonikerKind2.$export = "export";
        MonikerKind2.local = "local";
      })(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
      var MonikerRequest;
      (function(MonikerRequest2) {
        MonikerRequest2.method = "textDocument/moniker";
        MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
      })(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
  var require_protocol_typeHierarchy2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages6();
      var TypeHierarchyPrepareRequest;
      (function(TypeHierarchyPrepareRequest2) {
        TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
        TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
      })(TypeHierarchyPrepareRequest = exports.TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = {}));
      var TypeHierarchySupertypesRequest;
      (function(TypeHierarchySupertypesRequest2) {
        TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
        TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
      })(TypeHierarchySupertypesRequest = exports.TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = {}));
      var TypeHierarchySubtypesRequest;
      (function(TypeHierarchySubtypesRequest2) {
        TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
        TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
      })(TypeHierarchySubtypesRequest = exports.TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
  var require_protocol_inlineValue2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
      var messages_1 = require_messages6();
      var InlineValueRequest;
      (function(InlineValueRequest2) {
        InlineValueRequest2.method = "textDocument/inlineValue";
        InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
      })(InlineValueRequest = exports.InlineValueRequest || (exports.InlineValueRequest = {}));
      var InlineValueRefreshRequest;
      (function(InlineValueRefreshRequest2) {
        InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
        InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
      })(InlineValueRefreshRequest = exports.InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
  var require_protocol_inlayHint2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
      var messages_1 = require_messages6();
      var InlayHintRequest;
      (function(InlayHintRequest2) {
        InlayHintRequest2.method = "textDocument/inlayHint";
        InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
      })(InlayHintRequest = exports.InlayHintRequest || (exports.InlayHintRequest = {}));
      var InlayHintResolveRequest;
      (function(InlayHintResolveRequest2) {
        InlayHintResolveRequest2.method = "inlayHint/resolve";
        InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
      })(InlayHintResolveRequest = exports.InlayHintResolveRequest || (exports.InlayHintResolveRequest = {}));
      var InlayHintRefreshRequest;
      (function(InlayHintRefreshRequest2) {
        InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
        InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
      })(InlayHintRefreshRequest = exports.InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
  var require_protocol_diagnostic2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
      var vscode_jsonrpc_1 = require_main6();
      var Is2 = require_is6();
      var messages_1 = require_messages6();
      var DiagnosticServerCancellationData;
      (function(DiagnosticServerCancellationData2) {
        function is(value) {
          const candidate = value;
          return candidate && Is2.boolean(candidate.retriggerRequest);
        }
        DiagnosticServerCancellationData2.is = is;
      })(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
      var DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2.Full = "full";
        DocumentDiagnosticReportKind2.Unchanged = "unchanged";
      })(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
      var DocumentDiagnosticRequest;
      (function(DocumentDiagnosticRequest2) {
        DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
        DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
        DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
      var WorkspaceDiagnosticRequest;
      (function(WorkspaceDiagnosticRequest2) {
        WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
        WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
        WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
      var DiagnosticRefreshRequest;
      (function(DiagnosticRefreshRequest2) {
        DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
        DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
      })(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
  var require_protocol_notebook2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
      var vscode_languageserver_types_1 = require_main7();
      var Is2 = require_is6();
      var messages_1 = require_messages6();
      var NotebookCellKind;
      (function(NotebookCellKind2) {
        NotebookCellKind2.Markup = 1;
        NotebookCellKind2.Code = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        NotebookCellKind2.is = is;
      })(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));
      var ExecutionSummary;
      (function(ExecutionSummary2) {
        function create(executionOrder, success) {
          const result = { executionOrder };
          if (success === true || success === false) {
            result.success = success;
          }
          return result;
        }
        ExecutionSummary2.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
        }
        ExecutionSummary2.is = is;
        function equals(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          return one.executionOrder === other.executionOrder && one.success === other.success;
        }
        ExecutionSummary2.equals = equals;
      })(ExecutionSummary = exports.ExecutionSummary || (exports.ExecutionSummary = {}));
      var NotebookCell;
      (function(NotebookCell2) {
        function create(kind, document2) {
          return { kind, document: document2 };
        }
        NotebookCell2.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
        }
        NotebookCell2.is = is;
        function diff(one, two) {
          const result = /* @__PURE__ */ new Set();
          if (one.document !== two.document) {
            result.add("document");
          }
          if (one.kind !== two.kind) {
            result.add("kind");
          }
          if (one.executionSummary !== two.executionSummary) {
            result.add("executionSummary");
          }
          if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add("metadata");
          }
          if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add("executionSummary");
          }
          return result;
        }
        NotebookCell2.diff = diff;
        function equalsMetadata(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          if (typeof one !== typeof other) {
            return false;
          }
          if (typeof one !== "object") {
            return false;
          }
          const oneArray = Array.isArray(one);
          const otherArray = Array.isArray(other);
          if (oneArray !== otherArray) {
            return false;
          }
          if (oneArray && otherArray) {
            if (one.length !== other.length) {
              return false;
            }
            for (let i = 0; i < one.length; i++) {
              if (!equalsMetadata(one[i], other[i])) {
                return false;
              }
            }
          }
          if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
              return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
              return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
              const prop = oneKeys[i];
              if (!equalsMetadata(one[prop], other[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      })(NotebookCell = exports.NotebookCell || (exports.NotebookCell = {}));
      var NotebookDocument;
      (function(NotebookDocument2) {
        function create(uri, notebookType, version, cells) {
          return { uri, notebookType, version, cells };
        }
        NotebookDocument2.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
        }
        NotebookDocument2.is = is;
      })(NotebookDocument = exports.NotebookDocument || (exports.NotebookDocument = {}));
      var NotebookDocumentSyncRegistrationType;
      (function(NotebookDocumentSyncRegistrationType2) {
        NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
        NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
      })(NotebookDocumentSyncRegistrationType = exports.NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = {}));
      var DidOpenNotebookDocumentNotification;
      (function(DidOpenNotebookDocumentNotification2) {
        DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
        DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      })(DidOpenNotebookDocumentNotification = exports.DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = {}));
      var NotebookCellArrayChange;
      (function(NotebookCellArrayChange2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
        }
        NotebookCellArrayChange2.is = is;
        function create(start, deleteCount, cells) {
          const result = { start, deleteCount };
          if (cells !== void 0) {
            result.cells = cells;
          }
          return result;
        }
        NotebookCellArrayChange2.create = create;
      })(NotebookCellArrayChange = exports.NotebookCellArrayChange || (exports.NotebookCellArrayChange = {}));
      var DidChangeNotebookDocumentNotification;
      (function(DidChangeNotebookDocumentNotification2) {
        DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
        DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      })(DidChangeNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = {}));
      var DidSaveNotebookDocumentNotification;
      (function(DidSaveNotebookDocumentNotification2) {
        DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
        DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      })(DidSaveNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = {}));
      var DidCloseNotebookDocumentNotification;
      (function(DidCloseNotebookDocumentNotification2) {
        DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
        DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      })(DidCloseNotebookDocumentNotification = exports.DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
  var require_protocol2 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
      exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
      exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = void 0;
      var messages_1 = require_messages6();
      var vscode_languageserver_types_1 = require_main7();
      var Is2 = require_is6();
      var protocol_implementation_1 = require_protocol_implementation2();
      Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
        return protocol_implementation_1.ImplementationRequest;
      } });
      var protocol_typeDefinition_1 = require_protocol_typeDefinition2();
      Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
        return protocol_typeDefinition_1.TypeDefinitionRequest;
      } });
      var protocol_workspaceFolder_1 = require_protocol_workspaceFolder2();
      Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
      } });
      Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
      } });
      var protocol_configuration_1 = require_protocol_configuration2();
      Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
        return protocol_configuration_1.ConfigurationRequest;
      } });
      var protocol_colorProvider_1 = require_protocol_colorProvider2();
      Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.DocumentColorRequest;
      } });
      Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.ColorPresentationRequest;
      } });
      var protocol_foldingRange_1 = require_protocol_foldingRange2();
      Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRequest;
      } });
      var protocol_declaration_1 = require_protocol_declaration2();
      Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
        return protocol_declaration_1.DeclarationRequest;
      } });
      var protocol_selectionRange_1 = require_protocol_selectionRange2();
      Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
        return protocol_selectionRange_1.SelectionRangeRequest;
      } });
      var protocol_progress_1 = require_protocol_progress2();
      Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgress;
      } });
      Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCreateRequest;
      } });
      Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCancelNotification;
      } });
      var protocol_callHierarchy_1 = require_protocol_callHierarchy2();
      Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
      } });
      Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
      } });
      Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
      } });
      var protocol_semanticTokens_1 = require_protocol_semanticTokens2();
      Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.TokenFormat;
      } });
      Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRequest;
      } });
      Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
      } });
      Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
      } });
      Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
      } });
      Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
      } });
      var protocol_showDocument_1 = require_protocol_showDocument2();
      Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
        return protocol_showDocument_1.ShowDocumentRequest;
      } });
      var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange2();
      Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
      } });
      var protocol_fileOperations_1 = require_protocol_fileOperations2();
      Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
        return protocol_fileOperations_1.FileOperationPatternKind;
      } });
      Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidCreateFilesNotification;
      } });
      Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillCreateFilesRequest;
      } });
      Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidRenameFilesNotification;
      } });
      Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillRenameFilesRequest;
      } });
      Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidDeleteFilesNotification;
      } });
      Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillDeleteFilesRequest;
      } });
      var protocol_moniker_1 = require_protocol_moniker2();
      Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
        return protocol_moniker_1.UniquenessLevel;
      } });
      Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerKind;
      } });
      Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerRequest;
      } });
      var protocol_typeHierarchy_1 = require_protocol_typeHierarchy2();
      Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
      } });
      Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
      } });
      Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
      } });
      var protocol_inlineValue_1 = require_protocol_inlineValue2();
      Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRequest;
      } });
      Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRefreshRequest;
      } });
      var protocol_inlayHint_1 = require_protocol_inlayHint2();
      Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRequest;
      } });
      Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintResolveRequest;
      } });
      Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRefreshRequest;
      } });
      var protocol_diagnostic_1 = require_protocol_diagnostic2();
      Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticServerCancellationData;
      } });
      Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
      } });
      Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticRequest;
      } });
      Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
      } });
      Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticRefreshRequest;
      } });
      var protocol_notebook_1 = require_protocol_notebook2();
      Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellKind;
      } });
      Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function() {
        return protocol_notebook_1.ExecutionSummary;
      } });
      Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCell;
      } });
      Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocument;
      } });
      Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
      } });
      Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
      } });
      Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellArrayChange;
      } });
      Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
      } });
      Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
      } });
      Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
      } });
      var TextDocumentFilter;
      (function(TextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern);
        }
        TextDocumentFilter2.is = is;
      })(TextDocumentFilter = exports.TextDocumentFilter || (exports.TextDocumentFilter = {}));
      var NotebookDocumentFilter;
      (function(NotebookDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
        }
        NotebookDocumentFilter2.is = is;
      })(NotebookDocumentFilter = exports.NotebookDocumentFilter || (exports.NotebookDocumentFilter = {}));
      var NotebookCellTextDocumentFilter;
      (function(NotebookCellTextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
        }
        NotebookCellTextDocumentFilter2.is = is;
      })(NotebookCellTextDocumentFilter = exports.NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = {}));
      var DocumentSelector;
      (function(DocumentSelector2) {
        function is(value) {
          if (!Array.isArray(value)) {
            return false;
          }
          for (let elem of value) {
            if (!Is2.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
              return false;
            }
          }
          return true;
        }
        DocumentSelector2.is = is;
      })(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
      var RegistrationRequest;
      (function(RegistrationRequest2) {
        RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
      })(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
      var UnregistrationRequest;
      (function(UnregistrationRequest2) {
        UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
      })(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
      var ResourceOperationKind;
      (function(ResourceOperationKind2) {
        ResourceOperationKind2.Create = "create";
        ResourceOperationKind2.Rename = "rename";
        ResourceOperationKind2.Delete = "delete";
      })(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
      var FailureHandlingKind;
      (function(FailureHandlingKind2) {
        FailureHandlingKind2.Abort = "abort";
        FailureHandlingKind2.Transactional = "transactional";
        FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
        FailureHandlingKind2.Undo = "undo";
      })(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
      var PositionEncodingKind;
      (function(PositionEncodingKind2) {
        PositionEncodingKind2.UTF8 = "utf-8";
        PositionEncodingKind2.UTF16 = "utf-16";
        PositionEncodingKind2.UTF32 = "utf-32";
      })(PositionEncodingKind = exports.PositionEncodingKind || (exports.PositionEncodingKind = {}));
      var StaticRegistrationOptions;
      (function(StaticRegistrationOptions2) {
        function hasId(value) {
          const candidate = value;
          return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
        }
        StaticRegistrationOptions2.hasId = hasId;
      })(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
      var TextDocumentRegistrationOptions;
      (function(TextDocumentRegistrationOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
        }
        TextDocumentRegistrationOptions2.is = is;
      })(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
      var WorkDoneProgressOptions;
      (function(WorkDoneProgressOptions2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
        }
        WorkDoneProgressOptions2.is = is;
        function hasWorkDoneProgress(value) {
          const candidate = value;
          return candidate && Is2.boolean(candidate.workDoneProgress);
        }
        WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
      })(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
      var InitializeRequest;
      (function(InitializeRequest2) {
        InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
      })(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
      var InitializeErrorCodes;
      (function(InitializeErrorCodes2) {
        InitializeErrorCodes2.unknownProtocolVersion = 1;
      })(InitializeErrorCodes = exports.InitializeErrorCodes || (exports.InitializeErrorCodes = {}));
      var InitializedNotification;
      (function(InitializedNotification2) {
        InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
      })(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
      var ShutdownRequest;
      (function(ShutdownRequest2) {
        ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
      })(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
      var ExitNotification;
      (function(ExitNotification2) {
        ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
      })(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
      var DidChangeConfigurationNotification;
      (function(DidChangeConfigurationNotification2) {
        DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
      })(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
      var MessageType;
      (function(MessageType2) {
        MessageType2.Error = 1;
        MessageType2.Warning = 2;
        MessageType2.Info = 3;
        MessageType2.Log = 4;
      })(MessageType = exports.MessageType || (exports.MessageType = {}));
      var ShowMessageNotification;
      (function(ShowMessageNotification2) {
        ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
      })(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
      var ShowMessageRequest;
      (function(ShowMessageRequest2) {
        ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
      })(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
      var LogMessageNotification;
      (function(LogMessageNotification2) {
        LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
      })(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
      var TelemetryEventNotification;
      (function(TelemetryEventNotification2) {
        TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
      })(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
      var TextDocumentSyncKind;
      (function(TextDocumentSyncKind2) {
        TextDocumentSyncKind2.None = 0;
        TextDocumentSyncKind2.Full = 1;
        TextDocumentSyncKind2.Incremental = 2;
      })(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
      var DidOpenTextDocumentNotification;
      (function(DidOpenTextDocumentNotification2) {
        DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
        DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
      })(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
      var TextDocumentContentChangeEvent;
      (function(TextDocumentContentChangeEvent2) {
        function isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        TextDocumentContentChangeEvent2.isIncremental = isIncremental;
        function isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
        TextDocumentContentChangeEvent2.isFull = isFull;
      })(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
      var DidChangeTextDocumentNotification;
      (function(DidChangeTextDocumentNotification2) {
        DidChangeTextDocumentNotification2.method = "textDocument/didChange";
        DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
      })(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
      var DidCloseTextDocumentNotification;
      (function(DidCloseTextDocumentNotification2) {
        DidCloseTextDocumentNotification2.method = "textDocument/didClose";
        DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
      })(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
      var DidSaveTextDocumentNotification;
      (function(DidSaveTextDocumentNotification2) {
        DidSaveTextDocumentNotification2.method = "textDocument/didSave";
        DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
      })(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
      var TextDocumentSaveReason;
      (function(TextDocumentSaveReason2) {
        TextDocumentSaveReason2.Manual = 1;
        TextDocumentSaveReason2.AfterDelay = 2;
        TextDocumentSaveReason2.FocusOut = 3;
      })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
      var WillSaveTextDocumentNotification;
      (function(WillSaveTextDocumentNotification2) {
        WillSaveTextDocumentNotification2.method = "textDocument/willSave";
        WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
      })(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
      var WillSaveTextDocumentWaitUntilRequest;
      (function(WillSaveTextDocumentWaitUntilRequest2) {
        WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
        WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
      })(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
      var DidChangeWatchedFilesNotification;
      (function(DidChangeWatchedFilesNotification2) {
        DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
      })(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
      var FileChangeType;
      (function(FileChangeType2) {
        FileChangeType2.Created = 1;
        FileChangeType2.Changed = 2;
        FileChangeType2.Deleted = 3;
      })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
      var RelativePattern;
      (function(RelativePattern2) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
        }
        RelativePattern2.is = is;
      })(RelativePattern = exports.RelativePattern || (exports.RelativePattern = {}));
      var WatchKind;
      (function(WatchKind2) {
        WatchKind2.Create = 1;
        WatchKind2.Change = 2;
        WatchKind2.Delete = 4;
      })(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
      var PublishDiagnosticsNotification;
      (function(PublishDiagnosticsNotification2) {
        PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
      })(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
      var CompletionTriggerKind;
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2.Invoked = 1;
        CompletionTriggerKind2.TriggerCharacter = 2;
        CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
      })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
      var CompletionRequest;
      (function(CompletionRequest2) {
        CompletionRequest2.method = "textDocument/completion";
        CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
      })(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
      var CompletionResolveRequest;
      (function(CompletionResolveRequest2) {
        CompletionResolveRequest2.method = "completionItem/resolve";
        CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
      })(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
      var HoverRequest;
      (function(HoverRequest2) {
        HoverRequest2.method = "textDocument/hover";
        HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
      })(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
      var SignatureHelpTriggerKind;
      (function(SignatureHelpTriggerKind2) {
        SignatureHelpTriggerKind2.Invoked = 1;
        SignatureHelpTriggerKind2.TriggerCharacter = 2;
        SignatureHelpTriggerKind2.ContentChange = 3;
      })(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
      var SignatureHelpRequest;
      (function(SignatureHelpRequest2) {
        SignatureHelpRequest2.method = "textDocument/signatureHelp";
        SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
      })(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
      var DefinitionRequest;
      (function(DefinitionRequest2) {
        DefinitionRequest2.method = "textDocument/definition";
        DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
      })(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
      var ReferencesRequest;
      (function(ReferencesRequest2) {
        ReferencesRequest2.method = "textDocument/references";
        ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
      })(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
      var DocumentHighlightRequest;
      (function(DocumentHighlightRequest2) {
        DocumentHighlightRequest2.method = "textDocument/documentHighlight";
        DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
      })(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
      var DocumentSymbolRequest;
      (function(DocumentSymbolRequest2) {
        DocumentSymbolRequest2.method = "textDocument/documentSymbol";
        DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
      })(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
      var CodeActionRequest;
      (function(CodeActionRequest2) {
        CodeActionRequest2.method = "textDocument/codeAction";
        CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
      })(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
      var CodeActionResolveRequest;
      (function(CodeActionResolveRequest2) {
        CodeActionResolveRequest2.method = "codeAction/resolve";
        CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
      })(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
      var WorkspaceSymbolRequest;
      (function(WorkspaceSymbolRequest2) {
        WorkspaceSymbolRequest2.method = "workspace/symbol";
        WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
      })(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
      var WorkspaceSymbolResolveRequest;
      (function(WorkspaceSymbolResolveRequest2) {
        WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
        WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
      })(WorkspaceSymbolResolveRequest = exports.WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = {}));
      var CodeLensRequest;
      (function(CodeLensRequest2) {
        CodeLensRequest2.method = "textDocument/codeLens";
        CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
      })(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
      var CodeLensResolveRequest;
      (function(CodeLensResolveRequest2) {
        CodeLensResolveRequest2.method = "codeLens/resolve";
        CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
      })(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
      var CodeLensRefreshRequest;
      (function(CodeLensRefreshRequest2) {
        CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
        CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
      })(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
      var DocumentLinkRequest;
      (function(DocumentLinkRequest2) {
        DocumentLinkRequest2.method = "textDocument/documentLink";
        DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
      })(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
      var DocumentLinkResolveRequest;
      (function(DocumentLinkResolveRequest2) {
        DocumentLinkResolveRequest2.method = "documentLink/resolve";
        DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
      })(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
      var DocumentFormattingRequest;
      (function(DocumentFormattingRequest2) {
        DocumentFormattingRequest2.method = "textDocument/formatting";
        DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
      })(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
      var DocumentRangeFormattingRequest;
      (function(DocumentRangeFormattingRequest2) {
        DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
        DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
      })(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
      var DocumentOnTypeFormattingRequest;
      (function(DocumentOnTypeFormattingRequest2) {
        DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
        DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
      })(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
      var PrepareSupportDefaultBehavior;
      (function(PrepareSupportDefaultBehavior2) {
        PrepareSupportDefaultBehavior2.Identifier = 1;
      })(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
      var RenameRequest;
      (function(RenameRequest2) {
        RenameRequest2.method = "textDocument/rename";
        RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
      })(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
      var PrepareRenameRequest;
      (function(PrepareRenameRequest2) {
        PrepareRenameRequest2.method = "textDocument/prepareRename";
        PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
      })(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
      var ExecuteCommandRequest;
      (function(ExecuteCommandRequest2) {
        ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
      })(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
      var ApplyWorkspaceEditRequest;
      (function(ApplyWorkspaceEditRequest2) {
        ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
      })(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/connection.js
  var require_connection7 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createProtocolConnection = void 0;
      var vscode_jsonrpc_1 = require_main6();
      function createProtocolConnection(input, output, logger, options) {
        if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
      }
      exports.createProtocolConnection = createProtocolConnection;
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/api.js
  var require_api6 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
      __exportStar2(require_main6(), exports);
      __exportStar2(require_main7(), exports);
      __exportStar2(require_messages6(), exports);
      __exportStar2(require_protocol2(), exports);
      var connection_1 = require_connection7();
      Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
        return connection_1.createProtocolConnection;
      } });
      var LSPErrorCodes;
      (function(LSPErrorCodes2) {
        LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
        LSPErrorCodes2.RequestFailed = -32803;
        LSPErrorCodes2.ServerCancelled = -32802;
        LSPErrorCodes2.ContentModified = -32801;
        LSPErrorCodes2.RequestCancelled = -32800;
        LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
      })(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/browser/main.js
  var require_main8 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createProtocolConnection = void 0;
      var browser_1 = require_browser2();
      __exportStar2(require_browser2(), exports);
      __exportStar2(require_api6(), exports);
      function createProtocolConnection(reader, writer, logger, options) {
        return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports.createProtocolConnection = createProtocolConnection;
    }
  });

  // node_modules/vscode-languageclient/lib/common/utils/is.js
  var require_is7 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/utils/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.asPromise = exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports.typedArray = typedArray;
      function thenable(value) {
        return value && func(value.then);
      }
      exports.thenable = thenable;
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error2) => reject(error2));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      exports.asPromise = asPromise;
    }
  });

  // node_modules/vscode-languageclient/lib/common/utils/uuid.js
  var require_uuid = __commonJS({
    "node_modules/vscode-languageclient/lib/common/utils/uuid.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
      var ValueUUID = class {
        constructor(_value) {
          this._value = _value;
        }
        asHex() {
          return this._value;
        }
        equals(other) {
          return this.asHex() === other.asHex();
        }
      };
      var V4UUID = class _V4UUID extends ValueUUID {
        constructor() {
          super([
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            "4",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._oneOf(_V4UUID._timeHighBits),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex()
          ].join(""));
        }
        static _oneOf(array) {
          return array[Math.floor(array.length * Math.random())];
        }
        static _randomHex() {
          return _V4UUID._oneOf(_V4UUID._chars);
        }
      };
      V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      V4UUID._timeHighBits = ["8", "9", "a", "b"];
      exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
      function v4() {
        return new V4UUID();
      }
      exports.v4 = v4;
      var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      function isUUID(value) {
        return _UUIDPattern.test(value);
      }
      exports.isUUID = isUUID;
      function parse(value) {
        if (!isUUID(value)) {
          throw new Error("invalid uuid");
        }
        return new ValueUUID(value);
      }
      exports.parse = parse;
      function generateUuid() {
        return v4().asHex();
      }
      exports.generateUuid = generateUuid;
    }
  });

  // node_modules/vscode-languageclient/lib/common/features.js
  var require_features = __commonJS({
    "node_modules/vscode-languageclient/lib/common/features.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WorkspaceFeature = exports.TextDocumentLanguageFeature = exports.TextDocumentEventFeature = exports.DynamicDocumentFeature = exports.DynamicFeature = exports.StaticFeature = exports.ensure = exports.LSPCancellationError = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var Is2 = require_is7();
      var UUID = require_uuid();
      var LSPCancellationError = class extends vscode_1.CancellationError {
        constructor(data) {
          super();
          this.data = data;
        }
      };
      exports.LSPCancellationError = LSPCancellationError;
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = {};
        }
        return target[key];
      }
      exports.ensure = ensure;
      var StaticFeature;
      (function(StaticFeature2) {
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Is2.func(candidate.fillClientCapabilities) && Is2.func(candidate.initialize) && Is2.func(candidate.getState) && Is2.func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || Is2.func(candidate.fillInitializeParams));
        }
        StaticFeature2.is = is;
      })(StaticFeature = exports.StaticFeature || (exports.StaticFeature = {}));
      var DynamicFeature;
      (function(DynamicFeature2) {
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Is2.func(candidate.fillClientCapabilities) && Is2.func(candidate.initialize) && Is2.func(candidate.getState) && Is2.func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || Is2.func(candidate.fillInitializeParams)) && Is2.func(candidate.register) && Is2.func(candidate.unregister) && candidate.registrationType !== void 0;
        }
        DynamicFeature2.is = is;
      })(DynamicFeature = exports.DynamicFeature || (exports.DynamicFeature = {}));
      var DynamicDocumentFeature = class {
        constructor(client) {
          this._client = client;
        }
        /**
         * Returns the state the feature is in.
         */
        getState() {
          const selectors = this.getDocumentSelectors();
          let count = 0;
          for (const selector of selectors) {
            count++;
            for (const document2 of vscode_1.workspace.textDocuments) {
              if (vscode_1.languages.match(selector, document2) > 0) {
                return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
              }
            }
          }
          const registrations = count > 0;
          return { kind: "document", id: this.registrationType.method, registrations, matches: false };
        }
      };
      exports.DynamicDocumentFeature = DynamicDocumentFeature;
      var TextDocumentEventFeature = class extends DynamicDocumentFeature {
        constructor(client, event, type, middleware, createParams, textDocument, selectorFilter) {
          super(client);
          this._event = event;
          this._type = type;
          this._middleware = middleware;
          this._createParams = createParams;
          this._textDocument = textDocument;
          this._selectorFilter = selectorFilter;
          this._selectors = /* @__PURE__ */ new Map();
          this._onNotificationSent = new vscode_1.EventEmitter();
        }
        static textDocumentFilter(selectors, textDocument) {
          for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument) > 0) {
              return true;
            }
          }
          return false;
        }
        getStateInfo() {
          return [this._selectors.values(), false];
        }
        getDocumentSelectors() {
          return this._selectors.values();
        }
        register(data) {
          if (!data.registerOptions.documentSelector) {
            return;
          }
          if (!this._listener) {
            this._listener = this._event((data2) => {
              this.callback(data2).catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed.`, error);
              });
            });
          }
          this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
        }
        async callback(data) {
          const doSend = async (data2) => {
            const params = this._createParams(data2);
            await this._client.sendNotification(this._type, params).catch();
            this.notificationSent(data2, this._type, params);
          };
          if (this.matches(data)) {
            const middleware = this._middleware();
            return middleware ? middleware(data, (data2) => doSend(data2)) : doSend(data);
          }
        }
        matches(data) {
          if (this._client.hasDedicatedTextSynchronizationFeature(this._textDocument(data))) {
            return false;
          }
          return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
        }
        get onNotificationSent() {
          return this._onNotificationSent.event;
        }
        notificationSent(data, type, params) {
          this._onNotificationSent.fire({ original: data, type, params });
        }
        unregister(id) {
          this._selectors.delete(id);
          if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        dispose() {
          this._selectors.clear();
          this._onNotificationSent.dispose();
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        getProvider(document2) {
          for (const selector of this._selectors.values()) {
            if (vscode_1.languages.match(selector, document2) > 0) {
              return {
                send: (data) => {
                  return this.callback(data);
                }
              };
            }
          }
          return void 0;
        }
      };
      exports.TextDocumentEventFeature = TextDocumentEventFeature;
      var TextDocumentLanguageFeature = class extends DynamicDocumentFeature {
        constructor(client, registrationType) {
          super(client);
          this._registrationType = registrationType;
          this._registrations = /* @__PURE__ */ new Map();
        }
        *getDocumentSelectors() {
          for (const registration of this._registrations.values()) {
            const selector = registration.data.registerOptions.documentSelector;
            if (selector === null) {
              continue;
            }
            yield this._client.protocol2CodeConverter.asDocumentSelector(selector);
          }
        }
        get registrationType() {
          return this._registrationType;
        }
        register(data) {
          if (!data.registerOptions.documentSelector) {
            return;
          }
          let registration = this.registerLanguageProvider(data.registerOptions, data.id);
          this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
        }
        unregister(id) {
          let registration = this._registrations.get(id);
          if (registration !== void 0) {
            registration.disposable.dispose();
          }
        }
        dispose() {
          this._registrations.forEach((value) => {
            value.disposable.dispose();
          });
          this._registrations.clear();
        }
        getRegistration(documentSelector, capability) {
          if (!capability) {
            return [void 0, void 0];
          } else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector || documentSelector;
            if (selector) {
              return [id, Object.assign({}, capability, { documentSelector: selector })];
            }
          } else if (Is2.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
              return [void 0, void 0];
            }
            let options = Is2.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
            return [UUID.generateUuid(), options];
          }
          return [void 0, void 0];
        }
        getRegistrationOptions(documentSelector, capability) {
          if (!documentSelector || !capability) {
            return void 0;
          }
          return Is2.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
        }
        getProvider(textDocument) {
          for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && vscode_1.languages.match(this._client.protocol2CodeConverter.asDocumentSelector(selector), textDocument) > 0) {
              return registration.provider;
            }
          }
          return void 0;
        }
        getAllProviders() {
          const result = [];
          for (const item of this._registrations.values()) {
            result.push(item.provider);
          }
          return result;
        }
      };
      exports.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
      var WorkspaceFeature = class {
        constructor(client, registrationType) {
          this._client = client;
          this._registrationType = registrationType;
          this._registrations = /* @__PURE__ */ new Map();
        }
        getState() {
          const registrations = this._registrations.size > 0;
          return { kind: "workspace", id: this._registrationType.method, registrations };
        }
        get registrationType() {
          return this._registrationType;
        }
        register(data) {
          const registration = this.registerLanguageProvider(data.registerOptions);
          this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
        }
        unregister(id) {
          let registration = this._registrations.get(id);
          if (registration !== void 0) {
            registration.disposable.dispose();
          }
        }
        dispose() {
          this._registrations.forEach((registration) => {
            registration.disposable.dispose();
          });
          this._registrations.clear();
        }
        getProviders() {
          const result = [];
          for (const registration of this._registrations.values()) {
            result.push(registration.provider);
          }
          return result;
        }
      };
      exports.WorkspaceFeature = WorkspaceFeature;
    }
  });

  // node_modules/concat-map/index.js
  var require_concat_map = __commonJS({
    "node_modules/concat-map/index.js"(exports, module) {
      module.exports = function(xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          if (isArray(x)) res.push.apply(res, x);
          else res.push(x);
        }
        return res;
      };
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
    }
  });

  // node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "node_modules/balanced-match/index.js"(exports, module) {
      "use strict";
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    }
  });

  // node_modules/brace-expansion/index.js
  var require_brace_expansion = __commonJS({
    "node_modules/brace-expansion/index.js"(exports, module) {
      var concatMap = require_concat_map();
      var balanced = require_balanced_match();
      module.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m || /\$$/.test(m.pre)) return [str];
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,(?!,).*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              var post = m.post.length ? expand(m.post, false) : [""];
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [""];
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = concatMap(n, function(el) {
            return expand(el, false);
          });
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
        return expansions;
      }
    }
  });

  // node_modules/minimatch/minimatch.js
  var require_minimatch = __commonJS({
    "node_modules/minimatch/minimatch.js"(exports, module) {
      module.exports = minimatch;
      minimatch.Minimatch = Minimatch;
      var path = (function() {
        try {
          return __require("path");
        } catch (e) {
        }
      })() || {
        sep: "/"
      };
      minimatch.sep = path.sep;
      var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
      var expand = require_brace_expansion();
      var plTypes = {
        "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
        "?": { open: "(?:", close: ")?" },
        "+": { open: "(?:", close: ")+" },
        "*": { open: "(?:", close: ")*" },
        "@": { open: "(?:", close: ")" }
      };
      var qmark = "[^/]";
      var star = qmark + "*?";
      var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
      var reSpecials = charSet("().*{}+?[]^$\\!");
      function charSet(s) {
        return s.split("").reduce(function(set, c) {
          set[c] = true;
          return set;
        }, {});
      }
      var slashSplit = /\/+/;
      minimatch.filter = filter;
      function filter(pattern, options) {
        options = options || {};
        return function(p, i, list) {
          return minimatch(p, pattern, options);
        };
      }
      function ext(a, b) {
        b = b || {};
        var t = {};
        Object.keys(a).forEach(function(k) {
          t[k] = a[k];
        });
        Object.keys(b).forEach(function(k) {
          t[k] = b[k];
        });
        return t;
      }
      minimatch.defaults = function(def) {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return minimatch;
        }
        var orig = minimatch;
        var m = function minimatch2(p, pattern, options) {
          return orig(p, pattern, ext(def, options));
        };
        m.Minimatch = function Minimatch2(pattern, options) {
          return new orig.Minimatch(pattern, ext(def, options));
        };
        m.Minimatch.defaults = function defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        };
        m.filter = function filter2(pattern, options) {
          return orig.filter(pattern, ext(def, options));
        };
        m.defaults = function defaults(options) {
          return orig.defaults(ext(def, options));
        };
        m.makeRe = function makeRe2(pattern, options) {
          return orig.makeRe(pattern, ext(def, options));
        };
        m.braceExpand = function braceExpand2(pattern, options) {
          return orig.braceExpand(pattern, ext(def, options));
        };
        m.match = function(list, pattern, options) {
          return orig.match(list, pattern, ext(def, options));
        };
        return m;
      };
      Minimatch.defaults = function(def) {
        return minimatch.defaults(def).Minimatch;
      };
      function minimatch(p, pattern, options) {
        assertValidPattern(pattern);
        if (!options) options = {};
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        return new Minimatch(pattern, options).match(p);
      }
      function Minimatch(pattern, options) {
        if (!(this instanceof Minimatch)) {
          return new Minimatch(pattern, options);
        }
        assertValidPattern(pattern);
        if (!options) options = {};
        pattern = pattern.trim();
        if (!options.allowWindowsEscape && path.sep !== "/") {
          pattern = pattern.split(path.sep).join("/");
        }
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      Minimatch.prototype.debug = function() {
      };
      Minimatch.prototype.make = make;
      function make() {
        var pattern = this.pattern;
        var options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        var set = this.globSet = this.braceExpand();
        if (options.debug) this.debug = function debug() {
          console.error.apply(console, arguments);
        };
        this.debug(this.pattern, set);
        set = this.globParts = set.map(function(s) {
          return s.split(slashSplit);
        });
        this.debug(this.pattern, set);
        set = set.map(function(s, si, set2) {
          return s.map(this.parse, this);
        }, this);
        this.debug(this.pattern, set);
        set = set.filter(function(s) {
          return s.indexOf(false) === -1;
        });
        this.debug(this.pattern, set);
        this.set = set;
      }
      Minimatch.prototype.parseNegate = parseNegate;
      function parseNegate() {
        var pattern = this.pattern;
        var negate = false;
        var options = this.options;
        var negateOffset = 0;
        if (options.nonegate) return;
        for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      minimatch.braceExpand = function(pattern, options) {
        return braceExpand(pattern, options);
      };
      Minimatch.prototype.braceExpand = braceExpand;
      function braceExpand(pattern, options) {
        if (!options) {
          if (this instanceof Minimatch) {
            options = this.options;
          } else {
            options = {};
          }
        }
        pattern = typeof pattern === "undefined" ? this.pattern : pattern;
        assertValidPattern(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          return [pattern];
        }
        return expand(pattern);
      }
      var MAX_PATTERN_LENGTH = 1024 * 64;
      var assertValidPattern = function(pattern) {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }
        if (pattern.length > MAX_PATTERN_LENGTH) {
          throw new TypeError("pattern is too long");
        }
      };
      Minimatch.prototype.parse = parse;
      var SUBPARSE = {};
      function parse(pattern, isSub) {
        assertValidPattern(pattern);
        var options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "") return "";
        var re = "";
        var hasMagic = !!options.nocase;
        var escaping = false;
        var patternListStack = [];
        var negativeLists = [];
        var stateChar;
        var inClass = false;
        var reClassStart = -1;
        var classStart = -1;
        var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        var self = this;
        function clearStateChar() {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            self.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        }
        for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping && reSpecials[c]) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          switch (c) {
            /* istanbul ignore next */
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            // the various stateChar values
            // for the "extglob" stuff.
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1) c = "^";
                re += c;
                continue;
              }
              self.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext) clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              var pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            // these are mostly the same in regexp and glob
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (escaping) {
                escaping = false;
              } else if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          var tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        var addPatternStart = false;
        switch (re.charAt(0)) {
          case "[":
          case ".":
          case "(":
            addPatternStart = true;
        }
        for (var n = negativeLists.length - 1; n > -1; n--) {
          var nl = negativeLists[n];
          var nlBefore = re.slice(0, nl.reStart);
          var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
          var nlAfter = re.slice(nl.reEnd);
          nlLast += nlAfter;
          var openParensBefore = nlBefore.split("(").length - 1;
          var cleanAfter = nlAfter;
          for (i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          var dollar = "";
          if (nlAfter === "" && isSub !== SUBPARSE) {
            dollar = "$";
          }
          var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
          re = newRe;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        var flags = options.nocase ? "i" : "";
        try {
          var regExp = new RegExp("^" + re + "$", flags);
        } catch (er) {
          return new RegExp("$.");
        }
        regExp._glob = pattern;
        regExp._src = re;
        return regExp;
      }
      minimatch.makeRe = function(pattern, options) {
        return new Minimatch(pattern, options || {}).makeRe();
      };
      Minimatch.prototype.makeRe = makeRe;
      function makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        var set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        var options = this.options;
        var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        var flags = options.nocase ? "i" : "";
        var re = set.map(function(pattern) {
          return pattern.map(function(p) {
            return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
          }).join("\\/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate) re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      minimatch.match = function(list, pattern, options) {
        options = options || {};
        var mm = new Minimatch(pattern, options);
        list = list.filter(function(f) {
          return mm.match(f);
        });
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      Minimatch.prototype.match = function match(f, partial) {
        if (typeof partial === "undefined") partial = this.partial;
        this.debug("match", f, this.pattern);
        if (this.comment) return false;
        if (this.empty) return f === "";
        if (f === "/" && partial) return true;
        var options = this.options;
        if (path.sep !== "/") {
          f = f.split(path.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        var set = this.set;
        this.debug(this.pattern, "set", set);
        var filename;
        var i;
        for (i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename) break;
        }
        for (i = 0; i < set.length; i++) {
          var pattern = set[i];
          var file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          var hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) return true;
            return !this.negate;
          }
        }
        if (options.flipNegate) return false;
        return this.negate;
      };
      Minimatch.prototype.matchOne = function(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit) return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      };
      function globUnescape(s) {
        return s.replace(/\\(.)/g, "$1");
      }
      function regExpEscape(s) {
        return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
    }
  });

  // node_modules/vscode-languageclient/lib/common/diagnostic.js
  var require_diagnostic = __commonJS({
    "node_modules/vscode-languageclient/lib/common/diagnostic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;
      var minimatch = require_minimatch();
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var uuid_1 = require_uuid();
      var features_1 = require_features();
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = {};
        }
        return target[key];
      }
      var vsdiag;
      (function(vsdiag2) {
        let DocumentDiagnosticReportKind;
        (function(DocumentDiagnosticReportKind2) {
          DocumentDiagnosticReportKind2["full"] = "full";
          DocumentDiagnosticReportKind2["unChanged"] = "unChanged";
        })(DocumentDiagnosticReportKind = vsdiag2.DocumentDiagnosticReportKind || (vsdiag2.DocumentDiagnosticReportKind = {}));
      })(vsdiag = exports.vsdiag || (exports.vsdiag = {}));
      var DiagnosticPullMode;
      (function(DiagnosticPullMode2) {
        DiagnosticPullMode2["onType"] = "onType";
        DiagnosticPullMode2["onSave"] = "onSave";
      })(DiagnosticPullMode = exports.DiagnosticPullMode || (exports.DiagnosticPullMode = {}));
      var RequestStateKind;
      (function(RequestStateKind2) {
        RequestStateKind2["active"] = "open";
        RequestStateKind2["reschedule"] = "reschedule";
        RequestStateKind2["outDated"] = "drop";
      })(RequestStateKind || (RequestStateKind = {}));
      var Tabs = class {
        constructor() {
          this.open = /* @__PURE__ */ new Set();
          const openTabsHandler = () => {
            this.open.clear();
            for (const group of vscode_1.window.tabGroups.all) {
              for (const tab of group.tabs) {
                const input = tab.input;
                if (input instanceof vscode_1.TabInputText) {
                  this.open.add(input.uri.toString());
                } else if (input instanceof vscode_1.TabInputTextDiff) {
                  this.open.add(input.modified.toString());
                }
              }
            }
          };
          openTabsHandler();
          if (vscode_1.window.tabGroups.onDidChangeTabGroups !== void 0) {
            this.disposable = vscode_1.window.tabGroups.onDidChangeTabGroups(openTabsHandler);
          } else {
            this.disposable = { dispose: () => {
            } };
          }
        }
        dispose() {
          this.disposable.dispose();
        }
        isActive(document2) {
          return document2 instanceof vscode_1.Uri ? vscode_1.window.activeTextEditor?.document.uri === document2 : vscode_1.window.activeTextEditor?.document === document2;
        }
        isVisible(document2) {
          const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
          return this.open.has(uri.toString());
        }
        getTabResources() {
          const result = [];
          for (const group of vscode_1.window.tabGroups.all) {
            for (const tab of group.tabs) {
              const input = tab.input;
              if (input instanceof vscode_1.TabInputText) {
                result.push(input.uri);
              } else if (input instanceof vscode_1.TabInputTextDiff) {
                result.push(input.modified);
              }
            }
          }
          return result;
        }
      };
      var PullState;
      (function(PullState2) {
        PullState2[PullState2["document"] = 1] = "document";
        PullState2[PullState2["workspace"] = 2] = "workspace";
      })(PullState || (PullState = {}));
      var DocumentPullStateTracker = class {
        constructor() {
          this.documentPullStates = /* @__PURE__ */ new Map();
          this.workspacePullStates = /* @__PURE__ */ new Map();
        }
        track(kind, document2, arg1) {
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          const [key, uri, version] = document2 instanceof vscode_1.Uri ? [document2.toString(), document2, arg1] : [document2.uri.toString(), document2.uri, document2.version];
          let state = states.get(key);
          if (state === void 0) {
            state = { document: uri, pulledVersion: version, resultId: void 0 };
            states.set(key, state);
          }
          return state;
        }
        update(kind, document2, arg1, arg2) {
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          const [key, uri, version, resultId] = document2 instanceof vscode_1.Uri ? [document2.toString(), document2, arg1, arg2] : [document2.uri.toString(), document2.uri, document2.version, arg1];
          let state = states.get(key);
          if (state === void 0) {
            state = { document: uri, pulledVersion: version, resultId };
            states.set(key, state);
          } else {
            state.pulledVersion = version;
            state.resultId = resultId;
          }
        }
        unTrack(kind, document2) {
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          states.delete(key);
        }
        tracks(kind, document2) {
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          return states.has(key);
        }
        getResultId(kind, document2) {
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          return states.get(key)?.resultId;
        }
        getAllResultIds() {
          const result = [];
          for (let [uri, value] of this.workspacePullStates) {
            if (this.documentPullStates.has(uri)) {
              value = this.documentPullStates.get(uri);
            }
            if (value.resultId !== void 0) {
              result.push({ uri, value: value.resultId });
            }
          }
          return result;
        }
      };
      var DiagnosticRequestor = class {
        constructor(client, tabs, options) {
          this.client = client;
          this.tabs = tabs;
          this.options = options;
          this.isDisposed = false;
          this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
          this.provider = this.createProvider();
          this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
          this.openRequests = /* @__PURE__ */ new Map();
          this.documentStates = new DocumentPullStateTracker();
          this.workspaceErrorCounter = 0;
        }
        knows(kind, textDocument) {
          return this.documentStates.tracks(kind, textDocument);
        }
        pull(document2, cb) {
          if (this.isDisposed) {
            return;
          }
          const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
          this.pullAsync(document2).then(() => {
            if (cb) {
              cb();
            }
          }, (error) => {
            this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);
          });
        }
        async pullAsync(document2, version) {
          if (this.isDisposed) {
            return;
          }
          const isUri = document2 instanceof vscode_1.Uri;
          const uri = isUri ? document2 : document2.uri;
          const key = uri.toString();
          version = isUri ? version : document2.version;
          const currentRequestState = this.openRequests.get(key);
          const documentState = isUri ? this.documentStates.track(PullState.document, document2, version) : this.documentStates.track(PullState.document, document2);
          if (currentRequestState === void 0) {
            const tokenSource = new vscode_1.CancellationTokenSource();
            this.openRequests.set(key, { state: RequestStateKind.active, document: document2, version, tokenSource });
            let report;
            let afterState;
            try {
              report = await this.provider.provideDiagnostics(document2, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
            } catch (error) {
              if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
                afterState = { state: RequestStateKind.outDated, document: document2 };
              }
              if (afterState === void 0 && error instanceof vscode_1.CancellationError) {
                afterState = { state: RequestStateKind.reschedule, document: document2 };
              } else {
                throw error;
              }
            }
            afterState = afterState ?? this.openRequests.get(key);
            if (afterState === void 0) {
              this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
              this.diagnostics.delete(uri);
              return;
            }
            this.openRequests.delete(key);
            if (!this.tabs.isVisible(document2)) {
              this.documentStates.unTrack(PullState.document, document2);
              return;
            }
            if (afterState.state === RequestStateKind.outDated) {
              return;
            }
            if (report !== void 0) {
              if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                this.diagnostics.set(uri, report.items);
              }
              documentState.pulledVersion = version;
              documentState.resultId = report.resultId;
            }
            if (afterState.state === RequestStateKind.reschedule) {
              this.pull(document2);
            }
          } else {
            if (currentRequestState.state === RequestStateKind.active) {
              currentRequestState.tokenSource.cancel();
              this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            } else if (currentRequestState.state === RequestStateKind.outDated) {
              this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
          }
        }
        cleanupPull(document2) {
          const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
          const key = uri.toString();
          const request = this.openRequests.get(key);
          if (this.options.workspaceDiagnostics || this.options.interFileDependencies) {
            if (request !== void 0) {
              this.openRequests.set(key, { state: RequestStateKind.reschedule, document: document2 });
            } else {
              this.pull(document2);
            }
          } else {
            if (request !== void 0) {
              if (request.state === RequestStateKind.active) {
                request.tokenSource.cancel();
              }
              this.openRequests.set(key, { state: RequestStateKind.outDated, document: document2 });
            }
            this.diagnostics.delete(uri);
          }
        }
        pullWorkspace() {
          if (this.isDisposed) {
            return;
          }
          this.pullWorkspaceAsync().then(() => {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, 2e3);
          }, (error) => {
            if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {
              this.client.error(`Workspace diagnostic pull failed.`, error, false);
              this.workspaceErrorCounter++;
            }
            if (this.workspaceErrorCounter <= 5) {
              this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                this.pullWorkspace();
              }, 2e3);
            }
          });
        }
        async pullWorkspaceAsync() {
          if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {
            return;
          }
          if (this.workspaceCancellation !== void 0) {
            this.workspaceCancellation.cancel();
            this.workspaceCancellation = void 0;
          }
          this.workspaceCancellation = new vscode_1.CancellationTokenSource();
          const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
            return {
              uri: this.client.protocol2CodeConverter.asUri(item.uri),
              value: item.value
            };
          });
          await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
            if (!chunk || this.isDisposed) {
              return;
            }
            for (const item of chunk.items) {
              if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                if (!this.documentStates.tracks(PullState.document, item.uri)) {
                  this.diagnostics.set(item.uri, item.items);
                }
              }
              this.documentStates.update(PullState.workspace, item.uri, item.version ?? void 0, item.resultId);
            }
          });
        }
        createProvider() {
          const result = {
            onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
            provideDiagnostics: (document2, previousResultId, token) => {
              const provideDiagnostics = (document3, previousResultId2, token2) => {
                const params = {
                  identifier: this.options.identifier,
                  textDocument: { uri: this.client.code2ProtocolConverter.asUri(document3 instanceof vscode_1.Uri ? document3 : document3.uri) },
                  previousResultId: previousResultId2
                };
                if (this.isDisposed === true || !this.client.isRunning()) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                }
                return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token2).then(async (result2) => {
                  if (result2 === void 0 || result2 === null || this.isDisposed || token2.isCancellationRequested) {
                    return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                  }
                  if (result2.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                    return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result2.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result2.items, token2) };
                  } else {
                    return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result2.resultId };
                  }
                }, (error) => {
                  return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
                });
              };
              const middleware = this.client.middleware;
              return middleware.provideDiagnostics ? middleware.provideDiagnostics(document2, previousResultId, token, provideDiagnostics) : provideDiagnostics(document2, previousResultId, token);
            }
          };
          if (this.options.workspaceDiagnostics) {
            result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
              const convertReport = async (report) => {
                if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                  return {
                    kind: vsdiag.DocumentDiagnosticReportKind.full,
                    uri: this.client.protocol2CodeConverter.asUri(report.uri),
                    resultId: report.resultId,
                    version: report.version,
                    items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
                  };
                } else {
                  return {
                    kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                    uri: this.client.protocol2CodeConverter.asUri(report.uri),
                    resultId: report.resultId,
                    version: report.version
                  };
                }
              };
              const convertPreviousResultIds = (resultIds2) => {
                const converted = [];
                for (const item of resultIds2) {
                  converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
                }
                return converted;
              };
              const provideDiagnostics = (resultIds2, token2) => {
                const partialResultToken = (0, uuid_1.generateUuid)();
                const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {
                  if (partialResult === void 0 || partialResult === null) {
                    resultReporter(null);
                    return;
                  }
                  const converted = {
                    items: []
                  };
                  for (const item of partialResult.items) {
                    try {
                      converted.items.push(await convertReport(item));
                    } catch (error) {
                      this.client.error(`Converting workspace diagnostics failed.`, error);
                    }
                  }
                  resultReporter(converted);
                });
                const params = {
                  identifier: this.options.identifier,
                  previousResultIds: convertPreviousResultIds(resultIds2),
                  partialResultToken
                };
                if (this.isDisposed === true || !this.client.isRunning()) {
                  return { items: [] };
                }
                return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token2).then(async (result2) => {
                  if (token2.isCancellationRequested) {
                    return { items: [] };
                  }
                  const converted = {
                    items: []
                  };
                  for (const item of result2.items) {
                    converted.items.push(await convertReport(item));
                  }
                  disposable.dispose();
                  resultReporter(converted);
                  return { items: [] };
                }, (error) => {
                  disposable.dispose();
                  return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { items: [] });
                });
              };
              const middleware = this.client.middleware;
              return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics) : provideDiagnostics(resultIds, token, resultReporter);
            };
          }
          return result;
        }
        dispose() {
          this.isDisposed = true;
          this.workspaceCancellation?.cancel();
          this.workspaceTimeout?.dispose();
          for (const [key, request] of this.openRequests) {
            if (request.state === RequestStateKind.active) {
              request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });
          }
        }
      };
      var BackgroundScheduler = class {
        constructor(diagnosticRequestor) {
          this.diagnosticRequestor = diagnosticRequestor;
          this.documents = new vscode_languageserver_protocol_1.LinkedMap();
          this.isDisposed = false;
        }
        add(document2) {
          if (this.isDisposed === true) {
            return;
          }
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          if (this.documents.has(key)) {
            return;
          }
          this.documents.set(key, document2, vscode_languageserver_protocol_1.Touch.Last);
          this.trigger();
        }
        remove(document2) {
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          if (this.documents.has(key)) {
            this.documents.delete(key);
            this.diagnosticRequestor.pull(document2);
          }
          if (this.documents.size === 0) {
            this.stop();
          } else if (document2 === this.endDocument) {
            this.endDocument = this.documents.last;
          }
        }
        trigger() {
          if (this.isDisposed === true) {
            return;
          }
          if (this.intervalHandle !== void 0) {
            this.endDocument = this.documents.last;
            return;
          }
          this.endDocument = this.documents.last;
          this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
            const document2 = this.documents.first;
            if (document2 !== void 0) {
              const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
              this.diagnosticRequestor.pull(document2);
              this.documents.set(key, document2, vscode_languageserver_protocol_1.Touch.Last);
              if (document2 === this.endDocument) {
                this.stop();
              }
            }
          }, 200);
        }
        dispose() {
          this.isDisposed = true;
          this.stop();
          this.documents.clear();
        }
        stop() {
          this.intervalHandle?.dispose();
          this.intervalHandle = void 0;
          this.endDocument = void 0;
        }
      };
      var DiagnosticFeatureProviderImpl = class {
        constructor(client, tabs, options) {
          const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
          const documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
          const disposables = [];
          const matchResource = (resource) => {
            const selector = options.documentSelector;
            if (diagnosticPullOptions.match !== void 0) {
              return diagnosticPullOptions.match(selector, resource);
            }
            for (const filter of selector) {
              if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
                continue;
              }
              if (typeof filter === "string") {
                return false;
              }
              if (filter.language !== void 0 && filter.language !== "*") {
                return false;
              }
              if (filter.scheme !== void 0 && filter.scheme !== "*" && filter.scheme !== resource.scheme) {
                return false;
              }
              if (filter.pattern !== void 0) {
                const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
                if (!matcher.makeRe()) {
                  return false;
                }
                if (!matcher.match(resource.fsPath)) {
                  return false;
                }
              }
            }
            return true;
          };
          const matches = (document2) => {
            return document2 instanceof vscode_1.Uri ? matchResource(document2) : vscode_1.languages.match(documentSelector, document2) > 0 && tabs.isVisible(document2);
          };
          const isActiveDocument = (document2) => {
            return document2 instanceof vscode_1.Uri ? this.activeTextDocument?.uri.toString() === document2.toString() : this.activeTextDocument === document2;
          };
          this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);
          this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
          const addToBackgroundIfNeeded = (document2) => {
            if (!matches(document2) || !options.interFileDependencies || isActiveDocument(document2)) {
              return;
            }
            this.backgroundScheduler.add(document2);
          };
          this.activeTextDocument = vscode_1.window.activeTextEditor?.document;
          vscode_1.window.onDidChangeActiveTextEditor((editor2) => {
            const oldActive = this.activeTextDocument;
            this.activeTextDocument = editor2?.document;
            if (oldActive !== void 0) {
              addToBackgroundIfNeeded(oldActive);
            }
            if (this.activeTextDocument !== void 0) {
              this.backgroundScheduler.remove(this.activeTextDocument);
            }
          });
          const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
          disposables.push(openFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
            }
          }));
          const pullTextDocuments = /* @__PURE__ */ new Set();
          for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
              pullTextDocuments.add(textDocument.uri.toString());
            }
          }
          if (diagnosticPullOptions.onTabs === true) {
            for (const resource of tabs.getTabResources()) {
              if (!pullTextDocuments.has(resource.toString()) && matches(resource)) {
                this.diagnosticRequestor.pull(resource, () => {
                  addToBackgroundIfNeeded(resource);
                });
              }
            }
          }
          if (diagnosticPullOptions.onChange === true) {
            const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
            disposables.push(changeFeature.onNotificationSent(async (event) => {
              const textDocument = event.original.document;
              if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument) && event.original.contentChanges.length > 0) {
                this.diagnosticRequestor.pull(textDocument, () => {
                  this.backgroundScheduler.trigger();
                });
              }
            }));
          }
          if (diagnosticPullOptions.onSave === true) {
            const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
            disposables.push(saveFeature.onNotificationSent((event) => {
              const textDocument = event.original;
              if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
                this.diagnosticRequestor.pull(event.original, () => {
                  this.backgroundScheduler.trigger();
                });
              }
            }));
          }
          const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
          disposables.push(closeFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            this.diagnosticRequestor.cleanupPull(textDocument);
            this.backgroundScheduler.remove(textDocument);
          }));
          this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
            for (const textDocument of vscode_1.workspace.textDocuments) {
              if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument);
              }
            }
          });
          if (options.workspaceDiagnostics === true && options.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
            this.diagnosticRequestor.pullWorkspace();
          }
          this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
        }
        get onDidChangeDiagnosticsEmitter() {
          return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
        }
        get diagnostics() {
          return this.diagnosticRequestor.provider;
        }
      };
      var DiagnosticFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
          capability.dynamicRegistration = true;
          capability.relatedDocumentSupport = false;
          ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeDiagnosticsEmitter.fire();
            }
          });
          let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        dispose() {
          if (this.tabs !== void 0) {
            this.tabs.dispose();
            this.tabs = void 0;
          }
          super.dispose();
        }
        registerLanguageProvider(options) {
          if (this.tabs === void 0) {
            this.tabs = new Tabs();
          }
          const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
          return [provider.disposable, provider];
        }
      };
      exports.DiagnosticFeature = DiagnosticFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/utils/async.js
  var require_async = __commonJS({
    "node_modules/vscode-languageclient/lib/common/utils/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.forEach = exports.mapAsync = exports.map = exports.Semaphore = exports.Delayer = void 0;
      var vscode_languageserver_protocol_1 = require_main8();
      var Delayer = class {
        constructor(defaultDelay) {
          this.defaultDelay = defaultDelay;
          this.timeout = void 0;
          this.completionPromise = void 0;
          this.onSuccess = void 0;
          this.task = void 0;
        }
        trigger(task, delay = this.defaultDelay) {
          this.task = task;
          if (delay >= 0) {
            this.cancelTimeout();
          }
          if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve) => {
              this.onSuccess = resolve;
            }).then(() => {
              this.completionPromise = void 0;
              this.onSuccess = void 0;
              var result = this.task();
              this.task = void 0;
              return result;
            });
          }
          if (delay >= 0 || this.timeout === void 0) {
            this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
              this.timeout = void 0;
              this.onSuccess(void 0);
            }, delay >= 0 ? delay : this.defaultDelay);
          }
          return this.completionPromise;
        }
        forceDelivery() {
          if (!this.completionPromise) {
            return void 0;
          }
          this.cancelTimeout();
          let result = this.task();
          this.completionPromise = void 0;
          this.onSuccess = void 0;
          this.task = void 0;
          return result;
        }
        isTriggered() {
          return this.timeout !== void 0;
        }
        cancel() {
          this.cancelTimeout();
          this.completionPromise = void 0;
        }
        cancelTimeout() {
          if (this.timeout !== void 0) {
            this.timeout.dispose();
            this.timeout = void 0;
          }
        }
      };
      exports.Delayer = Delayer;
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports.Semaphore = Semaphore;
      var defaultYieldTimeout = 15;
      var Timer = class {
        constructor(yieldAfter = defaultYieldTimeout) {
          this.yieldAfter = Math.max(yieldAfter, defaultYieldTimeout);
          this.startTime = Date.now();
          this.counter = 0;
          this.total = 0;
          this.counterInterval = 1;
        }
        start() {
          this.startTime = Date.now();
        }
        shouldYield() {
          if (++this.counter >= this.counterInterval) {
            const timeTaken = Date.now() - this.startTime;
            const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
            this.total += this.counter;
            this.counter = 0;
            if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
              this.counterInterval = 1;
              this.total = 0;
              return true;
            } else {
              switch (timeTaken) {
                case 0:
                case 1:
                  this.counterInterval = this.total * 2;
                  break;
              }
            }
          }
          return false;
        }
      };
      async function map(items, func, token, options) {
        if (items.length === 0) {
          return [];
        }
        const result = new Array(items.length);
        const timer = new Timer(options?.yieldAfter);
        function convertBatch(start) {
          timer.start();
          for (let i = start; i < items.length; i++) {
            result[i] = func(items[i]);
            if (timer.shouldYield()) {
              options?.yieldCallback && options.yieldCallback();
              return i + 1;
            }
          }
          return -1;
        }
        let index = convertBatch(0);
        while (index !== -1) {
          if (token !== void 0 && token.isCancellationRequested) {
            break;
          }
          index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
              resolve(convertBatch(index));
            });
          });
        }
        return result;
      }
      exports.map = map;
      async function mapAsync(items, func, token, options) {
        if (items.length === 0) {
          return [];
        }
        const result = new Array(items.length);
        const timer = new Timer(options?.yieldAfter);
        async function convertBatch(start) {
          timer.start();
          for (let i = start; i < items.length; i++) {
            result[i] = await func(items[i], token);
            if (timer.shouldYield()) {
              options?.yieldCallback && options.yieldCallback();
              return i + 1;
            }
          }
          return -1;
        }
        let index = await convertBatch(0);
        while (index !== -1) {
          if (token !== void 0 && token.isCancellationRequested) {
            break;
          }
          index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
              resolve(convertBatch(index));
            });
          });
        }
        return result;
      }
      exports.mapAsync = mapAsync;
      async function forEach(items, func, token, options) {
        if (items.length === 0) {
          return;
        }
        const timer = new Timer(options?.yieldAfter);
        function runBatch(start) {
          timer.start();
          for (let i = start; i < items.length; i++) {
            func(items[i]);
            if (timer.shouldYield()) {
              options?.yieldCallback && options.yieldCallback();
              return i + 1;
            }
          }
          return -1;
        }
        let index = runBatch(0);
        while (index !== -1) {
          if (token !== void 0 && token.isCancellationRequested) {
            break;
          }
          index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
              resolve(runBatch(index));
            });
          });
        }
      }
      exports.forEach = forEach;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js
  var require_protocolCompletionItem = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code = __require("vscode");
      var ProtocolCompletionItem = class extends code.CompletionItem {
        constructor(label) {
          super(label);
        }
      };
      exports.default = ProtocolCompletionItem;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolCodeLens.js
  var require_protocolCodeLens = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolCodeLens.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code = __require("vscode");
      var ProtocolCodeLens = class extends code.CodeLens {
        constructor(range) {
          super(range);
        }
      };
      exports.default = ProtocolCodeLens;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js
  var require_protocolDocumentLink = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code = __require("vscode");
      var ProtocolDocumentLink = class extends code.DocumentLink {
        constructor(range, target) {
          super(range, target);
        }
      };
      exports.default = ProtocolDocumentLink;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolCodeAction.js
  var require_protocolCodeAction = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolCodeAction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var vscode = __require("vscode");
      var ProtocolCodeAction = class extends vscode.CodeAction {
        constructor(title, data) {
          super(title);
          this.data = data;
        }
      };
      exports.default = ProtocolCodeAction;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js
  var require_protocolDiagnostic = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
      var vscode = __require("vscode");
      var Is2 = require_is7();
      var DiagnosticCode;
      (function(DiagnosticCode2) {
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && (Is2.number(candidate.value) || Is2.string(candidate.value)) && Is2.string(candidate.target);
        }
        DiagnosticCode2.is = is;
      })(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));
      var ProtocolDiagnostic = class extends vscode.Diagnostic {
        constructor(range, message, severity, data) {
          super(range, message, severity);
          this.data = data;
          this.hasDiagnosticCode = false;
        }
      };
      exports.ProtocolDiagnostic = ProtocolDiagnostic;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js
  var require_protocolCallHierarchyItem = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code = __require("vscode");
      var ProtocolCallHierarchyItem = class extends code.CallHierarchyItem {
        constructor(kind, name, detail, uri, range, selectionRange, data) {
          super(kind, name, detail, uri, range, selectionRange);
          if (data !== void 0) {
            this.data = data;
          }
        }
      };
      exports.default = ProtocolCallHierarchyItem;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js
  var require_protocolTypeHierarchyItem = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code = __require("vscode");
      var ProtocolTypeHierarchyItem = class extends code.TypeHierarchyItem {
        constructor(kind, name, detail, uri, range, selectionRange, data) {
          super(kind, name, detail, uri, range, selectionRange);
          if (data !== void 0) {
            this.data = data;
          }
        }
      };
      exports.default = ProtocolTypeHierarchyItem;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js
  var require_protocolWorkspaceSymbol = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code = __require("vscode");
      var WorkspaceSymbol2 = class extends code.SymbolInformation {
        constructor(name, kind, containerName, locationOrUri, data) {
          const hasRange = !(locationOrUri instanceof code.Uri);
          super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
          this.hasRange = hasRange;
          if (data !== void 0) {
            this.data = data;
          }
        }
      };
      exports.default = WorkspaceSymbol2;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolInlayHint.js
  var require_protocolInlayHint = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolInlayHint.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var code = __require("vscode");
      var ProtocolInlayHint = class extends code.InlayHint {
        constructor(position, label, kind) {
          super(position, label, kind);
        }
      };
      exports.default = ProtocolInlayHint;
    }
  });

  // node_modules/vscode-languageclient/lib/common/codeConverter.js
  var require_codeConverter = __commonJS({
    "node_modules/vscode-languageclient/lib/common/codeConverter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createConverter = void 0;
      var code = __require("vscode");
      var proto = require_main8();
      var Is2 = require_is7();
      var async = require_async();
      var protocolCompletionItem_1 = require_protocolCompletionItem();
      var protocolCodeLens_1 = require_protocolCodeLens();
      var protocolDocumentLink_1 = require_protocolDocumentLink();
      var protocolCodeAction_1 = require_protocolCodeAction();
      var protocolDiagnostic_1 = require_protocolDiagnostic();
      var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
      var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
      var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
      var protocolInlayHint_1 = require_protocolInlayHint();
      var InsertReplaceRange;
      (function(InsertReplaceRange2) {
        function is(value) {
          const candidate = value;
          return candidate && !!candidate.inserting && !!candidate.replacing;
        }
        InsertReplaceRange2.is = is;
      })(InsertReplaceRange || (InsertReplaceRange = {}));
      function createConverter(uriConverter) {
        const nullConverter = (value) => value.toString();
        const _uriConverter = uriConverter || nullConverter;
        function asUri(value) {
          return _uriConverter(value);
        }
        function asTextDocumentIdentifier(textDocument) {
          return {
            uri: _uriConverter(textDocument.uri)
          };
        }
        function asTextDocumentItem(textDocument) {
          return {
            uri: _uriConverter(textDocument.uri),
            languageId: textDocument.languageId,
            version: textDocument.version,
            text: textDocument.getText()
          };
        }
        function asVersionedTextDocumentIdentifier(textDocument) {
          return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
          };
        }
        function asOpenTextDocumentParams(textDocument) {
          return {
            textDocument: asTextDocumentItem(textDocument)
          };
        }
        function isTextDocumentChangeEvent(value) {
          let candidate = value;
          return !!candidate.document && !!candidate.contentChanges;
        }
        function isTextDocument(value) {
          let candidate = value;
          return !!candidate.uri && !!candidate.version;
        }
        function asChangeTextDocumentParams(arg) {
          if (isTextDocument(arg)) {
            let result = {
              textDocument: {
                uri: _uriConverter(arg.uri),
                version: arg.version
              },
              contentChanges: [{ text: arg.getText() }]
            };
            return result;
          } else if (isTextDocumentChangeEvent(arg)) {
            let document2 = arg.document;
            let result = {
              textDocument: {
                uri: _uriConverter(document2.uri),
                version: document2.version
              },
              contentChanges: arg.contentChanges.map((change) => {
                let range = change.range;
                return {
                  range: {
                    start: { line: range.start.line, character: range.start.character },
                    end: { line: range.end.line, character: range.end.character }
                  },
                  rangeLength: change.rangeLength,
                  text: change.text
                };
              })
            };
            return result;
          } else {
            throw Error("Unsupported text document change parameter");
          }
        }
        function asCloseTextDocumentParams(textDocument) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
        }
        function asSaveTextDocumentParams(textDocument, includeContent = false) {
          let result = {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
          if (includeContent) {
            result.text = textDocument.getText();
          }
          return result;
        }
        function asTextDocumentSaveReason(reason) {
          switch (reason) {
            case code.TextDocumentSaveReason.Manual:
              return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
              return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
              return proto.TextDocumentSaveReason.FocusOut;
          }
          return proto.TextDocumentSaveReason.Manual;
        }
        function asWillSaveTextDocumentParams(event) {
          return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
          };
        }
        function asDidCreateFilesParams(event) {
          return {
            files: event.files.map((fileUri) => ({
              uri: _uriConverter(fileUri)
            }))
          };
        }
        function asDidRenameFilesParams(event) {
          return {
            files: event.files.map((file) => ({
              oldUri: _uriConverter(file.oldUri),
              newUri: _uriConverter(file.newUri)
            }))
          };
        }
        function asDidDeleteFilesParams(event) {
          return {
            files: event.files.map((fileUri) => ({
              uri: _uriConverter(fileUri)
            }))
          };
        }
        function asWillCreateFilesParams(event) {
          return {
            files: event.files.map((fileUri) => ({
              uri: _uriConverter(fileUri)
            }))
          };
        }
        function asWillRenameFilesParams(event) {
          return {
            files: event.files.map((file) => ({
              oldUri: _uriConverter(file.oldUri),
              newUri: _uriConverter(file.newUri)
            }))
          };
        }
        function asWillDeleteFilesParams(event) {
          return {
            files: event.files.map((fileUri) => ({
              uri: _uriConverter(fileUri)
            }))
          };
        }
        function asTextDocumentPositionParams(textDocument, position) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
          };
        }
        function asCompletionTriggerKind(triggerKind) {
          switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
              return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
              return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
              return proto.CompletionTriggerKind.Invoked;
          }
        }
        function asCompletionParams(textDocument, position, context) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
              triggerKind: asCompletionTriggerKind(context.triggerKind),
              triggerCharacter: context.triggerCharacter
            }
          };
        }
        function asSignatureHelpTriggerKind(triggerKind) {
          switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
              return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
              return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
              return proto.SignatureHelpTriggerKind.ContentChange;
          }
        }
        function asParameterInformation(value) {
          return {
            label: value.label
          };
        }
        function asParameterInformations(values) {
          return values.map(asParameterInformation);
        }
        function asSignatureInformation(value) {
          return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
          };
        }
        function asSignatureInformations(values) {
          return values.map(asSignatureInformation);
        }
        function asSignatureHelp(value) {
          if (value === void 0) {
            return value;
          }
          return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
          };
        }
        function asSignatureHelpParams(textDocument, position, context) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
              isRetrigger: context.isRetrigger,
              triggerCharacter: context.triggerCharacter,
              triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
              activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
          };
        }
        function asWorkerPosition(position) {
          return { line: position.line, character: position.character };
        }
        function asPosition(value) {
          if (value === void 0 || value === null) {
            return value;
          }
          return { line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line, character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character };
        }
        function asPositions(value, token) {
          return async.map(value, asPosition, token);
        }
        function asRange(value) {
          if (value === void 0 || value === null) {
            return value;
          }
          return { start: asPosition(value.start), end: asPosition(value.end) };
        }
        function asLocation(value) {
          if (value === void 0 || value === null) {
            return value;
          }
          return proto.Location.create(asUri(value.uri), asRange(value.range));
        }
        function asDiagnosticSeverity(value) {
          switch (value) {
            case code.DiagnosticSeverity.Error:
              return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
              return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
              return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
              return proto.DiagnosticSeverity.Hint;
          }
        }
        function asDiagnosticTags(tags) {
          if (!tags) {
            return void 0;
          }
          let result = [];
          for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result.length > 0 ? result : void 0;
        }
        function asDiagnosticTag(tag) {
          switch (tag) {
            case code.DiagnosticTag.Unnecessary:
              return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
              return proto.DiagnosticTag.Deprecated;
            default:
              return void 0;
          }
        }
        function asRelatedInformation(item) {
          return {
            message: item.message,
            location: asLocation(item.location)
          };
        }
        function asRelatedInformations(items) {
          return items.map(asRelatedInformation);
        }
        function asDiagnosticCode(value) {
          if (value === void 0 || value === null) {
            return void 0;
          }
          if (Is2.number(value) || Is2.string(value)) {
            return value;
          }
          return { value: value.value, target: asUri(value.target) };
        }
        function asDiagnostic(item) {
          const result = proto.Diagnostic.create(asRange(item.range), item.message);
          const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : void 0;
          if (protocolDiagnostic !== void 0 && protocolDiagnostic.data !== void 0) {
            result.data = protocolDiagnostic.data;
          }
          const code2 = asDiagnosticCode(item.code);
          if (protocolDiagnostic_1.DiagnosticCode.is(code2)) {
            if (protocolDiagnostic !== void 0 && protocolDiagnostic.hasDiagnosticCode) {
              result.code = code2;
            } else {
              result.code = code2.value;
              result.codeDescription = { href: code2.target };
            }
          } else {
            result.code = code2;
          }
          if (Is2.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
          }
          if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
          }
          if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
          }
          if (item.source) {
            result.source = item.source;
          }
          return result;
        }
        function asDiagnostics(items, token) {
          if (items === void 0 || items === null) {
            return items;
          }
          return async.map(items, asDiagnostic, token);
        }
        function asDocumentation(format, documentation) {
          switch (format) {
            case "$string":
              return documentation;
            case proto.MarkupKind.PlainText:
              return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
              return { kind: format, value: documentation.value };
            default:
              return `Unsupported Markup content received. Kind is: ${format}`;
          }
        }
        function asCompletionItemTag(tag) {
          switch (tag) {
            case code.CompletionItemTag.Deprecated:
              return proto.CompletionItemTag.Deprecated;
          }
          return void 0;
        }
        function asCompletionItemTags(tags) {
          if (tags === void 0) {
            return tags;
          }
          const result = [];
          for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result;
        }
        function asCompletionItemKind(value, original) {
          if (original !== void 0) {
            return original;
          }
          return value + 1;
        }
        function asCompletionItem(item, labelDetailsSupport = false) {
          let label;
          let labelDetails;
          if (Is2.string(item.label)) {
            label = item.label;
          } else {
            label = item.label.label;
            if (labelDetailsSupport && (item.label.detail !== void 0 || item.label.description !== void 0)) {
              labelDetails = { detail: item.label.detail, description: item.label.description };
            }
          }
          let result = { label };
          if (labelDetails !== void 0) {
            result.labelDetails = labelDetails;
          }
          let protocolItem = item instanceof protocolCompletionItem_1.default ? item : void 0;
          if (item.detail) {
            result.detail = item.detail;
          }
          if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === "$string") {
              result.documentation = item.documentation;
            } else {
              result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
          }
          if (item.filterText) {
            result.filterText = item.filterText;
          }
          fillPrimaryInsertText(result, item);
          if (Is2.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
          }
          if (item.sortText) {
            result.sortText = item.sortText;
          }
          if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
          }
          if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
          }
          if (item.command) {
            result.command = asCommand(item.command);
          }
          if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
          }
          const tags = asCompletionItemTags(item.tags);
          if (protocolItem) {
            if (protocolItem.data !== void 0) {
              result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
              if (protocolItem.deprecated === true && tags !== void 0 && tags.length > 0) {
                const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                if (index !== -1) {
                  tags.splice(index, 1);
                }
              }
              result.deprecated = protocolItem.deprecated;
            }
            if (protocolItem.insertTextMode !== void 0) {
              result.insertTextMode = protocolItem.insertTextMode;
            }
          }
          if (tags !== void 0 && tags.length > 0) {
            result.tags = tags;
          }
          if (result.insertTextMode === void 0 && item.keepWhitespace === true) {
            result.insertTextMode = proto.InsertTextMode.adjustIndentation;
          }
          return result;
        }
        function fillPrimaryInsertText(target, source) {
          let format = proto.InsertTextFormat.PlainText;
          let text = void 0;
          let range = void 0;
          if (source.textEdit) {
            text = source.textEdit.newText;
            range = source.textEdit.range;
          } else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
          } else {
            text = source.insertText;
          }
          if (source.range) {
            range = source.range;
          }
          target.insertTextFormat = format;
          if (source.fromEdit && text !== void 0 && range !== void 0) {
            target.textEdit = asCompletionTextEdit(text, range);
          } else {
            target.insertText = text;
          }
        }
        function asCompletionTextEdit(newText, range) {
          if (InsertReplaceRange.is(range)) {
            return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
          } else {
            return { newText, range: asRange(range) };
          }
        }
        function asTextEdit(edit) {
          return { range: asRange(edit.range), newText: edit.newText };
        }
        function asTextEdits(edits) {
          if (edits === void 0 || edits === null) {
            return edits;
          }
          return edits.map(asTextEdit);
        }
        function asSymbolKind(item) {
          if (item <= code.SymbolKind.TypeParameter) {
            return item + 1;
          }
          return proto.SymbolKind.Property;
        }
        function asSymbolTag(item) {
          return item;
        }
        function asSymbolTags(items) {
          return items.map(asSymbolTag);
        }
        function asReferenceParams(textDocument, position, options) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
          };
        }
        async function asCodeAction(item, token) {
          let result = proto.CodeAction.create(item.title);
          if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
            result.data = item.data;
          }
          if (item.kind !== void 0) {
            result.kind = asCodeActionKind(item.kind);
          }
          if (item.diagnostics !== void 0) {
            result.diagnostics = await asDiagnostics(item.diagnostics, token);
          }
          if (item.edit !== void 0) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
          }
          if (item.command !== void 0) {
            result.command = asCommand(item.command);
          }
          if (item.isPreferred !== void 0) {
            result.isPreferred = item.isPreferred;
          }
          if (item.disabled !== void 0) {
            result.disabled = { reason: item.disabled.reason };
          }
          return result;
        }
        async function asCodeActionContext(context, token) {
          if (context === void 0 || context === null) {
            return context;
          }
          let only;
          if (context.only && Is2.string(context.only.value)) {
            only = [context.only.value];
          }
          return proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
        }
        function asCodeActionTriggerKind(kind) {
          switch (kind) {
            case code.CodeActionTriggerKind.Invoke:
              return proto.CodeActionTriggerKind.Invoked;
            case code.CodeActionTriggerKind.Automatic:
              return proto.CodeActionTriggerKind.Automatic;
            default:
              return void 0;
          }
        }
        function asCodeActionKind(item) {
          if (item === void 0 || item === null) {
            return void 0;
          }
          return item.value;
        }
        function asInlineValueContext(context) {
          if (context === void 0 || context === null) {
            return context;
          }
          return proto.InlineValueContext.create(context.frameId, asRange(context.stoppedLocation));
        }
        function asCommand(item) {
          let result = proto.Command.create(item.title, item.command);
          if (item.arguments) {
            result.arguments = item.arguments;
          }
          return result;
        }
        function asCodeLens(item) {
          let result = proto.CodeLens.create(asRange(item.range));
          if (item.command) {
            result.command = asCommand(item.command);
          }
          if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
              result.data = item.data;
            }
          }
          return result;
        }
        function asFormattingOptions(options, fileOptions) {
          const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
          if (fileOptions.trimTrailingWhitespace) {
            result.trimTrailingWhitespace = true;
          }
          if (fileOptions.trimFinalNewlines) {
            result.trimFinalNewlines = true;
          }
          if (fileOptions.insertFinalNewline) {
            result.insertFinalNewline = true;
          }
          return result;
        }
        function asDocumentSymbolParams(textDocument) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
        }
        function asCodeLensParams(textDocument) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
        }
        function asDocumentLink(item) {
          let result = proto.DocumentLink.create(asRange(item.range));
          if (item.target) {
            result.target = asUri(item.target);
          }
          if (item.tooltip !== void 0) {
            result.tooltip = item.tooltip;
          }
          let protocolItem = item instanceof protocolDocumentLink_1.default ? item : void 0;
          if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
          }
          return result;
        }
        function asDocumentLinkParams(textDocument) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
        }
        function asCallHierarchyItem(value) {
          const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
          };
          if (value.detail !== void 0 && value.detail.length > 0) {
            result.detail = value.detail;
          }
          if (value.tags !== void 0) {
            result.tags = asSymbolTags(value.tags);
          }
          if (value instanceof protocolCallHierarchyItem_1.default && value.data !== void 0) {
            result.data = value.data;
          }
          return result;
        }
        function asTypeHierarchyItem(value) {
          const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
          };
          if (value.detail !== void 0 && value.detail.length > 0) {
            result.detail = value.detail;
          }
          if (value.tags !== void 0) {
            result.tags = asSymbolTags(value.tags);
          }
          if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== void 0) {
            result.data = value.data;
          }
          return result;
        }
        function asWorkspaceSymbol(item) {
          const result = item instanceof protocolWorkspaceSymbol_1.default ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data } : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
          if (item.tags !== void 0) {
            result.tags = asSymbolTags(item.tags);
          }
          if (item.containerName !== "") {
            result.containerName = item.containerName;
          }
          return result;
        }
        function asInlayHint(item) {
          const label = typeof item.label === "string" ? item.label : item.label.map(asInlayHintLabelPart);
          const result = proto.InlayHint.create(asPosition(item.position), label);
          if (item.kind !== void 0) {
            result.kind = item.kind;
          }
          if (item.textEdits !== void 0) {
            result.textEdits = asTextEdits(item.textEdits);
          }
          if (item.tooltip !== void 0) {
            result.tooltip = asTooltip(item.tooltip);
          }
          if (item.paddingLeft !== void 0) {
            result.paddingLeft = item.paddingLeft;
          }
          if (item.paddingRight !== void 0) {
            result.paddingRight = item.paddingRight;
          }
          if (item instanceof protocolInlayHint_1.default && item.data !== void 0) {
            result.data = item.data;
          }
          return result;
        }
        function asInlayHintLabelPart(item) {
          const result = proto.InlayHintLabelPart.create(item.value);
          if (item.location !== void 0) {
            result.location = asLocation(item.location);
          }
          if (item.command !== void 0) {
            result.command = asCommand(item.command);
          }
          if (item.tooltip !== void 0) {
            result.tooltip = asTooltip(item.tooltip);
          }
          return result;
        }
        function asTooltip(value) {
          if (typeof value === "string") {
            return value;
          }
          const result = {
            kind: proto.MarkupKind.Markdown,
            value: value.value
          };
          return result;
        }
        return {
          asUri,
          asTextDocumentIdentifier,
          asTextDocumentItem,
          asVersionedTextDocumentIdentifier,
          asOpenTextDocumentParams,
          asChangeTextDocumentParams,
          asCloseTextDocumentParams,
          asSaveTextDocumentParams,
          asWillSaveTextDocumentParams,
          asDidCreateFilesParams,
          asDidRenameFilesParams,
          asDidDeleteFilesParams,
          asWillCreateFilesParams,
          asWillRenameFilesParams,
          asWillDeleteFilesParams,
          asTextDocumentPositionParams,
          asCompletionParams,
          asSignatureHelpParams,
          asWorkerPosition,
          asRange,
          asPosition,
          asPositions,
          asLocation,
          asDiagnosticSeverity,
          asDiagnosticTag,
          asDiagnostic,
          asDiagnostics,
          asCompletionItem,
          asTextEdit,
          asSymbolKind,
          asSymbolTag,
          asSymbolTags,
          asReferenceParams,
          asCodeAction,
          asCodeActionContext,
          asInlineValueContext,
          asCommand,
          asCodeLens,
          asFormattingOptions,
          asDocumentSymbolParams,
          asCodeLensParams,
          asDocumentLink,
          asDocumentLinkParams,
          asCallHierarchyItem,
          asTypeHierarchyItem,
          asInlayHint,
          asWorkspaceSymbol
        };
      }
      exports.createConverter = createConverter;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolConverter.js
  var require_protocolConverter = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolConverter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createConverter = void 0;
      var code = __require("vscode");
      var ls = require_main8();
      var Is2 = require_is7();
      var async = require_async();
      var protocolCompletionItem_1 = require_protocolCompletionItem();
      var protocolCodeLens_1 = require_protocolCodeLens();
      var protocolDocumentLink_1 = require_protocolDocumentLink();
      var protocolCodeAction_1 = require_protocolCodeAction();
      var protocolDiagnostic_1 = require_protocolDiagnostic();
      var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
      var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
      var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
      var protocolInlayHint_1 = require_protocolInlayHint();
      var vscode_languageserver_protocol_1 = require_main8();
      var CodeBlock;
      (function(CodeBlock2) {
        function is(value) {
          let candidate = value;
          return candidate && Is2.string(candidate.language) && Is2.string(candidate.value);
        }
        CodeBlock2.is = is;
      })(CodeBlock || (CodeBlock = {}));
      function createConverter(uriConverter, trustMarkdown, supportHtml) {
        const nullConverter = (value) => code.Uri.parse(value);
        const _uriConverter = uriConverter || nullConverter;
        function asUri(value) {
          return _uriConverter(value);
        }
        function asDocumentSelector(selector) {
          const result = [];
          for (const filter of selector) {
            if (typeof filter === "string") {
              result.push(filter);
            } else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
              if (typeof filter.notebook === "string") {
                result.push({ notebookType: filter.notebook, language: filter.language });
              } else {
                const notebookType = filter.notebook.notebookType ?? "*";
                result.push({ notebookType, scheme: filter.notebook.scheme, pattern: filter.notebook.pattern, language: filter.language });
              }
            } else if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
              result.push({ language: filter.language, scheme: filter.scheme, pattern: filter.pattern });
            }
          }
          return result;
        }
        async function asDiagnostics(diagnostics, token) {
          return async.map(diagnostics, asDiagnostic, token);
        }
        function asDiagnosticsSync(diagnostics) {
          const result = new Array(diagnostics.length);
          for (let i = 0; i < diagnostics.length; i++) {
            result[i] = asDiagnostic(diagnostics[i]);
          }
          return result;
        }
        function asDiagnostic(diagnostic) {
          let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
          if (diagnostic.code !== void 0) {
            if (typeof diagnostic.code === "string" || typeof diagnostic.code === "number") {
              if (ls.CodeDescription.is(diagnostic.codeDescription)) {
                result.code = {
                  value: diagnostic.code,
                  target: asUri(diagnostic.codeDescription.href)
                };
              } else {
                result.code = diagnostic.code;
              }
            } else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
              result.hasDiagnosticCode = true;
              const diagnosticCode = diagnostic.code;
              result.code = {
                value: diagnosticCode.value,
                target: asUri(diagnosticCode.target)
              };
            }
          }
          if (diagnostic.source) {
            result.source = diagnostic.source;
          }
          if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
          }
          if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
          }
          return result;
        }
        function asRelatedInformation(relatedInformation) {
          const result = new Array(relatedInformation.length);
          for (let i = 0; i < relatedInformation.length; i++) {
            const info = relatedInformation[i];
            result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
          }
          return result;
        }
        function asDiagnosticTags(tags) {
          if (!tags) {
            return void 0;
          }
          let result = [];
          for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result.length > 0 ? result : void 0;
        }
        function asDiagnosticTag(tag) {
          switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
              return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
              return code.DiagnosticTag.Deprecated;
            default:
              return void 0;
          }
        }
        function asPosition(value) {
          return value ? new code.Position(value.line, value.character) : void 0;
        }
        function asRange(value) {
          return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : void 0;
        }
        async function asRanges(items, token) {
          return async.map(items, (range) => {
            return new code.Range(range.start.line, range.start.character, range.end.line, range.end.character);
          }, token);
        }
        function asDiagnosticSeverity(value) {
          if (value === void 0 || value === null) {
            return code.DiagnosticSeverity.Error;
          }
          switch (value) {
            case ls.DiagnosticSeverity.Error:
              return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
              return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
              return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
              return code.DiagnosticSeverity.Hint;
          }
          return code.DiagnosticSeverity.Error;
        }
        function asHoverContent(value) {
          if (Is2.string(value)) {
            return asMarkdownString(value);
          } else if (CodeBlock.is(value)) {
            let result = asMarkdownString();
            return result.appendCodeblock(value.value, value.language);
          } else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
              let item = asMarkdownString();
              if (CodeBlock.is(element)) {
                item.appendCodeblock(element.value, element.language);
              } else {
                item.appendMarkdown(element);
              }
              result.push(item);
            }
            return result;
          } else {
            return asMarkdownString(value);
          }
        }
        function asDocumentation(value) {
          if (Is2.string(value)) {
            return value;
          } else {
            switch (value.kind) {
              case ls.MarkupKind.Markdown:
                return asMarkdownString(value.value);
              case ls.MarkupKind.PlainText:
                return value.value;
              default:
                return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
          }
        }
        function asMarkdownString(value) {
          let result;
          if (value === void 0 || typeof value === "string") {
            result = new code.MarkdownString(value);
          } else {
            switch (value.kind) {
              case ls.MarkupKind.Markdown:
                result = new code.MarkdownString(value.value);
                break;
              case ls.MarkupKind.PlainText:
                result = new code.MarkdownString();
                result.appendText(value.value);
                break;
              default:
                result = new code.MarkdownString();
                result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                break;
            }
          }
          result.isTrusted = trustMarkdown;
          result.supportHtml = supportHtml;
          return result;
        }
        function asHover(hover) {
          if (!hover) {
            return void 0;
          }
          return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
        }
        async function asCompletionResult(value, allCommitCharacters, token) {
          if (!value) {
            return void 0;
          }
          if (Array.isArray(value)) {
            return async.map(value, (item) => asCompletionItem(item, allCommitCharacters), token);
          }
          const list = value;
          const { defaultRange, commitCharacters } = getCompletionItemDefaults(list, allCommitCharacters);
          const converted = await async.map(list.items, (item) => {
            return asCompletionItem(item, commitCharacters, defaultRange, list.itemDefaults?.insertTextMode, list.itemDefaults?.insertTextFormat, list.itemDefaults?.data);
          }, token);
          return new code.CompletionList(converted, list.isIncomplete);
        }
        function getCompletionItemDefaults(list, allCommitCharacters) {
          const rangeDefaults = list.itemDefaults?.editRange;
          const commitCharacters = list.itemDefaults?.commitCharacters ?? allCommitCharacters;
          return ls.Range.is(rangeDefaults) ? { defaultRange: asRange(rangeDefaults), commitCharacters } : rangeDefaults !== void 0 ? { defaultRange: { inserting: asRange(rangeDefaults.insert), replacing: asRange(rangeDefaults.replace) }, commitCharacters } : { defaultRange: void 0, commitCharacters };
        }
        function asCompletionItemKind(value) {
          if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, void 0];
          }
          return [code.CompletionItemKind.Text, value];
        }
        function asCompletionItemTag(tag) {
          switch (tag) {
            case ls.CompletionItemTag.Deprecated:
              return code.CompletionItemTag.Deprecated;
          }
          return void 0;
        }
        function asCompletionItemTags(tags) {
          if (tags === void 0 || tags === null) {
            return [];
          }
          const result = [];
          for (const tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result;
        }
        function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
          const tags = asCompletionItemTags(item.tags);
          const label = asCompletionItemLabel(item);
          const result = new protocolCompletionItem_1.default(label);
          if (item.detail) {
            result.detail = item.detail;
          }
          if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is2.string(item.documentation) ? "$string" : item.documentation.kind;
          }
          if (item.filterText) {
            result.filterText = item.filterText;
          }
          const insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
          if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
          }
          if (Is2.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
              result.originalItemKind = original;
            }
          }
          if (item.sortText) {
            result.sortText = item.sortText;
          }
          if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits);
          }
          const commitCharacters = item.commitCharacters !== void 0 ? Is2.stringArray(item.commitCharacters) ? item.commitCharacters : void 0 : defaultCommitCharacters;
          if (commitCharacters) {
            result.commitCharacters = commitCharacters.slice();
          }
          if (item.command) {
            result.command = asCommand(item.command);
          }
          if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
              tags.push(code.CompletionItemTag.Deprecated);
            }
          }
          if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
          }
          const data = item.data ?? defaultData;
          if (data !== void 0) {
            result.data = data;
          }
          if (tags.length > 0) {
            result.tags = tags;
          }
          const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
          if (insertTextMode !== void 0) {
            result.insertTextMode = insertTextMode;
            if (insertTextMode === ls.InsertTextMode.asIs) {
              result.keepWhitespace = true;
            }
          }
          return result;
        }
        function asCompletionItemLabel(item) {
          if (ls.CompletionItemLabelDetails.is(item.labelDetails)) {
            return {
              label: item.label,
              detail: item.labelDetails.detail,
              description: item.labelDetails.description
            };
          } else {
            return item.label;
          }
        }
        function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
          const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
          if (item.textEdit !== void 0 || defaultRange !== void 0) {
            const [range, newText] = item.textEdit !== void 0 ? getCompletionRangeAndText(item.textEdit) : [defaultRange, item.textEditText ?? item.label];
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
              return { text: new code.SnippetString(newText), range, fromEdit: true };
            } else {
              return { text: newText, range, fromEdit: true };
            }
          } else if (item.insertText) {
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
              return { text: new code.SnippetString(item.insertText), fromEdit: false };
            } else {
              return { text: item.insertText, fromEdit: false };
            }
          } else {
            return void 0;
          }
        }
        function getCompletionRangeAndText(value) {
          if (ls.InsertReplaceEdit.is(value)) {
            return [{ inserting: asRange(value.insert), replacing: asRange(value.replace) }, value.newText];
          } else {
            return [asRange(value.range), value.newText];
          }
        }
        function asTextEdit(edit) {
          if (!edit) {
            return void 0;
          }
          return new code.TextEdit(asRange(edit.range), edit.newText);
        }
        async function asTextEdits(items, token) {
          if (!items) {
            return void 0;
          }
          return async.map(items, asTextEdit, token);
        }
        function asTextEditsSync(items) {
          if (!items) {
            return void 0;
          }
          const result = new Array(items.length);
          for (let i = 0; i < items.length; i++) {
            result[i] = asTextEdit(items[i]);
          }
          return result;
        }
        async function asSignatureHelp(item, token) {
          if (!item) {
            return void 0;
          }
          let result = new code.SignatureHelp();
          if (Is2.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
          } else {
            result.activeSignature = 0;
          }
          if (Is2.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
          } else {
            result.activeParameter = 0;
          }
          if (item.signatures) {
            result.signatures = await asSignatureInformations(item.signatures, token);
          }
          return result;
        }
        async function asSignatureInformations(items, token) {
          return async.mapAsync(items, asSignatureInformation, token);
        }
        async function asSignatureInformation(item, token) {
          let result = new code.SignatureInformation(item.label);
          if (item.documentation !== void 0) {
            result.documentation = asDocumentation(item.documentation);
          }
          if (item.parameters !== void 0) {
            result.parameters = await asParameterInformations(item.parameters, token);
          }
          if (item.activeParameter !== void 0) {
            result.activeParameter = item.activeParameter;
          }
          {
            return result;
          }
        }
        function asParameterInformations(items, token) {
          return async.map(items, asParameterInformation, token);
        }
        function asParameterInformation(item) {
          let result = new code.ParameterInformation(item.label);
          if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
          }
          return result;
        }
        function asLocation(item) {
          return item ? new code.Location(_uriConverter(item.uri), asRange(item.range)) : void 0;
        }
        async function asDeclarationResult(item, token) {
          if (!item) {
            return void 0;
          }
          return asLocationResult(item, token);
        }
        async function asDefinitionResult(item, token) {
          if (!item) {
            return void 0;
          }
          return asLocationResult(item, token);
        }
        function asLocationLink(item) {
          if (!item) {
            return void 0;
          }
          let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
          };
          if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
          }
          return result;
        }
        async function asLocationResult(item, token) {
          if (!item) {
            return void 0;
          }
          if (Is2.array(item)) {
            if (item.length === 0) {
              return [];
            } else if (ls.LocationLink.is(item[0])) {
              const links = item;
              return async.map(links, asLocationLink, token);
            } else {
              const locations = item;
              return async.map(locations, asLocation, token);
            }
          } else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
          } else {
            return asLocation(item);
          }
        }
        async function asReferences(values, token) {
          if (!values) {
            return void 0;
          }
          return async.map(values, asLocation, token);
        }
        async function asDocumentHighlights(values, token) {
          if (!values) {
            return void 0;
          }
          return async.map(values, asDocumentHighlight, token);
        }
        function asDocumentHighlight(item) {
          let result = new code.DocumentHighlight(asRange(item.range));
          if (Is2.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
          }
          return result;
        }
        function asDocumentHighlightKind(item) {
          switch (item) {
            case ls.DocumentHighlightKind.Text:
              return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
              return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
              return code.DocumentHighlightKind.Write;
          }
          return code.DocumentHighlightKind.Text;
        }
        async function asSymbolInformations(values, token) {
          if (!values) {
            return void 0;
          }
          return async.map(values, asSymbolInformation, token);
        }
        function asSymbolKind(item) {
          if (item <= ls.SymbolKind.TypeParameter) {
            return item - 1;
          }
          return code.SymbolKind.Property;
        }
        function asSymbolTag(value) {
          switch (value) {
            case ls.SymbolTag.Deprecated:
              return code.SymbolTag.Deprecated;
            default:
              return void 0;
          }
        }
        function asSymbolTags(items) {
          if (items === void 0 || items === null) {
            return void 0;
          }
          const result = [];
          for (const item of items) {
            const converted = asSymbolTag(item);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result.length === 0 ? void 0 : result;
        }
        function asSymbolInformation(item) {
          const data = item.data;
          const location = item.location;
          const result = location.range === void 0 || data !== void 0 ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? "", location.range === void 0 ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data) : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? "", new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
          fillTags(result, item);
          return result;
        }
        async function asDocumentSymbols(values, token) {
          if (values === void 0 || values === null) {
            return void 0;
          }
          return async.map(values, asDocumentSymbol, token);
        }
        function asDocumentSymbol(value) {
          let result = new code.DocumentSymbol(value.name, value.detail || "", asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
          fillTags(result, value);
          if (value.children !== void 0 && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
              children.push(asDocumentSymbol(child));
            }
            result.children = children;
          }
          return result;
        }
        function fillTags(result, value) {
          result.tags = asSymbolTags(value.tags);
          if (value.deprecated) {
            if (!result.tags) {
              result.tags = [code.SymbolTag.Deprecated];
            } else {
              if (!result.tags.includes(code.SymbolTag.Deprecated)) {
                result.tags = result.tags.concat(code.SymbolTag.Deprecated);
              }
            }
          }
        }
        function asCommand(item) {
          let result = { title: item.title, command: item.command };
          if (item.arguments) {
            result.arguments = item.arguments;
          }
          return result;
        }
        async function asCommands(items, token) {
          if (!items) {
            return void 0;
          }
          return async.map(items, asCommand, token);
        }
        const kindMapping = /* @__PURE__ */ new Map();
        kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
        kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
        kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
        kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
        kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
        kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
        kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
        kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
        function asCodeActionKind(item) {
          if (item === void 0 || item === null) {
            return void 0;
          }
          let result = kindMapping.get(item);
          if (result) {
            return result;
          }
          let parts = item.split(".");
          result = code.CodeActionKind.Empty;
          for (let part of parts) {
            result = result.append(part);
          }
          return result;
        }
        function asCodeActionKinds(items) {
          if (items === void 0 || items === null) {
            return void 0;
          }
          return items.map((kind) => asCodeActionKind(kind));
        }
        async function asCodeAction(item, token) {
          if (item === void 0 || item === null) {
            return void 0;
          }
          let result = new protocolCodeAction_1.default(item.title, item.data);
          if (item.kind !== void 0) {
            result.kind = asCodeActionKind(item.kind);
          }
          if (item.diagnostics !== void 0) {
            result.diagnostics = asDiagnosticsSync(item.diagnostics);
          }
          if (item.edit !== void 0) {
            result.edit = await asWorkspaceEdit(item.edit, token);
          }
          if (item.command !== void 0) {
            result.command = asCommand(item.command);
          }
          if (item.isPreferred !== void 0) {
            result.isPreferred = item.isPreferred;
          }
          if (item.disabled !== void 0) {
            result.disabled = { reason: item.disabled.reason };
          }
          return result;
        }
        function asCodeActionResult(items, token) {
          return async.mapAsync(items, async (item) => {
            if (ls.Command.is(item)) {
              return asCommand(item);
            } else {
              return asCodeAction(item, token);
            }
          }, token);
        }
        function asCodeLens(item) {
          if (!item) {
            return void 0;
          }
          let result = new protocolCodeLens_1.default(asRange(item.range));
          if (item.command) {
            result.command = asCommand(item.command);
          }
          if (item.data !== void 0 && item.data !== null) {
            result.data = item.data;
          }
          return result;
        }
        async function asCodeLenses(items, token) {
          if (!items) {
            return void 0;
          }
          return async.map(items, asCodeLens, token);
        }
        async function asWorkspaceEdit(item, token) {
          if (!item) {
            return void 0;
          }
          const sharedMetadata = /* @__PURE__ */ new Map();
          if (item.changeAnnotations !== void 0) {
            const changeAnnotations = item.changeAnnotations;
            await async.forEach(Object.keys(changeAnnotations), (key) => {
              const metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
              sharedMetadata.set(key, metaData);
            }, token);
          }
          const asMetadata = (annotation) => {
            if (annotation === void 0) {
              return void 0;
            } else {
              return sharedMetadata.get(annotation);
            }
          };
          const result = new code.WorkspaceEdit();
          if (item.documentChanges) {
            const documentChanges = item.documentChanges;
            await async.forEach(documentChanges, (change) => {
              if (ls.CreateFile.is(change)) {
                result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
              } else if (ls.RenameFile.is(change)) {
                result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
              } else if (ls.DeleteFile.is(change)) {
                result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
              } else if (ls.TextDocumentEdit.is(change)) {
                const uri = _uriConverter(change.textDocument.uri);
                for (const edit of change.edits) {
                  if (ls.AnnotatedTextEdit.is(edit)) {
                    result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                  } else {
                    result.replace(uri, asRange(edit.range), edit.newText);
                  }
                }
              } else {
                throw new Error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
              }
            }, token);
          } else if (item.changes) {
            const changes = item.changes;
            await async.forEach(Object.keys(changes), (key) => {
              result.set(_uriConverter(key), asTextEditsSync(changes[key]));
            }, token);
          }
          return result;
        }
        function asWorkspaceEditEntryMetadata(annotation) {
          if (annotation === void 0) {
            return void 0;
          }
          return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
        }
        function asDocumentLink(item) {
          let range = asRange(item.range);
          let target = item.target ? asUri(item.target) : void 0;
          let link = new protocolDocumentLink_1.default(range, target);
          if (item.tooltip !== void 0) {
            link.tooltip = item.tooltip;
          }
          if (item.data !== void 0 && item.data !== null) {
            link.data = item.data;
          }
          return link;
        }
        async function asDocumentLinks(items, token) {
          if (!items) {
            return void 0;
          }
          return async.map(items, asDocumentLink, token);
        }
        function asColor(color) {
          return new code.Color(color.red, color.green, color.blue, color.alpha);
        }
        function asColorInformation(ci) {
          return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
        }
        async function asColorInformations(colorInformation, token) {
          if (!colorInformation) {
            return void 0;
          }
          return async.map(colorInformation, asColorInformation, token);
        }
        function asColorPresentation(cp) {
          let presentation = new code.ColorPresentation(cp.label);
          presentation.additionalTextEdits = asTextEditsSync(cp.additionalTextEdits);
          if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
          }
          return presentation;
        }
        async function asColorPresentations(colorPresentations, token) {
          if (!colorPresentations) {
            return void 0;
          }
          return async.map(colorPresentations, asColorPresentation, token);
        }
        function asFoldingRangeKind(kind) {
          if (kind) {
            switch (kind) {
              case ls.FoldingRangeKind.Comment:
                return code.FoldingRangeKind.Comment;
              case ls.FoldingRangeKind.Imports:
                return code.FoldingRangeKind.Imports;
              case ls.FoldingRangeKind.Region:
                return code.FoldingRangeKind.Region;
            }
          }
          return void 0;
        }
        function asFoldingRange(r) {
          return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
        }
        async function asFoldingRanges(foldingRanges, token) {
          if (!foldingRanges) {
            return void 0;
          }
          return async.map(foldingRanges, asFoldingRange, token);
        }
        function asSelectionRange(selectionRange) {
          return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : void 0);
        }
        async function asSelectionRanges(selectionRanges, token) {
          if (!Array.isArray(selectionRanges)) {
            return [];
          }
          return async.map(selectionRanges, asSelectionRange, token);
        }
        function asInlineValue(inlineValue) {
          if (ls.InlineValueText.is(inlineValue)) {
            return new code.InlineValueText(asRange(inlineValue.range), inlineValue.text);
          } else if (ls.InlineValueVariableLookup.is(inlineValue)) {
            return new code.InlineValueVariableLookup(asRange(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup);
          } else {
            return new code.InlineValueEvaluatableExpression(asRange(inlineValue.range), inlineValue.expression);
          }
        }
        async function asInlineValues(inlineValues, token) {
          if (!Array.isArray(inlineValues)) {
            return [];
          }
          return async.map(inlineValues, asInlineValue, token);
        }
        async function asInlayHint(value, token) {
          const label = typeof value.label === "string" ? value.label : await async.map(value.label, asInlayHintLabelPart, token);
          const result = new protocolInlayHint_1.default(asPosition(value.position), label);
          if (value.kind !== void 0) {
            result.kind = value.kind;
          }
          if (value.textEdits !== void 0) {
            result.textEdits = await asTextEdits(value.textEdits, token);
          }
          if (value.tooltip !== void 0) {
            result.tooltip = asTooltip(value.tooltip);
          }
          if (value.paddingLeft !== void 0) {
            result.paddingLeft = value.paddingLeft;
          }
          if (value.paddingRight !== void 0) {
            result.paddingRight = value.paddingRight;
          }
          if (value.data !== void 0) {
            result.data = value.data;
          }
          return result;
        }
        function asInlayHintLabelPart(part) {
          const result = new code.InlayHintLabelPart(part.value);
          if (part.location !== void 0) {
            result.location = asLocation(part.location);
          }
          if (part.tooltip !== void 0) {
            result.tooltip = asTooltip(part.tooltip);
          }
          if (part.command !== void 0) {
            result.command = asCommand(part.command);
          }
          return result;
        }
        function asTooltip(value) {
          if (typeof value === "string") {
            return value;
          }
          return asMarkdownString(value);
        }
        async function asInlayHints(values, token) {
          if (!Array.isArray(values)) {
            return void 0;
          }
          return async.mapAsync(values, asInlayHint, token);
        }
        function asCallHierarchyItem(item) {
          if (item === null) {
            return void 0;
          }
          const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
          if (item.tags !== void 0) {
            result.tags = asSymbolTags(item.tags);
          }
          return result;
        }
        async function asCallHierarchyItems(items, token) {
          if (items === null) {
            return void 0;
          }
          return async.map(items, asCallHierarchyItem, token);
        }
        async function asCallHierarchyIncomingCall(item, token) {
          return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
        }
        async function asCallHierarchyIncomingCalls(items, token) {
          if (items === null) {
            return void 0;
          }
          return async.mapAsync(items, asCallHierarchyIncomingCall, token);
        }
        async function asCallHierarchyOutgoingCall(item, token) {
          return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
        }
        async function asCallHierarchyOutgoingCalls(items, token) {
          if (items === null) {
            return void 0;
          }
          return async.mapAsync(items, asCallHierarchyOutgoingCall, token);
        }
        async function asSemanticTokens(value, _token) {
          if (value === void 0 || value === null) {
            return void 0;
          }
          return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
        }
        function asSemanticTokensEdit(value) {
          return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== void 0 ? new Uint32Array(value.data) : void 0);
        }
        async function asSemanticTokensEdits(value, _token) {
          if (value === void 0 || value === null) {
            return void 0;
          }
          return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
        }
        function asSemanticTokensLegend(value) {
          return value;
        }
        async function asLinkedEditingRanges(value, token) {
          if (value === null || value === void 0) {
            return void 0;
          }
          return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
        }
        function asRegularExpression(value) {
          if (value === null || value === void 0) {
            return void 0;
          }
          return new RegExp(value);
        }
        function asTypeHierarchyItem(item) {
          if (item === null) {
            return void 0;
          }
          let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
          if (item.tags !== void 0) {
            result.tags = asSymbolTags(item.tags);
          }
          return result;
        }
        async function asTypeHierarchyItems(items, token) {
          if (items === null) {
            return void 0;
          }
          return async.map(items, asTypeHierarchyItem, token);
        }
        function asGlobPattern(pattern) {
          if (Is2.string(pattern)) {
            return pattern;
          }
          if (ls.RelativePattern.is(pattern)) {
            if (ls.URI.is(pattern.baseUri)) {
              return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
            } else if (ls.WorkspaceFolder.is(pattern.baseUri)) {
              const workspaceFolder = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
              return workspaceFolder !== void 0 ? new code.RelativePattern(workspaceFolder, pattern.pattern) : void 0;
            }
          }
          return void 0;
        }
        return {
          asUri,
          asDocumentSelector,
          asDiagnostics,
          asDiagnostic,
          asRange,
          asRanges,
          asPosition,
          asDiagnosticSeverity,
          asDiagnosticTag,
          asHover,
          asCompletionResult,
          asCompletionItem,
          asTextEdit,
          asTextEdits,
          asSignatureHelp,
          asSignatureInformations,
          asSignatureInformation,
          asParameterInformations,
          asParameterInformation,
          asDeclarationResult,
          asDefinitionResult,
          asLocation,
          asReferences,
          asDocumentHighlights,
          asDocumentHighlight,
          asDocumentHighlightKind,
          asSymbolKind,
          asSymbolTag,
          asSymbolTags,
          asSymbolInformations,
          asSymbolInformation,
          asDocumentSymbols,
          asDocumentSymbol,
          asCommand,
          asCommands,
          asCodeAction,
          asCodeActionKind,
          asCodeActionKinds,
          asCodeActionResult,
          asCodeLens,
          asCodeLenses,
          asWorkspaceEdit,
          asDocumentLink,
          asDocumentLinks,
          asFoldingRangeKind,
          asFoldingRange,
          asFoldingRanges,
          asColor,
          asColorInformation,
          asColorInformations,
          asColorPresentation,
          asColorPresentations,
          asSelectionRange,
          asSelectionRanges,
          asInlineValue,
          asInlineValues,
          asInlayHint,
          asInlayHints,
          asSemanticTokensLegend,
          asSemanticTokens,
          asSemanticTokensEdit,
          asSemanticTokensEdits,
          asCallHierarchyItem,
          asCallHierarchyItems,
          asCallHierarchyIncomingCall,
          asCallHierarchyIncomingCalls,
          asCallHierarchyOutgoingCall,
          asCallHierarchyOutgoingCalls,
          asLinkedEditingRanges,
          asTypeHierarchyItem,
          asTypeHierarchyItems,
          asGlobPattern
        };
      }
      exports.createConverter = createConverter;
    }
  });

  // node_modules/vscode-languageclient/lib/common/progressPart.js
  var require_progressPart = __commonJS({
    "node_modules/vscode-languageclient/lib/common/progressPart.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProgressPart = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var Is2 = require_is7();
      var ProgressPart = class {
        constructor(_client, _token, done) {
          this._client = _client;
          this._token = _token;
          this._reported = 0;
          this._infinite = false;
          this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
            switch (value.kind) {
              case "begin":
                this.begin(value);
                break;
              case "report":
                this.report(value);
                break;
              case "end":
                this.done();
                done && done(this);
                break;
            }
          });
        }
        begin(params) {
          this._infinite = params.percentage === void 0;
          if (this._lspProgressDisposable === void 0) {
            return;
          }
          void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
            if (this._lspProgressDisposable === void 0) {
              return;
            }
            this._progress = progress;
            this._cancellationToken = cancellationToken;
            this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
              this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
            });
            this.report(params);
            return new Promise((resolve, reject) => {
              this._resolve = resolve;
              this._reject = reject;
            });
          });
        }
        report(params) {
          if (this._infinite && Is2.string(params.message)) {
            this._progress !== void 0 && this._progress.report({ message: params.message });
          } else if (Is2.number(params.percentage)) {
            const percentage = Math.max(0, Math.min(params.percentage, 100));
            const delta = Math.max(0, percentage - this._reported);
            this._reported += delta;
            this._progress !== void 0 && this._progress.report({ message: params.message, increment: delta });
          }
        }
        cancel() {
          this.cleanup();
          if (this._reject !== void 0) {
            this._reject();
            this._resolve = void 0;
            this._reject = void 0;
          }
        }
        done() {
          this.cleanup();
          if (this._resolve !== void 0) {
            this._resolve();
            this._resolve = void 0;
            this._reject = void 0;
          }
        }
        cleanup() {
          if (this._lspProgressDisposable !== void 0) {
            this._lspProgressDisposable.dispose();
            this._lspProgressDisposable = void 0;
          }
          if (this._tokenDisposable !== void 0) {
            this._tokenDisposable.dispose();
            this._tokenDisposable = void 0;
          }
          this._progress = void 0;
          this._cancellationToken = void 0;
        }
      };
      exports.ProgressPart = ProgressPart;
    }
  });

  // node_modules/vscode-languageclient/lib/common/notebook.js
  var require_notebook = __commonJS({
    "node_modules/vscode-languageclient/lib/common/notebook.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NotebookDocumentSyncFeature = void 0;
      var vscode = __require("vscode");
      var minimatch = require_minimatch();
      var proto = require_main8();
      var UUID = require_uuid();
      var Is2 = require_is7();
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = {};
        }
        return target[key];
      }
      var Converter;
      (function(Converter2) {
        let c2p;
        (function(c2p2) {
          function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
            return {
              version: notebookDocument.version,
              uri: base.asUri(notebookDocument.uri)
            };
          }
          c2p2.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
          function asNotebookDocument(notebookDocument, cells, base) {
            const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
            if (Object.keys(notebookDocument.metadata).length > 0) {
              result.metadata = asMetadata(notebookDocument.metadata);
            }
            return result;
          }
          c2p2.asNotebookDocument = asNotebookDocument;
          function asNotebookCells(cells, base) {
            return cells.map((cell) => asNotebookCell(cell, base));
          }
          c2p2.asNotebookCells = asNotebookCells;
          function asMetadata(metadata) {
            const seen = /* @__PURE__ */ new Set();
            return deepCopy(seen, metadata);
          }
          c2p2.asMetadata = asMetadata;
          function asNotebookCell(cell, base) {
            const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
            if (Object.keys(cell.metadata).length > 0) {
              result.metadata = asMetadata(cell.metadata);
            }
            if (cell.executionSummary !== void 0 && (Is2.number(cell.executionSummary.executionOrder) && Is2.boolean(cell.executionSummary.success))) {
              result.executionSummary = {
                executionOrder: cell.executionSummary.executionOrder,
                success: cell.executionSummary.success
              };
            }
            return result;
          }
          c2p2.asNotebookCell = asNotebookCell;
          function asNotebookCellKind(kind) {
            switch (kind) {
              case vscode.NotebookCellKind.Markup:
                return proto.NotebookCellKind.Markup;
              case vscode.NotebookCellKind.Code:
                return proto.NotebookCellKind.Code;
            }
          }
          function deepCopy(seen, value) {
            if (seen.has(value)) {
              throw new Error(`Can't deep copy cyclic structures.`);
            }
            if (Array.isArray(value)) {
              const result = [];
              for (const elem of value) {
                if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                  result.push(deepCopy(seen, elem));
                } else {
                  if (elem instanceof RegExp) {
                    throw new Error(`Can't transfer regular expressions to the server`);
                  }
                  result.push(elem);
                }
              }
              return result;
            } else {
              const props = Object.keys(value);
              const result = /* @__PURE__ */ Object.create(null);
              for (const prop of props) {
                const elem = value[prop];
                if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                  result[prop] = deepCopy(seen, elem);
                } else {
                  if (elem instanceof RegExp) {
                    throw new Error(`Can't transfer regular expressions to the server`);
                  }
                  result[prop] = elem;
                }
              }
              return result;
            }
          }
          function asTextContentChange(event, base) {
            const params = base.asChangeTextDocumentParams(event);
            return { document: params.textDocument, changes: params.contentChanges };
          }
          c2p2.asTextContentChange = asTextContentChange;
          function asNotebookDocumentChangeEvent(event, base) {
            const result = /* @__PURE__ */ Object.create(null);
            if (event.metadata) {
              result.metadata = Converter2.c2p.asMetadata(event.metadata);
            }
            if (event.cells !== void 0) {
              const cells = /* @__PURE__ */ Object.create(null);
              const changedCells = event.cells;
              if (changedCells.structure) {
                cells.structure = {
                  array: {
                    start: changedCells.structure.array.start,
                    deleteCount: changedCells.structure.array.deleteCount,
                    cells: changedCells.structure.array.cells !== void 0 ? changedCells.structure.array.cells.map((cell) => Converter2.c2p.asNotebookCell(cell, base)) : void 0
                  },
                  didOpen: changedCells.structure.didOpen !== void 0 ? changedCells.structure.didOpen.map((cell) => base.asOpenTextDocumentParams(cell.document).textDocument) : void 0,
                  didClose: changedCells.structure.didClose !== void 0 ? changedCells.structure.didClose.map((cell) => base.asCloseTextDocumentParams(cell.document).textDocument) : void 0
                };
              }
              if (changedCells.data !== void 0) {
                cells.data = changedCells.data.map((cell) => Converter2.c2p.asNotebookCell(cell, base));
              }
              if (changedCells.textContent !== void 0) {
                cells.textContent = changedCells.textContent.map((event2) => Converter2.c2p.asTextContentChange(event2, base));
              }
              if (Object.keys(cells).length > 0) {
                result.cells = cells;
              }
            }
            return result;
          }
          c2p2.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
        })(c2p = Converter2.c2p || (Converter2.c2p = {}));
      })(Converter || (Converter = {}));
      var $NotebookCell;
      (function($NotebookCell2) {
        function computeDiff(originalCells, modifiedCells, compareMetadata) {
          const originalLength = originalCells.length;
          const modifiedLength = modifiedCells.length;
          let startIndex = 0;
          while (startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
            startIndex++;
          }
          if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
              originalEndIndex--;
              modifiedEndIndex--;
            }
            const deleteCount = originalEndIndex + 1 - startIndex;
            const newCells = startIndex === modifiedEndIndex + 1 ? void 0 : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
            return newCells !== void 0 ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
          } else if (startIndex < modifiedLength) {
            return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
          } else if (startIndex < originalLength) {
            return { start: startIndex, deleteCount: originalLength - startIndex };
          } else {
            return void 0;
          }
        }
        $NotebookCell2.computeDiff = computeDiff;
        function equals(one, other, compareMetaData = true) {
          if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId || !equalsExecution(one.executionSummary, other.executionSummary)) {
            return false;
          }
          return !compareMetaData || compareMetaData && equalsMetadata(one.metadata, other.metadata);
        }
        function equalsExecution(one, other) {
          if (one === other) {
            return true;
          }
          if (one === void 0 || other === void 0) {
            return false;
          }
          return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
        }
        function equalsTiming(one, other) {
          if (one === other) {
            return true;
          }
          if (one === void 0 || other === void 0) {
            return false;
          }
          return one.startTime === other.startTime && one.endTime === other.endTime;
        }
        function equalsMetadata(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          if (typeof one !== typeof other) {
            return false;
          }
          if (typeof one !== "object") {
            return false;
          }
          const oneArray = Array.isArray(one);
          const otherArray = Array.isArray(other);
          if (oneArray !== otherArray) {
            return false;
          }
          if (oneArray && otherArray) {
            if (one.length !== other.length) {
              return false;
            }
            for (let i = 0; i < one.length; i++) {
              if (!equalsMetadata(one[i], other[i])) {
                return false;
              }
            }
          }
          if (isObjectLiteral(one) && isObjectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
              return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
              return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
              const prop = oneKeys[i];
              if (!equalsMetadata(one[prop], other[prop])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        function isObjectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        $NotebookCell2.isObjectLiteral = isObjectLiteral;
      })($NotebookCell || ($NotebookCell = {}));
      var $NotebookDocumentFilter;
      (function($NotebookDocumentFilter2) {
        function matchNotebook(filter, notebookDocument) {
          if (typeof filter === "string") {
            return filter === "*" || notebookDocument.notebookType === filter;
          }
          if (filter.notebookType !== void 0 && filter.notebookType !== "*" && notebookDocument.notebookType !== filter.notebookType) {
            return false;
          }
          const uri = notebookDocument.uri;
          if (filter.scheme !== void 0 && filter.scheme !== "*" && uri.scheme !== filter.scheme) {
            return false;
          }
          if (filter.pattern !== void 0) {
            const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
            if (!matcher.makeRe()) {
              return false;
            }
            if (!matcher.match(uri.fsPath)) {
              return false;
            }
          }
          return true;
        }
        $NotebookDocumentFilter2.matchNotebook = matchNotebook;
      })($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
      var $NotebookDocumentSyncOptions;
      (function($NotebookDocumentSyncOptions2) {
        function asDocumentSelector(options) {
          const selector = options.notebookSelector;
          const result = [];
          for (const element of selector) {
            const notebookType = (typeof element.notebook === "string" ? element.notebook : element.notebook?.notebookType) ?? "*";
            const scheme = typeof element.notebook === "string" ? void 0 : element.notebook?.scheme;
            const pattern = typeof element.notebook === "string" ? void 0 : element.notebook?.pattern;
            if (element.cells !== void 0) {
              for (const cell of element.cells) {
                result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));
              }
            } else {
              result.push(asDocumentFilter(notebookType, scheme, pattern, void 0));
            }
          }
          return result;
        }
        $NotebookDocumentSyncOptions2.asDocumentSelector = asDocumentSelector;
        function asDocumentFilter(notebookType, scheme, pattern, language) {
          return scheme === void 0 && pattern === void 0 ? { notebook: notebookType, language } : { notebook: { notebookType, scheme, pattern }, language };
        }
      })($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
      var SyncInfo;
      (function(SyncInfo2) {
        function create(cells) {
          return {
            cells,
            uris: new Set(cells.map((cell) => cell.document.uri.toString()))
          };
        }
        SyncInfo2.create = create;
      })(SyncInfo || (SyncInfo = {}));
      var NotebookDocumentSyncFeatureProvider = class {
        constructor(client, options) {
          this.client = client;
          this.options = options;
          this.notebookSyncInfo = /* @__PURE__ */ new Map();
          this.notebookDidOpen = /* @__PURE__ */ new Set();
          this.disposables = [];
          this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
          vscode.workspace.onDidOpenNotebookDocument((notebookDocument) => {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
          }, void 0, this.disposables);
          for (const notebookDocument of vscode.workspace.notebookDocuments) {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
          }
          vscode.workspace.onDidChangeNotebookDocument((event) => this.didChangeNotebookDocument(event), void 0, this.disposables);
          if (this.options.save === true) {
            vscode.workspace.onDidSaveNotebookDocument((notebookDocument) => this.didSave(notebookDocument), void 0, this.disposables);
          }
          vscode.workspace.onDidCloseNotebookDocument((notebookDocument) => {
            this.didClose(notebookDocument);
            this.notebookDidOpen.delete(notebookDocument.uri.toString());
          }, void 0, this.disposables);
        }
        getState() {
          for (const notebook of vscode.workspace.notebookDocuments) {
            const matchingCells = this.getMatchingCells(notebook);
            if (matchingCells !== void 0) {
              return { kind: "document", id: "$internal", registrations: true, matches: true };
            }
          }
          return { kind: "document", id: "$internal", registrations: true, matches: false };
        }
        get mode() {
          return "notebook";
        }
        handles(textDocument) {
          return vscode.languages.match(this.selector, textDocument) > 0;
        }
        didOpenNotebookCellTextDocument(notebookDocument, cell) {
          if (vscode.languages.match(this.selector, cell.document) === 0) {
            return;
          }
          if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
            return;
          }
          const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
          const cellMatches = this.cellMatches(notebookDocument, cell);
          if (syncInfo !== void 0) {
            const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
            if (cellMatches && cellIsSynced || !cellMatches && !cellIsSynced) {
              return;
            }
            if (cellMatches) {
              const matchingCells = this.getMatchingCells(notebookDocument);
              if (matchingCells !== void 0) {
                const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
                if (event !== void 0) {
                  this.doSendChange(event, matchingCells).catch(() => {
                  });
                }
              }
            }
          } else {
            if (cellMatches) {
              this.doSendOpen(notebookDocument, [cell]).catch(() => {
              });
            }
          }
        }
        didChangeNotebookCellTextDocument(notebookDocument, event) {
          if (vscode.languages.match(this.selector, event.document) === 0) {
            return;
          }
          this.doSendChange({
            notebook: notebookDocument,
            cells: { textContent: [event] }
          }, void 0).catch(() => {
          });
        }
        didCloseNotebookCellTextDocument(notebookDocument, cell) {
          const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
          if (syncInfo === void 0) {
            return;
          }
          const cellUri = cell.document.uri;
          const index = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());
          if (index === -1) {
            return;
          }
          if (index === 0 && syncInfo.cells.length === 1) {
            this.doSendClose(notebookDocument, syncInfo.cells).catch(() => {
            });
          } else {
            const newCells = syncInfo.cells.slice();
            const deleted = newCells.splice(index, 1);
            this.doSendChange({
              notebook: notebookDocument,
              cells: {
                structure: {
                  array: { start: index, deleteCount: 1 },
                  didClose: deleted
                }
              }
            }, newCells).catch(() => {
            });
          }
        }
        dispose() {
          for (const disposable of this.disposables) {
            disposable.dispose();
          }
        }
        didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
          if (syncInfo !== void 0) {
            if (matchingCells !== void 0) {
              const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
              if (event !== void 0) {
                this.doSendChange(event, matchingCells).catch(() => {
                });
              }
            } else {
              this.doSendClose(notebookDocument, []).catch(() => {
              });
            }
          } else {
            if (matchingCells === void 0) {
              return;
            }
            this.doSendOpen(notebookDocument, matchingCells).catch(() => {
            });
          }
        }
        didChangeNotebookDocument(event) {
          const notebookDocument = event.notebook;
          const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
          if (syncInfo === void 0) {
            if (event.contentChanges.length === 0) {
              return;
            }
            const cells = this.getMatchingCells(notebookDocument);
            if (cells === void 0) {
              return;
            }
            this.didOpen(notebookDocument, cells, syncInfo);
          } else {
            const cells = this.getMatchingCells(notebookDocument);
            if (cells === void 0) {
              this.didClose(notebookDocument, syncInfo);
              return;
            }
            const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
            if (newEvent !== void 0) {
              this.doSendChange(newEvent, cells).catch(() => {
              });
            }
          }
        }
        didSave(notebookDocument) {
          const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
          if (syncInfo === void 0) {
            return;
          }
          this.doSendSave(notebookDocument).catch(() => {
          });
        }
        didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
          if (syncInfo === void 0) {
            return;
          }
          const syncedCells = notebookDocument.getCells().filter((cell) => syncInfo.uris.has(cell.document.uri.toString()));
          this.doSendClose(notebookDocument, syncedCells).catch(() => {
          });
        }
        async sendDidOpenNotebookDocument(notebookDocument) {
          const cells = this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            return;
          }
          return this.doSendOpen(notebookDocument, cells);
        }
        async doSendOpen(notebookDocument, cells) {
          const send = async (notebookDocument2, cells2) => {
            const nb = Converter.c2p.asNotebookDocument(notebookDocument2, cells2, this.client.code2ProtocolConverter);
            const cellDocuments = cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
            try {
              await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
                notebookDocument: nb,
                cellTextDocuments: cellDocuments
              });
            } catch (error) {
              this.client.error("Sending DidOpenNotebookDocumentNotification failed", error);
              throw error;
            }
          };
          const middleware = this.client.middleware?.notebooks;
          this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));
          return middleware?.didOpen !== void 0 ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
        }
        async sendDidChangeNotebookDocument(event) {
          return this.doSendChange(event, void 0);
        }
        async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
          const send = async (event2) => {
            try {
              await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
                notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event2.notebook, this.client.code2ProtocolConverter),
                change: Converter.c2p.asNotebookDocumentChangeEvent(event2, this.client.code2ProtocolConverter)
              });
            } catch (error) {
              this.client.error("Sending DidChangeNotebookDocumentNotification failed", error);
              throw error;
            }
          };
          const middleware = this.client.middleware?.notebooks;
          if (event.cells?.structure !== void 0) {
            this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));
          }
          return middleware?.didChange !== void 0 ? middleware?.didChange(event, send) : send(event);
        }
        async sendDidSaveNotebookDocument(notebookDocument) {
          return this.doSendSave(notebookDocument);
        }
        async doSendSave(notebookDocument) {
          const send = async (notebookDocument2) => {
            try {
              await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
                notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) }
              });
            } catch (error) {
              this.client.error("Sending DidSaveNotebookDocumentNotification failed", error);
              throw error;
            }
          };
          const middleware = this.client.middleware?.notebooks;
          return middleware?.didSave !== void 0 ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
        }
        async sendDidCloseNotebookDocument(notebookDocument) {
          return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
        }
        async doSendClose(notebookDocument, cells) {
          const send = async (notebookDocument2, cells2) => {
            try {
              await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
                notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) },
                cellTextDocuments: cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
              });
            } catch (error) {
              this.client.error("Sending DidCloseNotebookDocumentNotification failed", error);
              throw error;
            }
          };
          const middleware = this.client.middleware?.notebooks;
          this.notebookSyncInfo.delete(notebookDocument.uri.toString());
          return middleware?.didClose !== void 0 ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
        }
        asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {
          if (event !== void 0 && event.notebook !== notebook) {
            throw new Error("Notebook must be identical");
          }
          const result = {
            notebook
          };
          if (event?.metadata !== void 0) {
            result.metadata = Converter.c2p.asMetadata(event.metadata);
          }
          let matchingCellsSet;
          if (event?.cellChanges !== void 0 && event.cellChanges.length > 0) {
            const data = [];
            matchingCellsSet = new Set(matchingCells.map((cell) => cell.document.uri.toString()));
            for (const cellChange of event.cellChanges) {
              if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== void 0 || cellChange.metadata !== void 0)) {
                data.push(cellChange.cell);
              }
            }
            if (data.length > 0) {
              result.cells = result.cells ?? {};
              result.cells.data = data;
            }
          }
          if ((event?.contentChanges !== void 0 && event.contentChanges.length > 0 || event === void 0) && syncInfo !== void 0 && matchingCells !== void 0) {
            const oldCells = syncInfo.cells;
            const newCells = matchingCells;
            const diff = $NotebookCell.computeDiff(oldCells, newCells, false);
            let addedCells;
            let removedCells;
            if (diff !== void 0) {
              addedCells = diff.cells === void 0 ? /* @__PURE__ */ new Map() : new Map(diff.cells.map((cell) => [cell.document.uri.toString(), cell]));
              removedCells = diff.deleteCount === 0 ? /* @__PURE__ */ new Map() : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map((cell) => [cell.document.uri.toString(), cell]));
              for (const key of Array.from(removedCells.keys())) {
                if (addedCells.has(key)) {
                  removedCells.delete(key);
                  addedCells.delete(key);
                }
              }
              result.cells = result.cells ?? {};
              const didOpen = [];
              const didClose = [];
              if (addedCells.size > 0 || removedCells.size > 0) {
                for (const cell of addedCells.values()) {
                  didOpen.push(cell);
                }
                for (const cell of removedCells.values()) {
                  didClose.push(cell);
                }
              }
              result.cells.structure = {
                array: diff,
                didOpen,
                didClose
              };
            }
          }
          return Object.keys(result).length > 1 ? result : void 0;
        }
        getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
          if (this.options.notebookSelector === void 0) {
            return void 0;
          }
          for (const item of this.options.notebookSelector) {
            if (item.notebook === void 0) {
              if (item.cells === void 0) {
                return void 0;
              }
              const filtered = this.filterCells(notebookDocument, cells, item.cells);
              return filtered.length === 0 ? void 0 : filtered;
            } else if ($NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
              return item.cells === void 0 ? cells : this.filterCells(notebookDocument, cells, item.cells);
            }
          }
          return void 0;
        }
        cellMatches(notebookDocument, cell) {
          const cells = this.getMatchingCells(notebookDocument, [cell]);
          return cells !== void 0 && cells[0] === cell;
        }
        filterCells(notebookDocument, cells, cellSelector) {
          const result = cells.filter((cell) => {
            const cellLanguage = cell.document.languageId;
            return cellSelector.some(((filter) => filter.language === "*" || cellLanguage === filter.language));
          });
          return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === "function" ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, cells) : result;
        }
      };
      var NotebookDocumentSyncFeature = class _NotebookDocumentSyncFeature {
        constructor(client) {
          this.client = client;
          this.registrations = /* @__PURE__ */ new Map();
          this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;
          vscode.workspace.onDidOpenTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) {
              return;
            }
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === void 0 || notebookCell === void 0) {
              return;
            }
            for (const provider of this.registrations.values()) {
              if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
              }
            }
          });
          vscode.workspace.onDidChangeTextDocument((event) => {
            if (event.contentChanges.length === 0) {
              return;
            }
            const textDocument = event.document;
            if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) {
              return;
            }
            const [notebookDocument] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === void 0) {
              return;
            }
            for (const provider of this.registrations.values()) {
              if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                provider.didChangeNotebookCellTextDocument(notebookDocument, event);
              }
            }
          });
          vscode.workspace.onDidCloseTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) {
              return;
            }
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === void 0 || notebookCell === void 0) {
              return;
            }
            for (const provider of this.registrations.values()) {
              if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
              }
            }
          });
        }
        getState() {
          if (this.registrations.size === 0) {
            return { kind: "document", id: this.registrationType.method, registrations: false, matches: false };
          }
          for (const provider of this.registrations.values()) {
            const state = provider.getState();
            if (state.kind === "document" && state.registrations === true && state.matches === true) {
              return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
            }
          }
          return { kind: "document", id: this.registrationType.method, registrations: true, matches: false };
        }
        fillClientCapabilities(capabilities) {
          const synchronization = ensure(ensure(capabilities, "notebookDocument"), "synchronization");
          synchronization.dynamicRegistration = true;
          synchronization.executionSummarySupport = true;
        }
        preInitialize(capabilities) {
          const options = capabilities.notebookDocumentSync;
          if (options === void 0) {
            return;
          }
          this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
        }
        initialize(capabilities) {
          const options = capabilities.notebookDocumentSync;
          if (options === void 0) {
            return;
          }
          const id = options.id ?? UUID.generateUuid();
          this.register({ id, registerOptions: options });
        }
        register(data) {
          const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
          this.registrations.set(data.id, provider);
        }
        unregister(id) {
          const provider = this.registrations.get(id);
          provider && provider.dispose();
        }
        dispose() {
          for (const provider of this.registrations.values()) {
            provider.dispose();
          }
          this.registrations.clear();
        }
        handles(textDocument) {
          if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) {
            return false;
          }
          if (this.dedicatedChannel !== void 0 && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) {
            return true;
          }
          for (const provider of this.registrations.values()) {
            if (provider.handles(textDocument)) {
              return true;
            }
          }
          return false;
        }
        getProvider(notebookCell) {
          for (const provider of this.registrations.values()) {
            if (provider.handles(notebookCell.document)) {
              return provider;
            }
          }
          return void 0;
        }
        findNotebookDocumentAndCell(textDocument) {
          const uri = textDocument.uri.toString();
          for (const notebookDocument of vscode.workspace.notebookDocuments) {
            for (const cell of notebookDocument.getCells()) {
              if (cell.document.uri.toString() === uri) {
                return [notebookDocument, cell];
              }
            }
          }
          return [void 0, void 0];
        }
      };
      exports.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
      NotebookDocumentSyncFeature.CellScheme = "vscode-notebook-cell";
    }
  });

  // node_modules/vscode-languageclient/lib/common/configuration.js
  var require_configuration = __commonJS({
    "node_modules/vscode-languageclient/lib/common/configuration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SyncConfigurationFeature = exports.toJSONObject = exports.ConfigurationFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var Is2 = require_is7();
      var UUID = require_uuid();
      var features_1 = require_features();
      var ConfigurationFeature = class {
        constructor(client) {
          this._client = client;
        }
        getState() {
          return { kind: "static" };
        }
        fillClientCapabilities(capabilities) {
          capabilities.workspace = capabilities.workspace || {};
          capabilities.workspace.configuration = true;
        }
        initialize() {
          let client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params2) => {
              let result = [];
              for (let item of params2.items) {
                let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : void 0;
                result.push(this.getConfiguration(resource, item.section !== null ? item.section : void 0));
              }
              return result;
            };
            let middleware = client.middleware.workspace;
            return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
          });
        }
        getConfiguration(resource, section) {
          let result = null;
          if (section) {
            let index = section.lastIndexOf(".");
            if (index === -1) {
              result = toJSONObject(vscode_1.workspace.getConfiguration(void 0, resource).get(section));
            } else {
              let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
              if (config) {
                result = toJSONObject(config.get(section.substr(index + 1)));
              }
            }
          } else {
            let config = vscode_1.workspace.getConfiguration(void 0, resource);
            result = {};
            for (let key of Object.keys(config)) {
              if (config.has(key)) {
                result[key] = toJSONObject(config.get(key));
              }
            }
          }
          if (result === void 0) {
            result = null;
          }
          return result;
        }
        dispose() {
        }
      };
      exports.ConfigurationFeature = ConfigurationFeature;
      function toJSONObject(obj) {
        if (obj) {
          if (Array.isArray(obj)) {
            return obj.map(toJSONObject);
          } else if (typeof obj === "object") {
            const res = /* @__PURE__ */ Object.create(null);
            for (const key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                res[key] = toJSONObject(obj[key]);
              }
            }
            return res;
          }
        }
        return obj;
      }
      exports.toJSONObject = toJSONObject;
      var SyncConfigurationFeature = class {
        constructor(_client) {
          this._client = _client;
          this._listeners = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
        }
        initialize() {
          let section = this._client.clientOptions.synchronize?.configurationSection;
          if (section !== void 0) {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: {
                section
              }
            });
          }
        }
        register(data) {
          let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
          });
          this._listeners.set(data.id, disposable);
          if (data.registerOptions.section !== void 0) {
            this.onDidChangeConfiguration(data.registerOptions.section, void 0);
          }
        }
        unregister(id) {
          let disposable = this._listeners.get(id);
          if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
          }
        }
        dispose() {
          for (const disposable of this._listeners.values()) {
            disposable.dispose();
          }
          this._listeners.clear();
        }
        onDidChangeConfiguration(configurationSection, event) {
          let sections;
          if (Is2.string(configurationSection)) {
            sections = [configurationSection];
          } else {
            sections = configurationSection;
          }
          if (sections !== void 0 && event !== void 0) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
              return;
            }
          }
          const didChangeConfiguration = async (sections2) => {
            if (sections2 === void 0) {
              return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
            } else {
              return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections2) });
            }
          };
          let middleware = this._client.middleware.workspace?.didChangeConfiguration;
          (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
          });
        }
        extractSettingsInformation(keys) {
          function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
              let obj = current[path[i]];
              if (!obj) {
                obj = /* @__PURE__ */ Object.create(null);
                current[path[i]] = obj;
              }
              current = obj;
            }
            return current;
          }
          let resource = this._client.clientOptions.workspaceFolder ? this._client.clientOptions.workspaceFolder.uri : void 0;
          let result = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf(".");
            let config = null;
            if (index >= 0) {
              config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            } else {
              config = vscode_1.workspace.getConfiguration(void 0, resource).get(key);
            }
            if (config) {
              let path = keys[i].split(".");
              ensurePath(result, path)[path[path.length - 1]] = toJSONObject(config);
            }
          }
          return result;
        }
      };
      exports.SyncConfigurationFeature = SyncConfigurationFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/textSynchronization.js
  var require_textSynchronization = __commonJS({
    "node_modules/vscode-languageclient/lib/common/textSynchronization.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DidSaveTextDocumentFeature = exports.WillSaveWaitUntilFeature = exports.WillSaveFeature = exports.DidChangeTextDocumentFeature = exports.DidCloseTextDocumentFeature = exports.DidOpenTextDocumentFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var async_1 = require_async();
      var UUID = require_uuid();
      var DidOpenTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
        constructor(client, syncedDocuments) {
          super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
          this._syncedDocuments = syncedDocuments;
        }
        get openDocuments() {
          return this._syncedDocuments.values();
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
          }
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
        }
        register(data) {
          super.register(data);
          if (!data.registerOptions.documentSelector) {
            return;
          }
          const documentSelector = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
          vscode_1.workspace.textDocuments.forEach((textDocument) => {
            const uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
              return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
              const middleware = this._client.middleware;
              const didOpen = (textDocument2) => {
                return this._client.sendNotification(this._type, this._createParams(textDocument2));
              };
              (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed`, error);
              });
              this._syncedDocuments.set(uri, textDocument);
            }
          });
        }
        notificationSent(textDocument, type, params) {
          super.notificationSent(textDocument, type, params);
          this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
        }
      };
      exports.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
      var DidCloseTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
        constructor(client, syncedDocuments) {
          super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
          this._syncedDocuments = syncedDocuments;
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
          }
        }
        notificationSent(textDocument, type, params) {
          super.notificationSent(textDocument, type, params);
          this._syncedDocuments.delete(textDocument.uri.toString());
        }
        unregister(id) {
          const selector = this._selectors.get(id);
          super.unregister(id);
          const selectors = this._selectors.values();
          this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
              let middleware = this._client.middleware;
              let didClose = (textDocument2) => {
                return this._client.sendNotification(this._type, this._createParams(textDocument2));
              };
              this._syncedDocuments.delete(textDocument.uri.toString());
              (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed`, error);
              });
            }
          });
        }
      };
      exports.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
      var DidChangeTextDocumentFeature = class extends features_1.DynamicDocumentFeature {
        constructor(client) {
          super(client);
          this._forcingDelivery = false;
          this._changeData = /* @__PURE__ */ new Map();
          this._onNotificationSent = new vscode_1.EventEmitter();
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
          }
        }
        register(data) {
          if (!data.registerOptions.documentSelector) {
            return;
          }
          if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
          }
          this._changeData.set(data.id, {
            syncKind: data.registerOptions.syncKind,
            documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector)
          });
        }
        *getDocumentSelectors() {
          for (const data of this._changeData.values()) {
            yield data.documentSelector;
          }
        }
        async callback(event) {
          if (event.contentChanges.length === 0) {
            return;
          }
          const promises = [];
          for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
              const middleware = this._client.middleware;
              if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                const didChange = async (event2) => {
                  const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event2);
                  await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                  this.notificationSent(event2, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                };
                promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
              } else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                const didChange = async (event2) => {
                  const doSend = async (event3) => {
                    const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event3.document);
                    await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    this.notificationSent(event3, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                  };
                  if (this._changeDelayer) {
                    if (this._changeDelayer.uri !== event2.document.uri.toString()) {
                      this.forceDelivery();
                      this._changeDelayer.uri = event2.document.uri.toString();
                    }
                    return this._changeDelayer.delayer.trigger(() => doSend(event2));
                  } else {
                    this._changeDelayer = {
                      uri: event2.document.uri.toString(),
                      delayer: new async_1.Delayer(200)
                    };
                    return this._changeDelayer.delayer.trigger(() => doSend(event2), -1);
                  }
                };
                promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
              }
            }
          }
          return Promise.all(promises).then(void 0, (error) => {
            this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
            throw error;
          });
        }
        get onNotificationSent() {
          return this._onNotificationSent.event;
        }
        notificationSent(changeEvent, type, params) {
          this._onNotificationSent.fire({ original: changeEvent, type, params });
        }
        unregister(id) {
          this._changeData.delete(id);
          if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        dispose() {
          if (this._changeDelayer !== void 0) {
            this._changeDelayer.delayer.cancel();
          }
          this._changeDelayer = void 0;
          this._forcingDelivery = false;
          this._changeData.clear();
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        forceDelivery() {
          if (this._forcingDelivery || !this._changeDelayer) {
            return;
          }
          try {
            this._forcingDelivery = true;
            this._changeDelayer.delayer.forceDelivery();
          } finally {
            this._forcingDelivery = false;
          }
        }
        getProvider(document2) {
          for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, document2) > 0) {
              return {
                send: (event) => {
                  return this.callback(event);
                }
              };
            }
          }
          return void 0;
        }
      };
      exports.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
      var WillSaveFeature = class extends features_1.TextDocumentEventFeature {
        constructor(client) {
          super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (event) => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
        }
        fillClientCapabilities(capabilities) {
          let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
          value.willSave = true;
        }
        initialize(capabilities, documentSelector) {
          let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: { documentSelector }
            });
          }
        }
      };
      exports.WillSaveFeature = WillSaveFeature;
      var WillSaveWaitUntilFeature = class extends features_1.DynamicDocumentFeature {
        constructor(client) {
          super(client);
          this._selectors = /* @__PURE__ */ new Map();
        }
        getDocumentSelectors() {
          return this._selectors.values();
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
        }
        fillClientCapabilities(capabilities) {
          let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
          value.willSaveWaitUntil = true;
        }
        initialize(capabilities, documentSelector) {
          let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: { documentSelector }
            });
          }
        }
        register(data) {
          if (!data.registerOptions.documentSelector) {
            return;
          }
          if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
          }
          this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
        }
        callback(event) {
          if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
            let middleware = this._client.middleware;
            let willSaveWaitUntil = (event2) => {
              return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event2)).then(async (edits) => {
                let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
                return vEdits === void 0 ? [] : vEdits;
              });
            };
            event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
          }
        }
        unregister(id) {
          this._selectors.delete(id);
          if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        dispose() {
          this._selectors.clear();
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
      };
      exports.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
      var DidSaveTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
        constructor(client) {
          super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
          this._includeText = false;
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").didSave = true;
        }
        initialize(capabilities, documentSelector) {
          const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
            this.register({
              id: UUID.generateUuid(),
              registerOptions: Object.assign({}, { documentSelector }, saveOptions)
            });
          }
        }
        register(data) {
          this._includeText = !!data.registerOptions.includeText;
          super.register(data);
        }
      };
      exports.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/completion.js
  var require_completion = __commonJS({
    "node_modules/vscode-languageclient/lib/common/completion.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompletionItemFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var UUID = require_uuid();
      var SupportedCompletionItemKinds = [
        vscode_languageserver_protocol_1.CompletionItemKind.Text,
        vscode_languageserver_protocol_1.CompletionItemKind.Method,
        vscode_languageserver_protocol_1.CompletionItemKind.Function,
        vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
        vscode_languageserver_protocol_1.CompletionItemKind.Field,
        vscode_languageserver_protocol_1.CompletionItemKind.Variable,
        vscode_languageserver_protocol_1.CompletionItemKind.Class,
        vscode_languageserver_protocol_1.CompletionItemKind.Interface,
        vscode_languageserver_protocol_1.CompletionItemKind.Module,
        vscode_languageserver_protocol_1.CompletionItemKind.Property,
        vscode_languageserver_protocol_1.CompletionItemKind.Unit,
        vscode_languageserver_protocol_1.CompletionItemKind.Value,
        vscode_languageserver_protocol_1.CompletionItemKind.Enum,
        vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
        vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
        vscode_languageserver_protocol_1.CompletionItemKind.Color,
        vscode_languageserver_protocol_1.CompletionItemKind.File,
        vscode_languageserver_protocol_1.CompletionItemKind.Reference,
        vscode_languageserver_protocol_1.CompletionItemKind.Folder,
        vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
        vscode_languageserver_protocol_1.CompletionItemKind.Constant,
        vscode_languageserver_protocol_1.CompletionItemKind.Struct,
        vscode_languageserver_protocol_1.CompletionItemKind.Event,
        vscode_languageserver_protocol_1.CompletionItemKind.Operator,
        vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
      ];
      var CompletionItemFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
          this.labelDetailsSupport = /* @__PURE__ */ new Map();
        }
        fillClientCapabilities(capabilities) {
          let completion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "completion");
          completion.dynamicRegistration = true;
          completion.contextSupport = true;
          completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
            insertReplaceSupport: true,
            resolveSupport: {
              properties: ["documentation", "detail", "additionalTextEdits"]
            },
            insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
            labelDetailsSupport: true
          };
          completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
          completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
          completion.completionList = {
            itemDefaults: [
              "commitCharacters",
              "editRange",
              "insertTextFormat",
              "insertTextMode"
            ]
          };
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
          if (!options) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: options
          });
        }
        registerLanguageProvider(options, id) {
          this.labelDetailsSupport.set(id, !!options.completionItem?.labelDetailsSupport);
          const triggerCharacters = options.triggerCharacters ?? [];
          const defaultCommitCharacters = options.allCommitCharacters;
          const selector = options.documentSelector;
          const provider = {
            provideCompletionItems: (document2, position, token, context) => {
              const client = this._client;
              const middleware = this._client.middleware;
              const provideCompletionItems = (document3, position2, context2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document3, position2, context2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token2, error, null);
                });
              };
              return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider ? (item, token) => {
              const client = this._client;
              const middleware = this._client.middleware;
              const resolveCompletionItem = (item2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item2, !!this.labelDetailsSupport.get(id)), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asCompletionItem(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token2, error, item2);
                });
              };
              return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
            } : void 0
          };
          return [vscode_1.languages.registerCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, ...triggerCharacters), provider];
        }
      };
      exports.CompletionItemFeature = CompletionItemFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/hover.js
  var require_hover = __commonJS({
    "node_modules/vscode-languageclient/lib/common/hover.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HoverFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var UUID = require_uuid();
      var HoverFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.HoverRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const hoverCapability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "hover");
          hoverCapability.dynamicRegistration = true;
          hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
          if (!options) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: options
          });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideHover: (document2, position, token) => {
              const client = this._client;
              const provideHover = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asHover(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerHoverProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.HoverFeature = HoverFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/definition.js
  var require_definition = __commonJS({
    "node_modules/vscode-languageclient/lib/common/definition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefinitionFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var UUID = require_uuid();
      var DefinitionFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let definitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "definition");
          definitionSupport.dynamicRegistration = true;
          definitionSupport.linkSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDefinition: (document2, position, token) => {
              const client = this._client;
              const provideDefinition = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDefinitionResult(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.DefinitionFeature = DefinitionFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/signatureHelp.js
  var require_signatureHelp = __commonJS({
    "node_modules/vscode-languageclient/lib/common/signatureHelp.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SignatureHelpFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var UUID = require_uuid();
      var SignatureHelpFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "signatureHelp");
          config.dynamicRegistration = true;
          config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
          config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
          config.signatureInformation.activeParameterSupport = true;
          config.contextSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
          if (!options) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: options
          });
        }
        registerLanguageProvider(options) {
          const provider = {
            provideSignatureHelp: (document2, position, token, context) => {
              const client = this._client;
              const providerSignatureHelp = (document3, position2, context2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document3, position2, context2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asSignatureHelp(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
            }
          };
          return [this.registerProvider(options, provider), provider];
        }
        registerProvider(options, provider) {
          const selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
          if (options.retriggerCharacters === void 0) {
            const triggerCharacters = options.triggerCharacters || [];
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, ...triggerCharacters);
          } else {
            const metaData = {
              triggerCharacters: options.triggerCharacters || [],
              retriggerCharacters: options.retriggerCharacters || []
            };
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, metaData);
          }
        }
      };
      exports.SignatureHelpFeature = SignatureHelpFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/documentHighlight.js
  var require_documentHighlight = __commonJS({
    "node_modules/vscode-languageclient/lib/common/documentHighlight.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentHighlightFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var UUID = require_uuid();
      var DocumentHighlightFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentHighlights: (document2, position, token) => {
              const client = this._client;
              const _provideDocumentHighlights = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDocumentHighlights(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
            }
          };
          return [vscode_1.languages.registerDocumentHighlightProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports.DocumentHighlightFeature = DocumentHighlightFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/documentSymbol.js
  var require_documentSymbol = __commonJS({
    "node_modules/vscode-languageclient/lib/common/documentSymbol.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentSymbolFeature = exports.SupportedSymbolTags = exports.SupportedSymbolKinds = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var UUID = require_uuid();
      exports.SupportedSymbolKinds = [
        vscode_languageserver_protocol_1.SymbolKind.File,
        vscode_languageserver_protocol_1.SymbolKind.Module,
        vscode_languageserver_protocol_1.SymbolKind.Namespace,
        vscode_languageserver_protocol_1.SymbolKind.Package,
        vscode_languageserver_protocol_1.SymbolKind.Class,
        vscode_languageserver_protocol_1.SymbolKind.Method,
        vscode_languageserver_protocol_1.SymbolKind.Property,
        vscode_languageserver_protocol_1.SymbolKind.Field,
        vscode_languageserver_protocol_1.SymbolKind.Constructor,
        vscode_languageserver_protocol_1.SymbolKind.Enum,
        vscode_languageserver_protocol_1.SymbolKind.Interface,
        vscode_languageserver_protocol_1.SymbolKind.Function,
        vscode_languageserver_protocol_1.SymbolKind.Variable,
        vscode_languageserver_protocol_1.SymbolKind.Constant,
        vscode_languageserver_protocol_1.SymbolKind.String,
        vscode_languageserver_protocol_1.SymbolKind.Number,
        vscode_languageserver_protocol_1.SymbolKind.Boolean,
        vscode_languageserver_protocol_1.SymbolKind.Array,
        vscode_languageserver_protocol_1.SymbolKind.Object,
        vscode_languageserver_protocol_1.SymbolKind.Key,
        vscode_languageserver_protocol_1.SymbolKind.Null,
        vscode_languageserver_protocol_1.SymbolKind.EnumMember,
        vscode_languageserver_protocol_1.SymbolKind.Struct,
        vscode_languageserver_protocol_1.SymbolKind.Event,
        vscode_languageserver_protocol_1.SymbolKind.Operator,
        vscode_languageserver_protocol_1.SymbolKind.TypeParameter
      ];
      exports.SupportedSymbolTags = [
        vscode_languageserver_protocol_1.SymbolTag.Deprecated
      ];
      var DocumentSymbolFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentSymbol");
          symbolCapabilities.dynamicRegistration = true;
          symbolCapabilities.symbolKind = {
            valueSet: exports.SupportedSymbolKinds
          };
          symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
          symbolCapabilities.tagSupport = {
            valueSet: exports.SupportedSymbolTags
          };
          symbolCapabilities.labelSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentSymbols: (document2, token) => {
              const client = this._client;
              const _provideDocumentSymbols = (document3, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document3), token2).then(async (data) => {
                  if (token2.isCancellationRequested || data === void 0 || data === null) {
                    return null;
                  }
                  if (data.length === 0) {
                    return [];
                  } else {
                    const first = data[0];
                    if (vscode_languageserver_protocol_1.DocumentSymbol.is(first)) {
                      return await client.protocol2CodeConverter.asDocumentSymbols(data, token2);
                    } else {
                      return await client.protocol2CodeConverter.asSymbolInformations(data, token2);
                    }
                  }
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
            }
          };
          const metaData = options.label !== void 0 ? { label: options.label } : void 0;
          return [vscode_1.languages.registerDocumentSymbolProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, metaData), provider];
        }
      };
      exports.DocumentSymbolFeature = DocumentSymbolFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/workspaceSymbol.js
  var require_workspaceSymbol = __commonJS({
    "node_modules/vscode-languageclient/lib/common/workspaceSymbol.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WorkspaceSymbolFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var documentSymbol_1 = require_documentSymbol();
      var UUID = require_uuid();
      var WorkspaceSymbolFeature = class extends features_1.WorkspaceFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "symbol");
          symbolCapabilities.dynamicRegistration = true;
          symbolCapabilities.symbolKind = {
            valueSet: documentSymbol_1.SupportedSymbolKinds
          };
          symbolCapabilities.tagSupport = {
            valueSet: documentSymbol_1.SupportedSymbolTags
          };
          symbolCapabilities.resolveSupport = { properties: ["location.range"] };
        }
        initialize(capabilities) {
          if (!capabilities.workspaceSymbolProvider) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
          });
        }
        registerLanguageProvider(options) {
          const provider = {
            provideWorkspaceSymbols: (query, token) => {
              const client = this._client;
              const provideWorkspaceSymbols = (query2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query: query2 }, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asSymbolInformations(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
            },
            resolveWorkspaceSymbol: options.resolveProvider === true ? (item, token) => {
              const client = this._client;
              const resolveWorkspaceSymbol = (item2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client.code2ProtocolConverter.asWorkspaceSymbol(item2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asSymbolInformation(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
            } : void 0
          };
          return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
        }
      };
      exports.WorkspaceSymbolFeature = WorkspaceSymbolFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/reference.js
  var require_reference = __commonJS({
    "node_modules/vscode-languageclient/lib/common/reference.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReferencesFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var UUID = require_uuid();
      var ReferencesFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "references").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideReferences: (document2, position, options2, token) => {
              const client = this._client;
              const _providerReferences = (document3, position2, options3, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document3, position2, options3), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asReferences(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideReferences ? middleware.provideReferences(document2, position, options2, token, _providerReferences) : _providerReferences(document2, position, options2, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerReferenceProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.ReferencesFeature = ReferencesFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/codeAction.js
  var require_codeAction = __commonJS({
    "node_modules/vscode-languageclient/lib/common/codeAction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodeActionFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var UUID = require_uuid();
      var features_1 = require_features();
      var CodeActionFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeAction");
          cap.dynamicRegistration = true;
          cap.isPreferredSupport = true;
          cap.disabledSupport = true;
          cap.dataSupport = true;
          cap.resolveSupport = {
            properties: ["edit"]
          };
          cap.codeActionLiteralSupport = {
            codeActionKind: {
              valueSet: [
                vscode_languageserver_protocol_1.CodeActionKind.Empty,
                vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                vscode_languageserver_protocol_1.CodeActionKind.Source,
                vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
              ]
            }
          };
          cap.honorsChangeAnnotations = false;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideCodeActions: (document2, range, context, token) => {
              const client = this._client;
              const _provideCodeActions = async (document3, range2, context2, token2) => {
                const params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client.code2ProtocolConverter.asRange(range2),
                  context: await client.code2ProtocolConverter.asCodeActionContext(context2, token2)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token2).then((values) => {
                  if (token2.isCancellationRequested || values === null || values === void 0) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asCodeActionResult(values, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range, context, token, _provideCodeActions) : _provideCodeActions(document2, range, context, token);
            },
            resolveCodeAction: options.resolveProvider ? (item, token) => {
              const client = this._client;
              const middleware = this._client.middleware;
              const resolveCodeAction = async (item2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, await client.code2ProtocolConverter.asCodeAction(item2, token2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return item2;
                  }
                  return client.protocol2CodeConverter.asCodeAction(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token2, error, item2);
                });
              };
              return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
            } : void 0
          };
          return [vscode_1.languages.registerCodeActionsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.codeActionKinds ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) } : void 0), provider];
        }
      };
      exports.CodeActionFeature = CodeActionFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/codeLens.js
  var require_codeLens = __commonJS({
    "node_modules/vscode-languageclient/lib/common/codeLens.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodeLensFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var UUID = require_uuid();
      var features_1 = require_features();
      var CodeLensFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "codeLens").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeCodeLensEmitter.fire();
            }
          });
          const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const eventEmitter = new vscode_1.EventEmitter();
          const provider = {
            onDidChangeCodeLenses: eventEmitter.event,
            provideCodeLenses: (document2, token) => {
              const client = this._client;
              const provideCodeLenses = (document3, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document3), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asCodeLenses(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
            },
            resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
              const client = this._client;
              const resolveCodeLens = (codeLens2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return codeLens2;
                  }
                  return client.protocol2CodeConverter.asCodeLens(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token2, error, codeLens2);
                });
              };
              const middleware = client.middleware;
              return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
            } : void 0
          };
          return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
        }
      };
      exports.CodeLensFeature = CodeLensFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/formatting.js
  var require_formatting = __commonJS({
    "node_modules/vscode-languageclient/lib/common/formatting.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentOnTypeFormattingFeature = exports.DocumentRangeFormattingFeature = exports.DocumentFormattingFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var UUID = require_uuid();
      var features_1 = require_features();
      var FileFormattingOptions;
      (function(FileFormattingOptions2) {
        function fromConfiguration(document2) {
          const filesConfig = vscode_1.workspace.getConfiguration("files", document2);
          return {
            trimTrailingWhitespace: filesConfig.get("trimTrailingWhitespace"),
            trimFinalNewlines: filesConfig.get("trimFinalNewlines"),
            insertFinalNewline: filesConfig.get("insertFinalNewline")
          };
        }
        FileFormattingOptions2.fromConfiguration = fromConfiguration;
      })(FileFormattingOptions || (FileFormattingOptions = {}));
      var DocumentFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentFormattingEdits: (document2, options2, token) => {
              const client = this._client;
              const provideDocumentFormattingEdits = (document3, options3, token2) => {
                const params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asTextEdits(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options2, token);
            }
          };
          return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports.DocumentFormattingFeature = DocumentFormattingFeature;
      var DocumentRangeFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rangeFormatting").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentRangeFormattingEdits: (document2, range, options2, token) => {
              const client = this._client;
              const provideDocumentRangeFormattingEdits = (document3, range2, options3, token2) => {
                const params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client.code2ProtocolConverter.asRange(range2),
                  options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asTextEdits(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range, options2, token);
            }
          };
          return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
      var DocumentOnTypeFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideOnTypeFormattingEdits: (document2, position, ch, options2, token) => {
              const client = this._client;
              const provideOnTypeFormattingEdits = (document3, position2, ch2, options3, token2) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  position: client.code2ProtocolConverter.asPosition(position2),
                  ch: ch2,
                  options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asTextEdits(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options2, token);
            }
          };
          const moreTriggerCharacter = options.moreTriggerCharacter || [];
          return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
        }
      };
      exports.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/rename.js
  var require_rename = __commonJS({
    "node_modules/vscode-languageclient/lib/common/rename.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RenameFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var UUID = require_uuid();
      var Is2 = require_is7();
      var features_1 = require_features();
      var RenameFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.RenameRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let rename = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rename");
          rename.dynamicRegistration = true;
          rename.prepareSupport = true;
          rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
          rename.honorsChangeAnnotations = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
          if (!options) {
            return;
          }
          if (Is2.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideRenameEdits: (document2, position, newName, token) => {
              const client = this._client;
              const provideRenameEdits = (document3, position2, newName2, token2) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  position: client.code2ProtocolConverter.asPosition(position2),
                  newName: newName2
                };
                return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asWorkspaceEdit(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token2, error, null, false);
                });
              };
              const middleware = client.middleware;
              return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
            },
            prepareRename: options.prepareProvider ? (document2, position, token) => {
              const client = this._client;
              const prepareRename = (document3, position2, token2) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  position: client.code2ProtocolConverter.asPosition(position2)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  if (vscode_languageserver_protocol_1.Range.is(result)) {
                    return client.protocol2CodeConverter.asRange(result);
                  } else if (this.isDefaultBehavior(result)) {
                    return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                  } else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                    return {
                      range: client.protocol2CodeConverter.asRange(result.range),
                      placeholder: result.placeholder
                    };
                  }
                  return Promise.reject(new Error(`The element can't be renamed.`));
                }, (error) => {
                  if (typeof error.message === "string") {
                    throw new Error(error.message);
                  } else {
                    throw new Error(`The element can't be renamed.`);
                  }
                });
              };
              const middleware = client.middleware;
              return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
            } : void 0
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerRenameProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
        isDefaultBehavior(value) {
          const candidate = value;
          return candidate && Is2.boolean(candidate.defaultBehavior);
        }
      };
      exports.RenameFeature = RenameFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/documentLink.js
  var require_documentLink = __commonJS({
    "node_modules/vscode-languageclient/lib/common/documentLink.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentLinkFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var UUID = require_uuid();
      var DocumentLinkFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const documentLinkCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentLink");
          documentLinkCapabilities.dynamicRegistration = true;
          documentLinkCapabilities.tooltipSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentLinks: (document2, token) => {
              const client = this._client;
              const provideDocumentLinks = (document3, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document3), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDocumentLinks(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
            },
            resolveDocumentLink: options.resolveProvider ? (link, token) => {
              const client = this._client;
              let resolveDocumentLink = (link2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return link2;
                  }
                  return client.protocol2CodeConverter.asDocumentLink(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token2, error, link2);
                });
              };
              const middleware = client.middleware;
              return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
            } : void 0
          };
          return [vscode_1.languages.registerDocumentLinkProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports.DocumentLinkFeature = DocumentLinkFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/executeCommand.js
  var require_executeCommand = __commonJS({
    "node_modules/vscode-languageclient/lib/common/executeCommand.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExecuteCommandFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var UUID = require_uuid();
      var features_1 = require_features();
      var ExecuteCommandFeature = class {
        constructor(client) {
          this._client = client;
          this._commands = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this.registrationType.method, registrations: this._commands.size > 0 };
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
        }
        initialize(capabilities) {
          if (!capabilities.executeCommandProvider) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
          });
        }
        register(data) {
          const client = this._client;
          const middleware = client.middleware;
          const executeCommand = (command, args) => {
            let params = {
              command,
              arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(void 0, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, void 0, error, void 0);
            });
          };
          if (data.registerOptions.commands) {
            const disposables = [];
            for (const command of data.registerOptions.commands) {
              disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
                return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
              }));
            }
            this._commands.set(data.id, disposables);
          }
        }
        unregister(id) {
          let disposables = this._commands.get(id);
          if (disposables) {
            disposables.forEach((disposable) => disposable.dispose());
          }
        }
        dispose() {
          this._commands.forEach((value) => {
            value.forEach((disposable) => disposable.dispose());
          });
          this._commands.clear();
        }
      };
      exports.ExecuteCommandFeature = ExecuteCommandFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js
  var require_fileSystemWatcher = __commonJS({
    "node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FileSystemWatcherFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var FileSystemWatcherFeature = class {
        constructor(client, notifyFileEvent) {
          this._client = client;
          this._notifyFileEvent = notifyFileEvent;
          this._watchers = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this.registrationType.method, registrations: this._watchers.size > 0 };
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").relativePatternSupport = true;
        }
        initialize(_capabilities, _documentSelector) {
        }
        register(data) {
          if (!Array.isArray(data.registerOptions.watchers)) {
            return;
          }
          const disposables = [];
          for (const watcher of data.registerOptions.watchers) {
            const globPattern = this._client.protocol2CodeConverter.asGlobPattern(watcher.globPattern);
            if (globPattern === void 0) {
              continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== void 0 && watcher.kind !== null) {
              watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
              watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
              watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
            }
            const fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
            disposables.push(fileSystemWatcher);
          }
          this._watchers.set(data.id, disposables);
        }
        registerRaw(id, fileSystemWatchers) {
          let disposables = [];
          for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposables);
          }
          this._watchers.set(id, disposables);
        }
        hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
          if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
              uri: this._client.code2ProtocolConverter.asUri(resource),
              type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
          }
          if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
              uri: this._client.code2ProtocolConverter.asUri(resource),
              type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
          }
          if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
              uri: this._client.code2ProtocolConverter.asUri(resource),
              type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
          }
        }
        unregister(id) {
          let disposables = this._watchers.get(id);
          if (disposables) {
            for (let disposable of disposables) {
              disposable.dispose();
            }
          }
        }
        dispose() {
          this._watchers.forEach((disposables) => {
            for (let disposable of disposables) {
              disposable.dispose();
            }
          });
          this._watchers.clear();
        }
      };
      exports.FileSystemWatcherFeature = FileSystemWatcherFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/colorProvider.js
  var require_colorProvider = __commonJS({
    "node_modules/vscode-languageclient/lib/common/colorProvider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ColorProviderFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var ColorProviderFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideColorPresentations: (color, context, token) => {
              const client = this._client;
              const provideColorPresentations = (color2, context2, token2) => {
                const requestParams = {
                  color: color2,
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context2.document),
                  range: client.code2ProtocolConverter.asRange(context2.range)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return this._client.protocol2CodeConverter.asColorPresentations(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document2, token) => {
              const client = this._client;
              const provideDocumentColors = (document3, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return this._client.protocol2CodeConverter.asColorInformations(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
            }
          };
          return [vscode_1.languages.registerColorProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports.ColorProviderFeature = ColorProviderFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/implementation.js
  var require_implementation = __commonJS({
    "node_modules/vscode-languageclient/lib/common/implementation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ImplementationFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var ImplementationFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let implementationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "implementation");
          implementationSupport.dynamicRegistration = true;
          implementationSupport.linkSupport = true;
        }
        initialize(capabilities, documentSelector) {
          let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideImplementation: (document2, position, token) => {
              const client = this._client;
              const provideImplementation = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDefinitionResult(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerImplementationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.ImplementationFeature = ImplementationFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/typeDefinition.js
  var require_typeDefinition = __commonJS({
    "node_modules/vscode-languageclient/lib/common/typeDefinition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeDefinitionFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var TypeDefinitionFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition").dynamicRegistration = true;
          let typeDefinitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition");
          typeDefinitionSupport.dynamicRegistration = true;
          typeDefinitionSupport.linkSupport = true;
        }
        initialize(capabilities, documentSelector) {
          let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideTypeDefinition: (document2, position, token) => {
              const client = this._client;
              const provideTypeDefinition = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDefinitionResult(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerTypeDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.TypeDefinitionFeature = TypeDefinitionFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/workspaceFolder.js
  var require_workspaceFolder = __commonJS({
    "node_modules/vscode-languageclient/lib/common/workspaceFolder.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WorkspaceFoldersFeature = exports.arrayDiff = void 0;
      var UUID = require_uuid();
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      function access(target, key) {
        if (target === void 0) {
          return void 0;
        }
        return target[key];
      }
      function arrayDiff(left, right) {
        return left.filter((element) => right.indexOf(element) < 0);
      }
      exports.arrayDiff = arrayDiff;
      var WorkspaceFoldersFeature = class {
        constructor(client) {
          this._client = client;
          this._listeners = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
        }
        fillInitializeParams(params) {
          const folders = vscode_1.workspace.workspaceFolders;
          this.initializeWithFolders(folders);
          if (folders === void 0) {
            params.workspaceFolders = null;
          } else {
            params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
          }
        }
        initializeWithFolders(currentWorkspaceFolders) {
          this._initialFolders = currentWorkspaceFolders;
        }
        fillClientCapabilities(capabilities) {
          capabilities.workspace = capabilities.workspace || {};
          capabilities.workspace.workspaceFolders = true;
        }
        initialize(capabilities) {
          const client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            const workspaceFolders = () => {
              const folders = vscode_1.workspace.workspaceFolders;
              if (folders === void 0) {
                return null;
              }
              const result = folders.map((folder) => {
                return this.asProtocol(folder);
              });
              return result;
            };
            const middleware = client.middleware.workspace;
            return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
          });
          const value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
          let id;
          if (typeof value === "string") {
            id = value;
          } else if (value === true) {
            id = UUID.generateUuid();
          }
          if (id) {
            this.register({ id, registerOptions: void 0 });
          }
        }
        sendInitialEvent(currentWorkspaceFolders) {
          let promise;
          if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
              promise = this.doSendEvent(added, removed);
            }
          } else if (this._initialFolders) {
            promise = this.doSendEvent([], this._initialFolders);
          } else if (currentWorkspaceFolders) {
            promise = this.doSendEvent(currentWorkspaceFolders, []);
          }
          if (promise !== void 0) {
            promise.catch((error) => {
              this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
          }
        }
        doSendEvent(addedFolders, removedFolders) {
          let params = {
            event: {
              added: addedFolders.map((folder) => this.asProtocol(folder)),
              removed: removedFolders.map((folder) => this.asProtocol(folder))
            }
          };
          return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
        }
        register(data) {
          let id = data.id;
          let client = this._client;
          let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event2) => {
              return this.doSendEvent(event2.added, event2.removed);
            };
            let middleware = client.middleware.workspace;
            const promise = middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
            promise.catch((error) => {
              this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
          });
          this._listeners.set(id, disposable);
          this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
        }
        unregister(id) {
          let disposable = this._listeners.get(id);
          if (disposable === void 0) {
            return;
          }
          this._listeners.delete(id);
          disposable.dispose();
        }
        dispose() {
          for (let disposable of this._listeners.values()) {
            disposable.dispose();
          }
          this._listeners.clear();
        }
        asProtocol(workspaceFolder) {
          if (workspaceFolder === void 0) {
            return null;
          }
          return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
        }
      };
      exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/foldingRange.js
  var require_foldingRange = __commonJS({
    "node_modules/vscode-languageclient/lib/common/foldingRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FoldingRangeFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var FoldingRangeFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "foldingRange");
          capability.dynamicRegistration = true;
          capability.rangeLimit = 5e3;
          capability.lineFoldingOnly = true;
          capability.foldingRangeKind = { valueSet: [vscode_languageserver_protocol_1.FoldingRangeKind.Comment, vscode_languageserver_protocol_1.FoldingRangeKind.Imports, vscode_languageserver_protocol_1.FoldingRangeKind.Region] };
          capability.foldingRange = { collapsedText: false };
        }
        initialize(capabilities, documentSelector) {
          let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideFoldingRanges: (document2, context, token) => {
              const client = this._client;
              const provideFoldingRanges = (document3, _, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asFoldingRanges(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
            }
          };
          return [vscode_1.languages.registerFoldingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports.FoldingRangeFeature = FoldingRangeFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/declaration.js
  var require_declaration = __commonJS({
    "node_modules/vscode-languageclient/lib/common/declaration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeclarationFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var DeclarationFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const declarationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "declaration");
          declarationSupport.dynamicRegistration = true;
          declarationSupport.linkSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDeclaration: (document2, position, token) => {
              const client = this._client;
              const provideDeclaration = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDeclarationResult(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerDeclarationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.DeclarationFeature = DeclarationFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/selectionRange.js
  var require_selectionRange = __commonJS({
    "node_modules/vscode-languageclient/lib/common/selectionRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectionRangeFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var SelectionRangeFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "selectionRange");
          capability.dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideSelectionRanges: (document2, positions, token) => {
              const client = this._client;
              const provideSelectionRanges = async (document3, positions2, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  positions: await client.code2ProtocolConverter.asPositions(positions2, token2)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token2).then((ranges) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asSelectionRanges(ranges, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document2, positions, token, provideSelectionRanges) : provideSelectionRanges(document2, positions, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerSelectionRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.SelectionRangeFeature = SelectionRangeFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/progress.js
  var require_progress = __commonJS({
    "node_modules/vscode-languageclient/lib/common/progress.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProgressFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main8();
      var progressPart_1 = require_progressPart();
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = /* @__PURE__ */ Object.create(null);
        }
        return target[key];
      }
      var ProgressFeature = class {
        constructor(_client) {
          this._client = _client;
          this.activeParts = /* @__PURE__ */ new Set();
        }
        getState() {
          return { kind: "window", id: vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
        }
        fillClientCapabilities(capabilities) {
          ensure(capabilities, "window").workDoneProgress = true;
        }
        initialize() {
          const client = this._client;
          const deleteHandler = (part) => {
            this.activeParts.delete(part);
          };
          const createHandler = (params) => {
            this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
          };
          client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
        }
        dispose() {
          for (const part of this.activeParts) {
            part.done();
          }
          this.activeParts.clear();
        }
      };
      exports.ProgressFeature = ProgressFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/callHierarchy.js
  var require_callHierarchy = __commonJS({
    "node_modules/vscode-languageclient/lib/common/callHierarchy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CallHierarchyFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var CallHierarchyProvider = class {
        constructor(client) {
          this.client = client;
          this.middleware = client.middleware;
        }
        prepareCallHierarchy(document2, position, token) {
          const client = this.client;
          const middleware = this.middleware;
          const prepareCallHierarchy = (document3, position2, token2) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asCallHierarchyItems(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token2, error, null);
            });
          };
          return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document2, position, token, prepareCallHierarchy) : prepareCallHierarchy(document2, position, token);
        }
        provideCallHierarchyIncomingCalls(item, token) {
          const client = this.client;
          const middleware = this.middleware;
          const provideCallHierarchyIncomingCalls = (item2, token2) => {
            const params = {
              item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token2, error, null);
            });
          };
          return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
        }
        provideCallHierarchyOutgoingCalls(item, token) {
          const client = this.client;
          const middleware = this.middleware;
          const provideCallHierarchyOutgoingCalls = (item2, token2) => {
            const params = {
              item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token2, error, null);
            });
          };
          return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
        }
      };
      var CallHierarchyFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
        }
        fillClientCapabilities(cap) {
          const capabilities = cap;
          const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "callHierarchy");
          capability.dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const client = this._client;
          const provider = new CallHierarchyProvider(client);
          return [vscode_1.languages.registerCallHierarchyProvider(this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
        }
      };
      exports.CallHierarchyFeature = CallHierarchyFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/semanticTokens.js
  var require_semanticTokens = __commonJS({
    "node_modules/vscode-languageclient/lib/common/semanticTokens.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SemanticTokensFeature = void 0;
      var vscode = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var Is2 = require_is7();
      var SemanticTokensFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
        }
        fillClientCapabilities(capabilities) {
          const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "semanticTokens");
          capability.dynamicRegistration = true;
          capability.tokenTypes = [
            vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
            vscode_languageserver_protocol_1.SemanticTokenTypes.type,
            vscode_languageserver_protocol_1.SemanticTokenTypes.class,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
            vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
            vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
            vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
            vscode_languageserver_protocol_1.SemanticTokenTypes.property,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
            vscode_languageserver_protocol_1.SemanticTokenTypes.event,
            vscode_languageserver_protocol_1.SemanticTokenTypes.function,
            vscode_languageserver_protocol_1.SemanticTokenTypes.method,
            vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
            vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
            vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
            vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
            vscode_languageserver_protocol_1.SemanticTokenTypes.string,
            vscode_languageserver_protocol_1.SemanticTokenTypes.number,
            vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
            vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
            vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
          ];
          capability.tokenModifiers = [
            vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
          ];
          capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
          capability.requests = {
            range: true,
            full: {
              delta: true
            }
          };
          capability.multilineTokenSupport = false;
          capability.overlappingTokenSupport = false;
          capability.serverCancelSupport = true;
          capability.augmentsSyntaxTokens = true;
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeSemanticTokensEmitter.fire();
            }
          });
          const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const fullProvider = Is2.boolean(options.full) ? options.full : options.full !== void 0;
          const hasEditProvider = options.full !== void 0 && typeof options.full !== "boolean" && options.full.delta === true;
          const eventEmitter = new vscode.EventEmitter();
          const documentProvider = fullProvider ? {
            onDidChangeSemanticTokens: eventEmitter.event,
            provideDocumentSemanticTokens: (document2, token) => {
              const client2 = this._client;
              const middleware = client2.middleware;
              const provideDocumentSemanticTokens = (document3, token2) => {
                const params = {
                  textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3)
                };
                return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client2.protocol2CodeConverter.asSemanticTokens(result, token2);
                }, (error) => {
                  return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token2, error, null);
                });
              };
              return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document2, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document2, token);
            },
            provideDocumentSemanticTokensEdits: hasEditProvider ? (document2, previousResultId, token) => {
              const client2 = this._client;
              const middleware = client2.middleware;
              const provideDocumentSemanticTokensEdits = (document3, previousResultId2, token2) => {
                const params = {
                  textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  previousResultId: previousResultId2
                };
                return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token2).then(async (result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                    return await client2.protocol2CodeConverter.asSemanticTokens(result, token2);
                  } else {
                    return await client2.protocol2CodeConverter.asSemanticTokensEdits(result, token2);
                  }
                }, (error) => {
                  return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token2, error, null);
                });
              };
              return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document2, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document2, previousResultId, token);
            } : void 0
          } : void 0;
          const hasRangeProvider = options.range === true;
          const rangeProvider = hasRangeProvider ? {
            provideDocumentRangeSemanticTokens: (document2, range, token) => {
              const client2 = this._client;
              const middleware = client2.middleware;
              const provideDocumentRangeSemanticTokens = (document3, range2, token2) => {
                const params = {
                  textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client2.code2ProtocolConverter.asRange(range2)
                };
                return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client2.protocol2CodeConverter.asSemanticTokens(result, token2);
                }, (error) => {
                  return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token2, error, null);
                });
              };
              return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document2, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document2, range, token);
            }
          } : void 0;
          const disposables = [];
          const client = this._client;
          const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
          const documentSelector = client.protocol2CodeConverter.asDocumentSelector(selector);
          if (documentProvider !== void 0) {
            disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentProvider, legend));
          }
          if (rangeProvider !== void 0) {
            disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, rangeProvider, legend));
          }
          return [new vscode.Disposable(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
        }
      };
      exports.SemanticTokensFeature = SemanticTokensFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/fileOperations.js
  var require_fileOperations = __commonJS({
    "node_modules/vscode-languageclient/lib/common/fileOperations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
      var code = __require("vscode");
      var minimatch = require_minimatch();
      var proto = require_main8();
      var UUID = require_uuid();
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = {};
        }
        return target[key];
      }
      function access(target, key) {
        return target[key];
      }
      function assign(target, key, value) {
        target[key] = value;
      }
      var FileOperationFeature = class _FileOperationFeature {
        constructor(client, event, registrationType, clientCapability, serverCapability) {
          this._client = client;
          this._event = event;
          this._registrationType = registrationType;
          this._clientCapability = clientCapability;
          this._serverCapability = serverCapability;
          this._filters = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this._registrationType.method, registrations: this._filters.size > 0 };
        }
        filterSize() {
          return this._filters.size;
        }
        get registrationType() {
          return this._registrationType;
        }
        fillClientCapabilities(capabilities) {
          const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
          assign(value, "dynamicRegistration", true);
          assign(value, this._clientCapability, true);
        }
        initialize(capabilities) {
          const options = capabilities.workspace?.fileOperations;
          const capability = options !== void 0 ? access(options, this._serverCapability) : void 0;
          if (capability?.filters !== void 0) {
            try {
              this.register({
                id: UUID.generateUuid(),
                registerOptions: { filters: capability.filters }
              });
            } catch (e) {
              this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
            }
          }
        }
        register(data) {
          if (!this._listener) {
            this._listener = this._event(this.send, this);
          }
          const minimatchFilter = data.registerOptions.filters.map((filter) => {
            const matcher = new minimatch.Minimatch(filter.pattern.glob, _FileOperationFeature.asMinimatchOptions(filter.pattern.options));
            if (!matcher.makeRe()) {
              throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
            }
            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
          });
          this._filters.set(data.id, minimatchFilter);
        }
        unregister(id) {
          this._filters.delete(id);
          if (this._filters.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        dispose() {
          this._filters.clear();
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        getFileType(uri) {
          return _FileOperationFeature.getFileType(uri);
        }
        async filter(event, prop) {
          const fileMatches = await Promise.all(event.files.map(async (item) => {
            const uri = prop(item);
            const path = uri.fsPath.replace(/\\/g, "/");
            for (const filters of this._filters.values()) {
              for (const filter of filters) {
                if (filter.scheme !== void 0 && filter.scheme !== uri.scheme) {
                  continue;
                }
                if (filter.matcher.match(path)) {
                  if (filter.kind === void 0) {
                    return true;
                  }
                  const fileType = await this.getFileType(uri);
                  if (fileType === void 0) {
                    this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                    return true;
                  }
                  if (fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file || fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder) {
                    return true;
                  }
                } else if (filter.kind === proto.FileOperationPatternKind.folder) {
                  const fileType = await _FileOperationFeature.getFileType(uri);
                  if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {
                    return true;
                  }
                }
              }
            }
            return false;
          }));
          const files = event.files.filter((_, index) => fileMatches[index]);
          return { ...event, files };
        }
        static async getFileType(uri) {
          try {
            return (await code.workspace.fs.stat(uri)).type;
          } catch (e) {
            return void 0;
          }
        }
        static asMinimatchOptions(options) {
          if (options === void 0) {
            return void 0;
          }
          if (options.ignoreCase === true) {
            return { nocase: true };
          }
          return void 0;
        }
      };
      var NotificationFileOperationFeature = class extends FileOperationFeature {
        constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
          super(client, event, notificationType, clientCapability, serverCapability);
          this._notificationType = notificationType;
          this._accessUri = accessUri;
          this._createParams = createParams;
        }
        async send(originalEvent) {
          const filteredEvent = await this.filter(originalEvent, this._accessUri);
          if (filteredEvent.files.length) {
            const next = async (event) => {
              return this._client.sendNotification(this._notificationType, this._createParams(event));
            };
            return this.doSend(filteredEvent, next);
          }
        }
      };
      var CachingNotificationFileOperationFeature = class extends NotificationFileOperationFeature {
        constructor() {
          super(...arguments);
          this._fsPathFileTypes = /* @__PURE__ */ new Map();
        }
        async getFileType(uri) {
          const fsPath = uri.fsPath;
          if (this._fsPathFileTypes.has(fsPath)) {
            return this._fsPathFileTypes.get(fsPath);
          }
          const type = await FileOperationFeature.getFileType(uri);
          if (type) {
            this._fsPathFileTypes.set(fsPath, type);
          }
          return type;
        }
        async cacheFileTypes(event, prop) {
          await this.filter(event, prop);
        }
        clearFileTypeCache() {
          this._fsPathFileTypes.clear();
        }
        unregister(id) {
          super.unregister(id);
          if (this.filterSize() === 0 && this._willListener) {
            this._willListener.dispose();
            this._willListener = void 0;
          }
        }
        dispose() {
          super.dispose();
          if (this._willListener) {
            this._willListener.dispose();
            this._willListener = void 0;
          }
        }
      };
      var DidCreateFilesFeature = class extends NotificationFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, "didCreate", "didCreate", (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
        }
        doSend(event, next) {
          const middleware = this._client.middleware.workspace;
          return middleware?.didCreateFiles ? middleware.didCreateFiles(event, next) : next(event);
        }
      };
      exports.DidCreateFilesFeature = DidCreateFilesFeature;
      var DidRenameFilesFeature = class extends CachingNotificationFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, "didRename", "didRename", (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
        }
        register(data) {
          if (!this._willListener) {
            this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
          }
          super.register(data);
        }
        willRename(e) {
          e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
        }
        doSend(event, next) {
          this.clearFileTypeCache();
          const middleware = this._client.middleware.workspace;
          return middleware?.didRenameFiles ? middleware.didRenameFiles(event, next) : next(event);
        }
      };
      exports.DidRenameFilesFeature = DidRenameFilesFeature;
      var DidDeleteFilesFeature = class extends CachingNotificationFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, "didDelete", "didDelete", (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
        }
        register(data) {
          if (!this._willListener) {
            this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
          }
          super.register(data);
        }
        willDelete(e) {
          e.waitUntil(this.cacheFileTypes(e, (i) => i));
        }
        doSend(event, next) {
          this.clearFileTypeCache();
          const middleware = this._client.middleware.workspace;
          return middleware?.didDeleteFiles ? middleware.didDeleteFiles(event, next) : next(event);
        }
      };
      exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
      var RequestFileOperationFeature = class extends FileOperationFeature {
        constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
          super(client, event, requestType, clientCapability, serverCapability);
          this._requestType = requestType;
          this._accessUri = accessUri;
          this._createParams = createParams;
        }
        async send(originalEvent) {
          const waitUntil = this.waitUntil(originalEvent);
          originalEvent.waitUntil(waitUntil);
        }
        async waitUntil(originalEvent) {
          const filteredEvent = await this.filter(originalEvent, this._accessUri);
          if (filteredEvent.files.length) {
            const next = (event) => {
              return this._client.sendRequest(this._requestType, this._createParams(event), event.token).then(this._client.protocol2CodeConverter.asWorkspaceEdit);
            };
            return this.doSend(filteredEvent, next);
          } else {
            return void 0;
          }
        }
      };
      var WillCreateFilesFeature = class extends RequestFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, "willCreate", "willCreate", (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
        }
        doSend(event, next) {
          const middleware = this._client.middleware.workspace;
          return middleware?.willCreateFiles ? middleware.willCreateFiles(event, next) : next(event);
        }
      };
      exports.WillCreateFilesFeature = WillCreateFilesFeature;
      var WillRenameFilesFeature = class extends RequestFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, "willRename", "willRename", (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
        }
        doSend(event, next) {
          const middleware = this._client.middleware.workspace;
          return middleware?.willRenameFiles ? middleware.willRenameFiles(event, next) : next(event);
        }
      };
      exports.WillRenameFilesFeature = WillRenameFilesFeature;
      var WillDeleteFilesFeature = class extends RequestFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, "willDelete", "willDelete", (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
        }
        doSend(event, next) {
          const middleware = this._client.middleware.workspace;
          return middleware?.willDeleteFiles ? middleware.willDeleteFiles(event, next) : next(event);
        }
      };
      exports.WillDeleteFilesFeature = WillDeleteFilesFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/linkedEditingRange.js
  var require_linkedEditingRange = __commonJS({
    "node_modules/vscode-languageclient/lib/common/linkedEditingRange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LinkedEditingFeature = void 0;
      var code = __require("vscode");
      var proto = require_main8();
      var features_1 = require_features();
      var LinkedEditingFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, proto.LinkedEditingRangeRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const linkedEditingSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "linkedEditingRange");
          linkedEditingSupport.dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideLinkedEditingRanges: (document2, position, token) => {
              const client = this._client;
              const provideLinkedEditing = (document3, position2, token2) => {
                return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asLinkedEditingRanges(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document2, position, token, provideLinkedEditing) : provideLinkedEditing(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return code.languages.registerLinkedEditingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.LinkedEditingFeature = LinkedEditingFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/typeHierarchy.js
  var require_typeHierarchy = __commonJS({
    "node_modules/vscode-languageclient/lib/common/typeHierarchy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeHierarchyFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var TypeHierarchyProvider = class {
        constructor(client) {
          this.client = client;
          this.middleware = client.middleware;
        }
        prepareTypeHierarchy(document2, position, token) {
          const client = this.client;
          const middleware = this.middleware;
          const prepareTypeHierarchy = (document3, position2, token2) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, token2, error, null);
            });
          };
          return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document2, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document2, position, token);
        }
        provideTypeHierarchySupertypes(item, token) {
          const client = this.client;
          const middleware = this.middleware;
          const provideTypeHierarchySupertypes = (item2, token2) => {
            const params = {
              item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, token2, error, null);
            });
          };
          return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
        }
        provideTypeHierarchySubtypes(item, token) {
          const client = this.client;
          const middleware = this.middleware;
          const provideTypeHierarchySubtypes = (item2, token2) => {
            const params = {
              item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, token2, error, null);
            });
          };
          return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
        }
      };
      var TypeHierarchyFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeHierarchy");
          capability.dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const [id, options] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const client = this._client;
          const provider = new TypeHierarchyProvider(client);
          return [vscode_1.languages.registerTypeHierarchyProvider(client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
        }
      };
      exports.TypeHierarchyFeature = TypeHierarchyFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/inlineValue.js
  var require_inlineValue = __commonJS({
    "node_modules/vscode-languageclient/lib/common/inlineValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InlineValueFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var InlineValueFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.InlineValueRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlineValue").dynamicRegistration = true;
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlineValue").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          this._client.onRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeInlineValues.fire();
            }
          });
          const [id, options] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const eventEmitter = new vscode_1.EventEmitter();
          const provider = {
            onDidChangeInlineValues: eventEmitter.event,
            provideInlineValues: (document2, viewPort, context, token) => {
              const client = this._client;
              const provideInlineValues = (document3, viewPort2, context2, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client.code2ProtocolConverter.asRange(viewPort2),
                  context: client.code2ProtocolConverter.asInlineValueContext(context2)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, requestParams, token2).then((values) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asInlineValues(values, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideInlineValues ? middleware.provideInlineValues(document2, viewPort, context, token, provideInlineValues) : provideInlineValues(document2, viewPort, context, token);
            }
          };
          return [this.registerProvider(selector, provider), { provider, onDidChangeInlineValues: eventEmitter }];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerInlineValuesProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.InlineValueFeature = InlineValueFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/inlayHint.js
  var require_inlayHint = __commonJS({
    "node_modules/vscode-languageclient/lib/common/inlayHint.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InlayHintsFeature = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var features_1 = require_features();
      var InlayHintsFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.InlayHintRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const inlayHint = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlayHint");
          inlayHint.dynamicRegistration = true;
          inlayHint.resolveSupport = {
            properties: ["tooltip", "textEdits", "label.tooltip", "label.location", "label.command"]
          };
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlayHint").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          this._client.onRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeInlayHints.fire();
            }
          });
          const [id, options] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
          if (!id || !options) {
            return;
          }
          this.register({ id, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const eventEmitter = new vscode_1.EventEmitter();
          const provider = {
            onDidChangeInlayHints: eventEmitter.event,
            provideInlayHints: (document2, viewPort, token) => {
              const client = this._client;
              const provideInlayHints = async (document3, viewPort2, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client.code2ProtocolConverter.asRange(viewPort2)
                };
                try {
                  const values = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, requestParams, token2);
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asInlayHints(values, token2);
                } catch (error) {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, token2, error, null);
                }
              };
              const middleware = client.middleware;
              return middleware.provideInlayHints ? middleware.provideInlayHints(document2, viewPort, token, provideInlayHints) : provideInlayHints(document2, viewPort, token);
            }
          };
          provider.resolveInlayHint = options.resolveProvider === true ? (hint, token) => {
            const client = this._client;
            const resolveInlayHint = async (item, token2) => {
              try {
                const value = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, client.code2ProtocolConverter.asInlayHint(item), token2);
                if (token2.isCancellationRequested) {
                  return null;
                }
                const result = client.protocol2CodeConverter.asInlayHint(value, token2);
                return token2.isCancellationRequested ? null : result;
              } catch (error) {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, token2, error, null);
              }
            };
            const middleware = client.middleware;
            return middleware.resolveInlayHint ? middleware.resolveInlayHint(hint, token, resolveInlayHint) : resolveInlayHint(hint, token);
          } : void 0;
          return [this.registerProvider(selector, provider), { provider, onDidChangeInlayHints: eventEmitter }];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerInlayHintsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports.InlayHintsFeature = InlayHintsFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/client.js
  var require_client = __commonJS({
    "node_modules/vscode-languageclient/lib/common/client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProposedFeatures = exports.BaseLanguageClient = exports.MessageTransports = exports.SuspendMode = exports.State = exports.CloseAction = exports.ErrorAction = exports.RevealOutputChannelOn = void 0;
      var vscode_1 = __require("vscode");
      var vscode_languageserver_protocol_1 = require_main8();
      var c2p = require_codeConverter();
      var p2c = require_protocolConverter();
      var Is2 = require_is7();
      var async_1 = require_async();
      var UUID = require_uuid();
      var progressPart_1 = require_progressPart();
      var features_1 = require_features();
      var diagnostic_1 = require_diagnostic();
      var notebook_1 = require_notebook();
      var configuration_1 = require_configuration();
      var textSynchronization_1 = require_textSynchronization();
      var completion_1 = require_completion();
      var hover_1 = require_hover();
      var definition_1 = require_definition();
      var signatureHelp_1 = require_signatureHelp();
      var documentHighlight_1 = require_documentHighlight();
      var documentSymbol_1 = require_documentSymbol();
      var workspaceSymbol_1 = require_workspaceSymbol();
      var reference_1 = require_reference();
      var codeAction_1 = require_codeAction();
      var codeLens_1 = require_codeLens();
      var formatting_1 = require_formatting();
      var rename_1 = require_rename();
      var documentLink_1 = require_documentLink();
      var executeCommand_1 = require_executeCommand();
      var fileSystemWatcher_1 = require_fileSystemWatcher();
      var colorProvider_1 = require_colorProvider();
      var configuration_2 = require_configuration();
      var implementation_1 = require_implementation();
      var typeDefinition_1 = require_typeDefinition();
      var workspaceFolder_1 = require_workspaceFolder();
      var foldingRange_1 = require_foldingRange();
      var declaration_1 = require_declaration();
      var selectionRange_1 = require_selectionRange();
      var progress_1 = require_progress();
      var callHierarchy_1 = require_callHierarchy();
      var semanticTokens_1 = require_semanticTokens();
      var fileOperations_1 = require_fileOperations();
      var linkedEditingRange_1 = require_linkedEditingRange();
      var typeHierarchy_1 = require_typeHierarchy();
      var inlineValue_1 = require_inlineValue();
      var inlayHint_1 = require_inlayHint();
      var RevealOutputChannelOn;
      (function(RevealOutputChannelOn2) {
        RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
        RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
        RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
        RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
      })(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
      var ErrorAction2;
      (function(ErrorAction3) {
        ErrorAction3[ErrorAction3["Continue"] = 1] = "Continue";
        ErrorAction3[ErrorAction3["Shutdown"] = 2] = "Shutdown";
      })(ErrorAction2 = exports.ErrorAction || (exports.ErrorAction = {}));
      var CloseAction2;
      (function(CloseAction3) {
        CloseAction3[CloseAction3["DoNotRestart"] = 1] = "DoNotRestart";
        CloseAction3[CloseAction3["Restart"] = 2] = "Restart";
      })(CloseAction2 = exports.CloseAction || (exports.CloseAction = {}));
      var State;
      (function(State2) {
        State2[State2["Stopped"] = 1] = "Stopped";
        State2[State2["Starting"] = 3] = "Starting";
        State2[State2["Running"] = 2] = "Running";
      })(State = exports.State || (exports.State = {}));
      var SuspendMode;
      (function(SuspendMode2) {
        SuspendMode2["off"] = "off";
        SuspendMode2["on"] = "on";
      })(SuspendMode = exports.SuspendMode || (exports.SuspendMode = {}));
      var DefaultErrorHandler = class {
        constructor(client, maxRestartCount) {
          this.client = client;
          this.maxRestartCount = maxRestartCount;
          this.restarts = [];
        }
        error(_error, _message, count) {
          if (count && count <= 3) {
            return { action: ErrorAction2.Continue };
          }
          return { action: ErrorAction2.Shutdown };
        }
        closed() {
          this.restarts.push(Date.now());
          if (this.restarts.length <= this.maxRestartCount) {
            return { action: CloseAction2.Restart };
          } else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1e3) {
              return { action: CloseAction2.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
            } else {
              this.restarts.shift();
              return { action: CloseAction2.Restart };
            }
          }
        }
      };
      var ClientState;
      (function(ClientState2) {
        ClientState2["Initial"] = "initial";
        ClientState2["Starting"] = "starting";
        ClientState2["StartFailed"] = "startFailed";
        ClientState2["Running"] = "running";
        ClientState2["Stopping"] = "stopping";
        ClientState2["Stopped"] = "stopped";
      })(ClientState || (ClientState = {}));
      var MessageTransports;
      (function(MessageTransports2) {
        function is(value) {
          let candidate = value;
          return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
        }
        MessageTransports2.is = is;
      })(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
      var BaseLanguageClient = class _BaseLanguageClient {
        constructor(id, name, clientOptions) {
          this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
          this._diagnosticQueue = /* @__PURE__ */ new Map();
          this._diagnosticQueueState = { state: "idle" };
          this._features = [];
          this._dynamicFeatures = /* @__PURE__ */ new Map();
          this.workspaceEditLock = new async_1.Semaphore(1);
          this._id = id;
          this._name = name;
          clientOptions = clientOptions || {};
          const markdown = { isTrusted: false, supportHtml: false };
          if (clientOptions.markdown !== void 0) {
            markdown.isTrusted = clientOptions.markdown.isTrusted === true;
            markdown.supportHtml = clientOptions.markdown.supportHtml === true;
          }
          this._clientOptions = {
            documentSelector: clientOptions.documentSelector ?? [],
            synchronize: clientOptions.synchronize ?? {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName ?? this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
            middleware: clientOptions.middleware ?? {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder,
            connectionOptions: clientOptions.connectionOptions,
            markdown,
            // suspend: {
            // 	mode: clientOptions.suspend?.mode ?? SuspendMode.off,
            // 	callback: clientOptions.suspend?.callback ?? (() => Promise.resolve(true)),
            // 	interval: clientOptions.suspend?.interval ? Math.max(clientOptions.suspend.interval, defaultInterval) : defaultInterval
            // },
            diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false },
            notebookDocumentOptions: clientOptions.notebookDocumentOptions ?? {}
          };
          this._clientOptions.synchronize = this._clientOptions.synchronize || {};
          this._state = ClientState.Initial;
          this._ignoredRegistrations = /* @__PURE__ */ new Set();
          this._notificationHandlers = /* @__PURE__ */ new Map();
          this._pendingNotificationHandlers = /* @__PURE__ */ new Map();
          this._notificationDisposables = /* @__PURE__ */ new Map();
          this._requestHandlers = /* @__PURE__ */ new Map();
          this._pendingRequestHandlers = /* @__PURE__ */ new Map();
          this._requestDisposables = /* @__PURE__ */ new Map();
          this._progressHandlers = /* @__PURE__ */ new Map();
          this._pendingProgressHandlers = /* @__PURE__ */ new Map();
          this._progressDisposables = /* @__PURE__ */ new Map();
          this._connection = void 0;
          this._initializeResult = void 0;
          if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
          } else {
            this._outputChannel = void 0;
            this._disposeOutputChannel = true;
          }
          this._traceOutputChannel = clientOptions.traceOutputChannel;
          this._diagnostics = void 0;
          this._fileEvents = [];
          this._fileEventDelayer = new async_1.Delayer(250);
          this._onStop = void 0;
          this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
          this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
          this._trace = vscode_languageserver_protocol_1.Trace.Off;
          this._tracer = {
            log: (messageOrDataObject, data) => {
              if (Is2.string(messageOrDataObject)) {
                this.logTrace(messageOrDataObject, data);
              } else {
                this.logObjectTrace(messageOrDataObject);
              }
            }
          };
          this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : void 0);
          this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : void 0, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
          this._syncedDocuments = /* @__PURE__ */ new Map();
          this.registerBuiltinFeatures();
        }
        get name() {
          return this._name;
        }
        get middleware() {
          return this._clientOptions.middleware ?? /* @__PURE__ */ Object.create(null);
        }
        get clientOptions() {
          return this._clientOptions;
        }
        get protocol2CodeConverter() {
          return this._p2c;
        }
        get code2ProtocolConverter() {
          return this._c2p;
        }
        get onTelemetry() {
          return this._telemetryEmitter.event;
        }
        get onDidChangeState() {
          return this._stateChangeEmitter.event;
        }
        get outputChannel() {
          if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
          }
          return this._outputChannel;
        }
        get traceOutputChannel() {
          if (this._traceOutputChannel) {
            return this._traceOutputChannel;
          }
          return this.outputChannel;
        }
        get diagnostics() {
          return this._diagnostics;
        }
        get state() {
          return this.getPublicState();
        }
        get $state() {
          return this._state;
        }
        set $state(value) {
          let oldState = this.getPublicState();
          this._state = value;
          let newState = this.getPublicState();
          if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
          }
        }
        getPublicState() {
          switch (this.$state) {
            case ClientState.Starting:
              return State.Starting;
            case ClientState.Running:
              return State.Running;
            default:
              return State.Stopped;
          }
        }
        get initializeResult() {
          return this._initializeResult;
        }
        async sendRequest(type, ...params) {
          if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
          }
          try {
            const connection = await this.$start();
            this.forceDocumentSync();
            return connection.sendRequest(type, ...params);
          } catch (error) {
            this.error(`Sending request ${Is2.string(type) ? type : type.method} failed.`, error);
            throw error;
          }
        }
        onRequest(type, handler) {
          const method = typeof type === "string" ? type : type.method;
          this._requestHandlers.set(method, handler);
          const connection = this.activeConnection();
          let disposable;
          if (connection !== void 0) {
            this._requestDisposables.set(method, connection.onRequest(type, handler));
            disposable = {
              dispose: () => {
                const disposable2 = this._requestDisposables.get(method);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._requestDisposables.delete(method);
                }
              }
            };
          } else {
            this._pendingRequestHandlers.set(method, handler);
            disposable = {
              dispose: () => {
                this._pendingRequestHandlers.delete(method);
                const disposable2 = this._requestDisposables.get(method);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._requestDisposables.delete(method);
                }
              }
            };
          }
          return {
            dispose: () => {
              this._requestHandlers.delete(method);
              disposable.dispose();
            }
          };
        }
        async sendNotification(type, params) {
          if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
          }
          try {
            const connection = await this.$start();
            this.forceDocumentSync();
            return connection.sendNotification(type, params);
          } catch (error) {
            this.error(`Sending notification ${Is2.string(type) ? type : type.method} failed.`, error);
            throw error;
          }
        }
        onNotification(type, handler) {
          const method = typeof type === "string" ? type : type.method;
          this._notificationHandlers.set(method, handler);
          const connection = this.activeConnection();
          let disposable;
          if (connection !== void 0) {
            this._notificationDisposables.set(method, connection.onNotification(type, handler));
            disposable = {
              dispose: () => {
                const disposable2 = this._notificationDisposables.get(method);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._notificationDisposables.delete(method);
                }
              }
            };
          } else {
            this._pendingNotificationHandlers.set(method, handler);
            disposable = {
              dispose: () => {
                this._pendingNotificationHandlers.delete(method);
                const disposable2 = this._notificationDisposables.get(method);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._notificationDisposables.delete(method);
                }
              }
            };
          }
          return {
            dispose: () => {
              this._notificationHandlers.delete(method);
              disposable.dispose();
            }
          };
        }
        async sendProgress(type, token, value) {
          try {
            const connection = await this.$start();
            return connection.sendProgress(type, token, value);
          } catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
          }
        }
        onProgress(type, token, handler) {
          this._progressHandlers.set(token, { type, handler });
          const connection = this.activeConnection();
          let disposable;
          const handleWorkDoneProgress = this._clientOptions.middleware?.handleWorkDoneProgress;
          const realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? (params) => {
            handleWorkDoneProgress(token, params, () => handler(params));
          } : handler;
          if (connection !== void 0) {
            this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
            disposable = {
              dispose: () => {
                const disposable2 = this._progressDisposables.get(token);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._progressDisposables.delete(token);
                }
              }
            };
          } else {
            this._pendingProgressHandlers.set(token, { type, handler });
            disposable = {
              dispose: () => {
                this._pendingProgressHandlers.delete(token);
                const disposable2 = this._progressDisposables.get(token);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._progressDisposables.delete(token);
                }
              }
            };
          }
          return {
            dispose: () => {
              this._progressHandlers.delete(token);
              disposable.dispose();
            }
          };
        }
        createDefaultErrorHandler(maxRestartCount) {
          if (maxRestartCount !== void 0 && maxRestartCount < 0) {
            throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
          }
          return new DefaultErrorHandler(this, maxRestartCount ?? 4);
        }
        async setTrace(value) {
          this._trace = value;
          const connection = this.activeConnection();
          if (connection !== void 0) {
            await connection.trace(this._trace, this._tracer, {
              sendNotification: false,
              traceFormat: this._traceFormat
            });
          }
        }
        data2String(data) {
          if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
          }
          if (data instanceof Error) {
            if (Is2.string(data.stack)) {
              return data.stack;
            }
            return data.message;
          }
          if (Is2.string(data)) {
            return data;
          }
          return data.toString();
        }
        info(message, data, showNotification = true) {
          this.outputChannel.appendLine(`[Info  - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
          if (data !== null && data !== void 0) {
            this.outputChannel.appendLine(this.data2String(data));
          }
          if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Info, message);
          }
        }
        warn(message, data, showNotification = true) {
          this.outputChannel.appendLine(`[Warn  - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
          if (data !== null && data !== void 0) {
            this.outputChannel.appendLine(this.data2String(data));
          }
          if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Warning, message);
          }
        }
        error(message, data, showNotification = true) {
          this.outputChannel.appendLine(`[Error - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
          if (data !== null && data !== void 0) {
            this.outputChannel.appendLine(this.data2String(data));
          }
          if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Error, message);
          }
        }
        showNotificationMessage(type, message) {
          message = message ?? "A request has failed. See the output for more information.";
          const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error ? vscode_1.window.showErrorMessage : type === vscode_languageserver_protocol_1.MessageType.Warning ? vscode_1.window.showWarningMessage : vscode_1.window.showInformationMessage;
          void messageFunc(message, "Go to output").then((selection) => {
            if (selection !== void 0) {
              this.outputChannel.show(true);
            }
          });
        }
        logTrace(message, data) {
          this.traceOutputChannel.appendLine(`[Trace - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
          if (data) {
            this.traceOutputChannel.appendLine(this.data2String(data));
          }
        }
        logObjectTrace(data) {
          if (data.isLSPMessage && data.type) {
            this.traceOutputChannel.append(`[LSP   - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] `);
          } else {
            this.traceOutputChannel.append(`[Trace - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] `);
          }
          if (data) {
            this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
          }
        }
        needsStart() {
          return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
        }
        needsStop() {
          return this.$state === ClientState.Starting || this.$state === ClientState.Running;
        }
        activeConnection() {
          return this.$state === ClientState.Running && this._connection !== void 0 ? this._connection : void 0;
        }
        isRunning() {
          return this.$state === ClientState.Running;
        }
        async start() {
          if (this._onStart !== void 0) {
            return this._onStart;
          }
          const [promise, resolve, reject] = this.createOnStartPromise();
          this._onStart = promise;
          if (this._onStop !== void 0) {
            await this._onStop;
            this._onStop = void 0;
          }
          if (this._diagnostics === void 0) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName) : vscode_1.languages.createDiagnosticCollection();
          }
          for (const [method, handler] of this._notificationHandlers) {
            if (!this._pendingNotificationHandlers.has(method)) {
              this._pendingNotificationHandlers.set(method, handler);
            }
          }
          for (const [method, handler] of this._requestHandlers) {
            if (!this._pendingRequestHandlers.has(method)) {
              this._pendingRequestHandlers.set(method, handler);
            }
          }
          for (const [token, data] of this._progressHandlers) {
            if (!this._pendingProgressHandlers.has(token)) {
              this._pendingProgressHandlers.set(token, data);
            }
          }
          this.$state = ClientState.Starting;
          try {
            const connection = await this.createConnection();
            connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, (message) => {
              switch (message.type) {
                case vscode_languageserver_protocol_1.MessageType.Error:
                  this.error(message.message, void 0, false);
                  break;
                case vscode_languageserver_protocol_1.MessageType.Warning:
                  this.warn(message.message, void 0, false);
                  break;
                case vscode_languageserver_protocol_1.MessageType.Info:
                  this.info(message.message, void 0, false);
                  break;
                default:
                  this.outputChannel.appendLine(message.message);
              }
            });
            connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, (message) => {
              switch (message.type) {
                case vscode_languageserver_protocol_1.MessageType.Error:
                  void vscode_1.window.showErrorMessage(message.message);
                  break;
                case vscode_languageserver_protocol_1.MessageType.Warning:
                  void vscode_1.window.showWarningMessage(message.message);
                  break;
                case vscode_languageserver_protocol_1.MessageType.Info:
                  void vscode_1.window.showInformationMessage(message.message);
                  break;
                default:
                  void vscode_1.window.showInformationMessage(message.message);
              }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
              let messageFunc;
              switch (params.type) {
                case vscode_languageserver_protocol_1.MessageType.Error:
                  messageFunc = vscode_1.window.showErrorMessage;
                  break;
                case vscode_languageserver_protocol_1.MessageType.Warning:
                  messageFunc = vscode_1.window.showWarningMessage;
                  break;
                case vscode_languageserver_protocol_1.MessageType.Info:
                  messageFunc = vscode_1.window.showInformationMessage;
                  break;
                default:
                  messageFunc = vscode_1.window.showInformationMessage;
              }
              let actions = params.actions || [];
              return messageFunc(params.message, ...actions);
            });
            connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, (data) => {
              this._telemetryEmitter.fire(data);
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
              const showDocument = async (params2) => {
                const uri = this.protocol2CodeConverter.asUri(params2.uri);
                try {
                  if (params2.external === true) {
                    const success = await vscode_1.env.openExternal(uri);
                    return { success };
                  } else {
                    const options = {};
                    if (params2.selection !== void 0) {
                      options.selection = this.protocol2CodeConverter.asRange(params2.selection);
                    }
                    if (params2.takeFocus === void 0 || params2.takeFocus === false) {
                      options.preserveFocus = true;
                    } else if (params2.takeFocus === true) {
                      options.preserveFocus = false;
                    }
                    await vscode_1.window.showTextDocument(uri, options);
                    return { success: true };
                  }
                } catch (error) {
                  return { success: true };
                }
              };
              const middleware = this._clientOptions.middleware.window?.showDocument;
              if (middleware !== void 0) {
                return middleware(params, showDocument);
              } else {
                return showDocument(params);
              }
            });
            connection.listen();
            await this.initialize(connection);
            resolve();
          } catch (error) {
            this.$state = ClientState.StartFailed;
            this.error(`${this._name} client: couldn't create connection to server.`, error, "force");
            reject(error);
          }
          return this._onStart;
        }
        createOnStartPromise() {
          let resolve;
          let reject;
          const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
          });
          return [promise, resolve, reject];
        }
        async initialize(connection) {
          this.refreshTrace(connection, false);
          const initOption = this._clientOptions.initializationOptions;
          const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== void 0 ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]] : [this._clientGetRootPath(), null];
          const initParams = {
            processId: null,
            clientInfo: {
              name: vscode_1.env.appName,
              version: vscode_1.version
            },
            locale: this.getLocale(),
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is2.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders
          };
          this.fillInitializeParams(initParams);
          if (this._clientOptions.progressOnInitialization) {
            const token = UUID.generateUuid();
            const part = new progressPart_1.ProgressPart(connection, token);
            initParams.workDoneToken = token;
            try {
              const result = await this.doInitialize(connection, initParams);
              part.done();
              return result;
            } catch (error) {
              part.cancel();
              throw error;
            }
          } else {
            return this.doInitialize(connection, initParams);
          }
        }
        async doInitialize(connection, initParams) {
          try {
            const result = await connection.initialize(initParams);
            if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) {
              throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
            }
            this._initializeResult = result;
            this.$state = ClientState.Running;
            let textDocumentSyncOptions = void 0;
            if (Is2.number(result.capabilities.textDocumentSync)) {
              if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                textDocumentSyncOptions = {
                  openClose: false,
                  change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                  save: void 0
                };
              } else {
                textDocumentSyncOptions = {
                  openClose: true,
                  change: result.capabilities.textDocumentSync,
                  save: {
                    includeText: false
                  }
                };
              }
            } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
              textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, (params) => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
            connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
            connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
            for (const [method, handler] of this._pendingNotificationHandlers) {
              this._notificationDisposables.set(method, connection.onNotification(method, handler));
            }
            this._pendingNotificationHandlers.clear();
            for (const [method, handler] of this._pendingRequestHandlers) {
              this._requestDisposables.set(method, connection.onRequest(method, handler));
            }
            this._pendingRequestHandlers.clear();
            for (const [token, data] of this._pendingProgressHandlers) {
              this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
            }
            this._pendingProgressHandlers.clear();
            await connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            return result;
          } catch (error) {
            if (this._clientOptions.initializationFailedHandler) {
              if (this._clientOptions.initializationFailedHandler(error)) {
                void this.initialize(connection);
              } else {
                void this.stop();
              }
            } else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
              void vscode_1.window.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
                if (item && item.id === "retry") {
                  void this.initialize(connection);
                } else {
                  void this.stop();
                }
              });
            } else {
              if (error && error.message) {
                void vscode_1.window.showErrorMessage(error.message);
              }
              this.error("Server initialization failed.", error);
              void this.stop();
            }
            throw error;
          }
        }
        _clientGetRootPath() {
          let folders = vscode_1.workspace.workspaceFolders;
          if (!folders || folders.length === 0) {
            return void 0;
          }
          let folder = folders[0];
          if (folder.uri.scheme === "file") {
            return folder.uri.fsPath;
          }
          return void 0;
        }
        stop(timeout = 2e3) {
          return this.shutdown("stop", timeout);
        }
        suspend() {
          return this.shutdown("suspend", 5e3);
        }
        async shutdown(mode, timeout) {
          if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
            return;
          }
          if (this.$state === ClientState.Stopping && this._onStop) {
            return this._onStop;
          }
          const connection = await this.$start();
          this._initializeResult = void 0;
          this.$state = ClientState.Stopping;
          this.cleanUp(mode);
          const tp = new Promise((c) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout);
          });
          const shutdown = (async (connection2) => {
            await connection2.shutdown();
            await connection2.exit();
            return connection2;
          })(connection);
          return this._onStop = Promise.race([tp, shutdown]).then((connection2) => {
            if (connection2 !== void 0) {
              connection2.end();
              connection2.dispose();
            } else {
              this.error(`Stopping server timed out`, void 0, false);
              throw new Error(`Stopping the server timed out`);
            }
          }, (error) => {
            this.error(`Stopping server failed`, error, false);
            throw error;
          }).finally(() => {
            this.$state = ClientState.Stopped;
            mode === "stop" && this.cleanUpChannel();
            this._onStart = void 0;
            this._onStop = void 0;
            this._connection = void 0;
            this._ignoredRegistrations.clear();
          });
        }
        cleanUp(mode) {
          this._fileEvents = [];
          this._fileEventDelayer.cancel();
          if (this._syncedDocuments) {
            this._syncedDocuments.clear();
          }
          for (const feature of Array.from(this._features.entries()).map((entry) => entry[1]).reverse()) {
            feature.dispose();
          }
          if (mode === "stop" && this._diagnostics !== void 0) {
            this._diagnostics.dispose();
            this._diagnostics = void 0;
          }
          if (this._idleInterval !== void 0) {
            this._idleInterval.dispose();
            this._idleInterval = void 0;
          }
        }
        cleanUpChannel() {
          if (this._outputChannel !== void 0 && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = void 0;
          }
        }
        notifyFileEvent(event) {
          const client = this;
          async function didChangeWatchedFile(event2) {
            client._fileEvents.push(event2);
            return client._fileEventDelayer.trigger(async () => {
              const connection = await client.$start();
              client.forceDocumentSync();
              const result = connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, { changes: client._fileEvents });
              client._fileEvents = [];
              return result;
            });
          }
          const workSpaceMiddleware = this.clientOptions.middleware?.workspace;
          (workSpaceMiddleware?.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
            client.error(`Notify file events failed.`, error);
          });
        }
        forceDocumentSync() {
          if (this._didChangeTextDocumentFeature === void 0) {
            this._didChangeTextDocumentFeature = this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method);
          }
          this._didChangeTextDocumentFeature.forceDelivery();
        }
        handleDiagnostics(params) {
          if (!this._diagnostics) {
            return;
          }
          const key = params.uri;
          if (this._diagnosticQueueState.state === "busy" && this._diagnosticQueueState.document === key) {
            this._diagnosticQueueState.tokenSource.cancel();
          }
          this._diagnosticQueue.set(params.uri, params.diagnostics);
          this.triggerDiagnosticQueue();
        }
        triggerDiagnosticQueue() {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
            this.workDiagnosticQueue();
          });
        }
        workDiagnosticQueue() {
          if (this._diagnosticQueueState.state === "busy") {
            return;
          }
          const next = this._diagnosticQueue.entries().next();
          if (next.done === true) {
            return;
          }
          const [document2, diagnostics] = next.value;
          this._diagnosticQueue.delete(document2);
          const tokenSource = new vscode_1.CancellationTokenSource();
          this._diagnosticQueueState = { state: "busy", document: document2, tokenSource };
          this._p2c.asDiagnostics(diagnostics, tokenSource.token).then((converted) => {
            if (!tokenSource.token.isCancellationRequested) {
              const uri = this._p2c.asUri(document2);
              const middleware = this.clientOptions.middleware;
              if (middleware.handleDiagnostics) {
                middleware.handleDiagnostics(uri, converted, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
              } else {
                this.setDiagnostics(uri, converted);
              }
            }
          }).finally(() => {
            this._diagnosticQueueState = { state: "idle" };
            this.triggerDiagnosticQueue();
          });
        }
        setDiagnostics(uri, diagnostics) {
          if (!this._diagnostics) {
            return;
          }
          this._diagnostics.set(uri, diagnostics);
        }
        async $start() {
          if (this.$state === ClientState.StartFailed) {
            throw new Error(`Previous start failed. Can't restart server.`);
          }
          await this.start();
          const connection = this.activeConnection();
          if (connection === void 0) {
            throw new Error(`Starting server failed`);
          }
          return connection;
        }
        async createConnection() {
          let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count);
          };
          let closeHandler = () => {
            this.handleConnectionClosed();
          };
          const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8");
          this._connection = createConnection2(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
          return this._connection;
        }
        handleConnectionClosed() {
          if (this.$state === ClientState.Stopped) {
            return;
          }
          try {
            if (this._connection !== void 0) {
              this._connection.dispose();
            }
          } catch (error) {
          }
          let handlerResult = { action: CloseAction2.DoNotRestart };
          if (this.$state !== ClientState.Stopping) {
            try {
              handlerResult = this._clientOptions.errorHandler.closed();
            } catch (error) {
            }
          }
          this._connection = void 0;
          if (handlerResult.action === CloseAction2.DoNotRestart) {
            this.error(handlerResult.message ?? "Connection to server got closed. Server will not be restarted.", void 0, "force");
            this.cleanUp("stop");
            if (this.$state === ClientState.Starting) {
              this.$state = ClientState.StartFailed;
            } else {
              this.$state = ClientState.Stopped;
            }
            this._onStop = Promise.resolve();
            this._onStart = void 0;
          } else if (handlerResult.action === CloseAction2.Restart) {
            this.info(handlerResult.message ?? "Connection to server got closed. Server will restart.");
            this.cleanUp("restart");
            this.$state = ClientState.Initial;
            this._onStop = Promise.resolve();
            this._onStart = void 0;
            this.start().catch((error) => this.error(`Restarting server failed`, error, "force"));
          }
        }
        handleConnectionError(error, message, count) {
          const handlerResult = this._clientOptions.errorHandler.error(error, message, count);
          if (handlerResult.action === ErrorAction2.Shutdown) {
            this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring. Shutting down server.`, void 0, "force");
            this.stop().catch((error2) => {
              this.error(`Stopping server failed`, error2, false);
            });
          }
        }
        hookConfigurationChanged(connection) {
          vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
          });
        }
        refreshTrace(connection, sendNotification = false) {
          const config = vscode_1.workspace.getConfiguration(this._id);
          let trace = vscode_languageserver_protocol_1.Trace.Off;
          let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
          if (config) {
            const traceConfig = config.get("trace.server", "off");
            if (typeof traceConfig === "string") {
              trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            } else {
              trace = vscode_languageserver_protocol_1.Trace.fromString(config.get("trace.server.verbosity", "off"));
              traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get("trace.server.format", "text"));
            }
          }
          this._trace = trace;
          this._traceFormat = traceFormat;
          connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
          }).catch((error) => {
            this.error(`Updating trace failed with error`, error, false);
          });
        }
        hookFileEvents(_connection) {
          let fileEvents = this._clientOptions.synchronize.fileEvents;
          if (!fileEvents) {
            return;
          }
          let watchers;
          if (Is2.array(fileEvents)) {
            watchers = fileEvents;
          } else {
            watchers = [fileEvents];
          }
          if (!watchers) {
            return;
          }
          this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
        }
        registerFeatures(features) {
          for (let feature of features) {
            this.registerFeature(feature);
          }
        }
        registerFeature(feature) {
          this._features.push(feature);
          if (features_1.DynamicFeature.is(feature)) {
            const registrationType = feature.registrationType;
            this._dynamicFeatures.set(registrationType.method, feature);
          }
        }
        getFeature(request) {
          return this._dynamicFeatures.get(request);
        }
        hasDedicatedTextSynchronizationFeature(textDocument) {
          const feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
          if (feature === void 0 || !(feature instanceof notebook_1.NotebookDocumentSyncFeature)) {
            return false;
          }
          return feature.handles(textDocument);
        }
        registerBuiltinFeatures() {
          this.registerFeature(new configuration_1.ConfigurationFeature(this));
          this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments));
          this.registerFeature(new textSynchronization_1.DidChangeTextDocumentFeature(this));
          this.registerFeature(new textSynchronization_1.WillSaveFeature(this));
          this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this));
          this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this));
          this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments));
          this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
          this.registerFeature(new completion_1.CompletionItemFeature(this));
          this.registerFeature(new hover_1.HoverFeature(this));
          this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this));
          this.registerFeature(new definition_1.DefinitionFeature(this));
          this.registerFeature(new reference_1.ReferencesFeature(this));
          this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this));
          this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this));
          this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this));
          this.registerFeature(new codeAction_1.CodeActionFeature(this));
          this.registerFeature(new codeLens_1.CodeLensFeature(this));
          this.registerFeature(new formatting_1.DocumentFormattingFeature(this));
          this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this));
          this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this));
          this.registerFeature(new rename_1.RenameFeature(this));
          this.registerFeature(new documentLink_1.DocumentLinkFeature(this));
          this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this));
          this.registerFeature(new configuration_1.SyncConfigurationFeature(this));
          this.registerFeature(new configuration_2.ConfigurationFeature(this));
          this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
          this.registerFeature(new implementation_1.ImplementationFeature(this));
          this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
          if (this.clientOptions.workspaceFolder === void 0) {
            this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this));
          }
          this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
          this.registerFeature(new declaration_1.DeclarationFeature(this));
          this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
          this.registerFeature(new progress_1.ProgressFeature(this));
          this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
          this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
          this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
          this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
          this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
          this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
          this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
          this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
          this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
          this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this));
          this.registerFeature(new inlineValue_1.InlineValueFeature(this));
          this.registerFeature(new inlayHint_1.InlayHintsFeature(this));
          this.registerFeature(new diagnostic_1.DiagnosticFeature(this));
          this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
        }
        registerProposedFeatures() {
          this.registerFeatures(ProposedFeatures.createAll(this));
        }
        fillInitializeParams(params) {
          for (let feature of this._features) {
            if (Is2.func(feature.fillInitializeParams)) {
              feature.fillInitializeParams(params);
            }
          }
        }
        computeClientCapabilities() {
          const result = {};
          (0, features_1.ensure)(result, "workspace").applyEdit = true;
          const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, "workspace"), "workspaceEdit");
          workspaceEdit.documentChanges = true;
          workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
          workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
          workspaceEdit.normalizesLineEndings = true;
          workspaceEdit.changeAnnotationSupport = {
            groupsOnLabel: true
          };
          const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, "textDocument"), "publishDiagnostics");
          diagnostics.relatedInformation = true;
          diagnostics.versionSupport = false;
          diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
          diagnostics.codeDescriptionSupport = true;
          diagnostics.dataSupport = true;
          const windowCapabilities = (0, features_1.ensure)(result, "window");
          const showMessage = (0, features_1.ensure)(windowCapabilities, "showMessage");
          showMessage.messageActionItem = { additionalPropertiesSupport: true };
          const showDocument = (0, features_1.ensure)(windowCapabilities, "showDocument");
          showDocument.support = true;
          const generalCapabilities = (0, features_1.ensure)(result, "general");
          generalCapabilities.staleRequestSupport = {
            cancel: true,
            retryOnContentModified: Array.from(_BaseLanguageClient.RequestsToCancelOnContentModified)
          };
          generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
          generalCapabilities.markdown = {
            parser: "marked",
            version: "1.1.0"
          };
          generalCapabilities.positionEncodings = ["utf-16"];
          if (this._clientOptions.markdown.supportHtml) {
            generalCapabilities.markdown.allowedTags = ["ul", "li", "p", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"];
          }
          for (let feature of this._features) {
            feature.fillClientCapabilities(result);
          }
          return result;
        }
        initializeFeatures(_connection) {
          const documentSelector = this._clientOptions.documentSelector;
          for (const feature of this._features) {
            if (Is2.func(feature.preInitialize)) {
              feature.preInitialize(this._capabilities, documentSelector);
            }
          }
          for (const feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
          }
        }
        async handleRegistrationRequest(params) {
          if (!this.isRunning()) {
            for (const registration of params.registrations) {
              this._ignoredRegistrations.add(registration.id);
            }
            return;
          }
          for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (feature === void 0) {
              return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
            }
            const options = registration.registerOptions ?? {};
            options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
            const data = {
              id: registration.id,
              registerOptions: options
            };
            try {
              feature.register(data);
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }
        async handleUnregistrationRequest(params) {
          for (let unregistration of params.unregisterations) {
            if (this._ignoredRegistrations.has(unregistration.id)) {
              continue;
            }
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
              return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
            }
            feature.unregister(unregistration.id);
          }
        }
        async handleApplyWorkspaceEdit(params) {
          const workspaceEdit = params.edit;
          const converted = await this.workspaceEditLock.lock(() => {
            return this._p2c.asWorkspaceEdit(workspaceEdit);
          });
          const openTextDocuments = /* @__PURE__ */ new Map();
          vscode_1.workspace.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
          let versionMismatch = false;
          if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
              if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                const textDocument = openTextDocuments.get(change.textDocument.uri);
                if (textDocument && textDocument.version !== change.textDocument.version) {
                  versionMismatch = true;
                  break;
                }
              }
            }
          }
          if (versionMismatch) {
            return Promise.resolve({ applied: false });
          }
          return Is2.asPromise(vscode_1.workspace.applyEdit(converted).then((value) => {
            return { applied: value };
          }));
        }
        handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
          if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
            if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) {
              return defaultValue;
            }
            if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
              if (token !== void 0 && token.isCancellationRequested) {
                return defaultValue;
              } else {
                if (error.data !== void 0) {
                  throw new features_1.LSPCancellationError(error.data);
                } else {
                  throw new vscode_1.CancellationError();
                }
              }
            } else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
              if (_BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
                throw new vscode_1.CancellationError();
              } else {
                return defaultValue;
              }
            }
          }
          this.error(`Request ${type.method} failed.`, error, showNotification);
          throw error;
        }
      };
      exports.BaseLanguageClient = BaseLanguageClient;
      BaseLanguageClient.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
        vscode_languageserver_protocol_1.SemanticTokensRequest.method,
        vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
        vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
      ]);
      var ConsoleLogger2 = class {
        error(message) {
          (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
        }
        warn(message) {
          (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
        }
        info(message) {
          (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
        }
        log(message) {
          (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
        }
      };
      function createConnection2(input, output, errorHandler, closeHandler, options) {
        let _lastUsed = -1;
        const logger = new ConsoleLogger2();
        const connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
        connection.onError((data) => {
          errorHandler(data[0], data[1], data[2]);
        });
        connection.onClose(closeHandler);
        const result = {
          get lastUsed() {
            return _lastUsed;
          },
          resetLastUsed: () => {
            _lastUsed = -1;
          },
          listen: () => connection.listen(),
          sendRequest: (type, ...params) => {
            _lastUsed = Date.now();
            return connection.sendRequest(type, ...params);
          },
          onRequest: (type, handler) => connection.onRequest(type, handler),
          hasPendingResponse: () => connection.hasPendingResponse(),
          sendNotification: (type, params) => {
            _lastUsed = Date.now();
            return connection.sendNotification(type, params);
          },
          onNotification: (type, handler) => connection.onNotification(type, handler),
          onProgress: connection.onProgress,
          sendProgress: connection.sendProgress,
          trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
              sendNotification: false,
              traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === void 0) {
              return connection.trace(value, tracer, defaultTraceOptions);
            } else if (Is2.boolean(sendNotificationOrTraceOptions)) {
              return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            } else {
              return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
          },
          initialize: (params) => {
            _lastUsed = Date.now();
            return connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params);
          },
          shutdown: () => {
            _lastUsed = Date.now();
            return connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0);
          },
          exit: () => {
            _lastUsed = Date.now();
            return connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type);
          },
          end: () => connection.end(),
          dispose: () => connection.dispose()
        };
        return result;
      }
      var ProposedFeatures;
      (function(ProposedFeatures2) {
        function createAll(_client) {
          let result = [];
          return result;
        }
        ProposedFeatures2.createAll = createAll;
      })(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
    }
  });

  // node_modules/vscode-languageclient/lib/common/api.js
  var require_api7 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/api.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagnosticPullMode = exports.vsdiag = void 0;
      __exportStar2(require_main8(), exports);
      __exportStar2(require_features(), exports);
      var diagnostic_1 = require_diagnostic();
      Object.defineProperty(exports, "vsdiag", { enumerable: true, get: function() {
        return diagnostic_1.vsdiag;
      } });
      Object.defineProperty(exports, "DiagnosticPullMode", { enumerable: true, get: function() {
        return diagnostic_1.DiagnosticPullMode;
      } });
      __exportStar2(require_client(), exports);
    }
  });

  // node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/browser.js
  var require_browser3 = __commonJS({
    "node_modules/vscode-languageclient/node_modules/vscode-languageserver-protocol/browser.js"(exports, module) {
      "use strict";
      module.exports = require_main8();
    }
  });

  // node_modules/vscode-languageclient/lib/browser/main.js
  var require_main9 = __commonJS({
    "node_modules/vscode-languageclient/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LanguageClient = void 0;
      var api_1 = require_api7();
      var browser_1 = require_browser3();
      __exportStar2(require_browser3(), exports);
      __exportStar2(require_api7(), exports);
      var LanguageClient = class extends api_1.BaseLanguageClient {
        constructor(id, name, clientOptions, worker) {
          super(id, name, clientOptions);
          this.worker = worker;
        }
        createMessageTransports(_encoding) {
          const reader = new browser_1.BrowserMessageReader(this.worker);
          const writer = new browser_1.BrowserMessageWriter(this.worker);
          return Promise.resolve({ reader, writer });
        }
        getLocale() {
          return "en";
        }
      };
      exports.LanguageClient = LanguageClient;
    }
  });

  // node_modules/monaco-languageclient/lib/monaco-language-client.js
  var require_monaco_language_client = __commonJS({
    "node_modules/monaco-languageclient/lib/monaco-language-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MonacoLanguageClient = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var vscode_languageclient_1 = require_main9();
      tslib_1.__exportStar(require_client(), exports);
      var MonacoLanguageClient2 = class _MonacoLanguageClient extends vscode_languageclient_1.BaseLanguageClient {
        constructor({ id, name, clientOptions, connectionProvider }) {
          super(id || name.toLowerCase(), name, clientOptions);
          this.connectionProvider = connectionProvider;
          const self = this;
          self._p2c = new Proxy(self._p2c, {
            get: (target, prop) => {
              if (prop === "asUri") {
                return target[prop];
              }
              return _MonacoLanguageClient.bypassConversion;
            }
          });
          self._c2p = new Proxy(self._c2p, {
            get: (target, prop) => {
              if (prop === "asUri") {
                return target[prop];
              }
              if (prop === "asCompletionParams") {
                return (textDocument, position, context) => {
                  return {
                    textDocument: target.asTextDocumentIdentifier(textDocument),
                    position,
                    context
                  };
                };
              }
              if (prop === "asWillSaveTextDocumentParams") {
                return (event) => {
                  return {
                    textDocument: target.asTextDocumentIdentifier(event.document),
                    reason: event.reason
                  };
                };
              }
              if (prop.endsWith("Params")) {
                return target[prop];
              }
              return _MonacoLanguageClient.bypassConversion;
            }
          });
        }
        createMessageTransports(encoding) {
          return this.connectionProvider.get(encoding);
        }
        getLocale() {
          return navigator.language || "en-US";
        }
      };
      exports.MonacoLanguageClient = MonacoLanguageClient2;
      MonacoLanguageClient2.bypassConversion = (result, token) => token != null ? Promise.resolve(result || void 0) : result || void 0;
    }
  });

  // node_modules/monaco-languageclient/lib/monaco-commands.js
  var require_monaco_commands = __commonJS({
    "node_modules/monaco-languageclient/lib/monaco-commands.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MonacoCommands = void 0;
      var MonacoCommands = class {
        constructor(_monaco) {
          this._monaco = _monaco;
        }
        registerCommand(command, callback, thisArg) {
          return this._monaco.editor.registerCommand(command, (accessor, ...args) => callback.call(thisArg, ...args));
        }
      };
      exports.MonacoCommands = MonacoCommands;
    }
  });

  // node_modules/monaco-languageclient/lib/console-window.js
  var require_console_window = __commonJS({
    "node_modules/monaco-languageclient/lib/console-window.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConsoleWindow = void 0;
      var services_1 = require_services();
      var ConsoleWindow = class {
        constructor() {
          this.channels = /* @__PURE__ */ new Map();
        }
        showMessage(type, message, ...actions) {
          if (type === services_1.MessageType.Error) {
            console.error(message);
          }
          if (type === services_1.MessageType.Warning) {
            console.warn(message);
          }
          if (type === services_1.MessageType.Info) {
            console.info(message);
          }
          if (type === services_1.MessageType.Log) {
            console.log(message);
          }
          return Promise.resolve(void 0);
        }
        createOutputChannel(name) {
          const existing = this.channels.get(name);
          if (existing) {
            return existing;
          }
          const channel = {
            append(value) {
              console.log(name + ": " + value);
            },
            appendLine(line) {
              console.log(name + ": " + line);
            },
            show() {
            },
            dispose() {
            }
          };
          this.channels.set(name, channel);
          return channel;
        }
      };
      exports.ConsoleWindow = ConsoleWindow;
    }
  });

  // node_modules/glob-to-regexp/index.js
  var require_glob_to_regexp = __commonJS({
    "node_modules/glob-to-regexp/index.js"(exports, module) {
      module.exports = function(glob, opts) {
        if (typeof glob !== "string") {
          throw new TypeError("Expected a string");
        }
        var str = String(glob);
        var reStr = "";
        var extended = opts ? !!opts.extended : false;
        var globstar = opts ? !!opts.globstar : false;
        var inGroup = false;
        var flags = opts && typeof opts.flags === "string" ? opts.flags : "";
        var c;
        for (var i = 0, len = str.length; i < len; i++) {
          c = str[i];
          switch (c) {
            case "/":
            case "$":
            case "^":
            case "+":
            case ".":
            case "(":
            case ")":
            case "=":
            case "!":
            case "|":
              reStr += "\\" + c;
              break;
            case "?":
              if (extended) {
                reStr += ".";
                break;
              }
            case "[":
            case "]":
              if (extended) {
                reStr += c;
                break;
              }
            case "{":
              if (extended) {
                inGroup = true;
                reStr += "(";
                break;
              }
            case "}":
              if (extended) {
                inGroup = false;
                reStr += ")";
                break;
              }
            case ",":
              if (inGroup) {
                reStr += "|";
                break;
              }
              reStr += "\\" + c;
              break;
            case "*":
              var prevChar = str[i - 1];
              var starCount = 1;
              while (str[i + 1] === "*") {
                starCount++;
                i++;
              }
              var nextChar = str[i + 1];
              if (!globstar) {
                reStr += ".*";
              } else {
                var isGlobstar = starCount > 1 && (prevChar === "/" || prevChar === void 0) && (nextChar === "/" || nextChar === void 0);
                if (isGlobstar) {
                  reStr += "((?:[^/]*(?:/|$))*)";
                  i++;
                } else {
                  reStr += "([^/]*)";
                }
              }
              break;
            default:
              reStr += c;
          }
        }
        if (!flags || !~flags.indexOf("g")) {
          reStr = "^" + reStr + "$";
        }
        return new RegExp(reStr, flags);
      };
    }
  });

  // node_modules/monaco-languageclient/lib/monaco-diagnostic-collection.js
  var require_monaco_diagnostic_collection = __commonJS({
    "node_modules/monaco-languageclient/lib/monaco-diagnostic-collection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MonacoModelDiagnostics = exports.MonacoDiagnosticCollection = void 0;
      var disposable_1 = require_disposable4();
      var MonacoDiagnosticCollection = class {
        constructor(_monaco, name, p2m) {
          this._monaco = _monaco;
          this.name = name;
          this.p2m = p2m;
          this.diagnostics = /* @__PURE__ */ new Map();
          this.toDispose = new disposable_1.DisposableCollection();
        }
        dispose() {
          this.toDispose.dispose();
        }
        get(uri) {
          const diagnostics = this.diagnostics.get(uri);
          return !!diagnostics ? diagnostics.diagnostics : [];
        }
        set(uri, diagnostics) {
          const existing = this.diagnostics.get(uri);
          if (existing) {
            existing.diagnostics = diagnostics;
          } else {
            const modelDiagnostics = new MonacoModelDiagnostics(this._monaco, uri, diagnostics, this.name, this.p2m);
            this.diagnostics.set(uri, modelDiagnostics);
            this.toDispose.push(disposable_1.Disposable.create(() => {
              this.diagnostics.delete(uri);
              modelDiagnostics.dispose();
            }));
          }
        }
      };
      exports.MonacoDiagnosticCollection = MonacoDiagnosticCollection;
      var MonacoModelDiagnostics = class {
        constructor(_monaco, uri, diagnostics, owner, p2m) {
          this._monaco = _monaco;
          this.owner = owner;
          this.p2m = p2m;
          this._markers = [];
          this._diagnostics = [];
          this.toDispose = new disposable_1.DisposableCollection();
          this.uri = this._monaco.Uri.parse(uri);
          this.diagnostics = diagnostics;
          this.toDispose.push(this._monaco.editor.onDidCreateModel((model) => this.doUpdateModelMarkers(model)));
        }
        set diagnostics(diagnostics) {
          this._diagnostics = diagnostics;
          this._markers = this.p2m.asDiagnostics(diagnostics);
          this.updateModelMarkers();
        }
        get diagnostics() {
          return this._diagnostics;
        }
        get markers() {
          return this._markers;
        }
        dispose() {
          this._markers = [];
          this.updateModelMarkers();
          this.toDispose.dispose();
        }
        updateModelMarkers() {
          const model = this._monaco.editor.getModel(this.uri);
          this.doUpdateModelMarkers(model ? model : void 0);
        }
        doUpdateModelMarkers(model) {
          if (model && this.uri.toString() === model.uri.toString()) {
            this._monaco.editor.setModelMarkers(model, this.owner, this._markers);
          }
        }
      };
      exports.MonacoModelDiagnostics = MonacoModelDiagnostics;
    }
  });

  // node_modules/monaco-languageclient/lib/monaco-languages.js
  var require_monaco_languages = __commonJS({
    "node_modules/monaco-languageclient/lib/monaco-languages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MonacoLanguages = exports.testGlob = exports.MonacoModelIdentifier = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var glob_to_regexp_1 = tslib_1.__importDefault(require_glob_to_regexp());
      var services_1 = require_services();
      var monaco_diagnostic_collection_1 = require_monaco_diagnostic_collection();
      var MonacoModelIdentifier;
      (function(MonacoModelIdentifier2) {
        function fromDocument(_monaco, document2) {
          return {
            uri: _monaco.Uri.parse(document2.uri),
            languageId: document2.languageId
          };
        }
        MonacoModelIdentifier2.fromDocument = fromDocument;
        function fromModel(model) {
          return {
            uri: model.uri,
            languageId: model.getLanguageId()
          };
        }
        MonacoModelIdentifier2.fromModel = fromModel;
      })(MonacoModelIdentifier = exports.MonacoModelIdentifier || (exports.MonacoModelIdentifier = {}));
      function testGlob(pattern, value) {
        const regExp = (0, glob_to_regexp_1.default)(pattern, {
          extended: true,
          globstar: true
        });
        return regExp.test(value);
      }
      exports.testGlob = testGlob;
      function overrideWithResolvedValue(item, resolvedItem) {
        for (const key in resolvedItem) {
          const value = resolvedItem[key];
          if (value != null) {
            item[key] = value;
          }
        }
      }
      var ExtHostDiagnostics = class _ExtHostDiagnostics {
        constructor(_monaco, p2m) {
          this._monaco = _monaco;
          this.p2m = p2m;
          this._collections = /* @__PURE__ */ new Map();
        }
        /**
         * This method is greatly inspired by https://github.com/microsoft/vscode/blob/e9393b096d90a5ac49b1528d1ec60483fc6b993e/src/vs/workbench/api/common/extHostDiagnostics.ts#L248
         */
        createDiagnosticCollection(name) {
          let owner;
          if (!name) {
            name = "_generated_diagnostic_collection_name_#" + _ExtHostDiagnostics._idPool++;
            owner = name;
          } else if (!this._collections.has(name)) {
            owner = name;
          } else {
            do {
              owner = name + _ExtHostDiagnostics._idPool++;
            } while (this._collections.has(owner));
          }
          const _this = this;
          return new class extends monaco_diagnostic_collection_1.MonacoDiagnosticCollection {
            constructor() {
              super(_this._monaco, name || "default", _this.p2m);
              _this._collections.set(owner, this);
            }
            dispose() {
              super.dispose();
              _this._collections.delete(owner);
            }
          }();
        }
        getDiagnostics(resourceUri) {
          let res = [];
          for (let collection of this._collections.values()) {
            const diagnostics = collection.get(resourceUri);
            if (diagnostics) {
              res = res.concat(diagnostics);
            }
          }
          return res;
        }
      };
      ExtHostDiagnostics._idPool = 0;
      var MonacoLanguages = class _MonacoLanguages {
        constructor(_monaco, p2m, m2p) {
          this._monaco = _monaco;
          this.p2m = p2m;
          this.m2p = m2p;
          this.extHostDiagnostics = new ExtHostDiagnostics(_monaco, p2m);
        }
        match(selector, document2) {
          return this.matchModel(selector, MonacoModelIdentifier.fromDocument(this._monaco, document2));
        }
        createDiagnosticCollection(name) {
          return this.extHostDiagnostics.createDiagnosticCollection(name);
        }
        registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
          const completionProvider = this.createCompletionProvider(provider, ...triggerCharacters);
          return this._monaco.languages.registerCompletionItemProvider(selector, completionProvider);
        }
        createCompletionProvider(provider, ...triggerCharacters) {
          return {
            triggerCharacters,
            provideCompletionItems: async (model, position, context, token) => {
              const wordUntil = model.getWordUntilPosition(position);
              const defaultRange = new this._monaco.Range(position.lineNumber, wordUntil.startColumn, position.lineNumber, wordUntil.endColumn);
              const params = this.m2p.asCompletionParams(model, position, context);
              const result = await provider.provideCompletionItems(params, token);
              return result && this.p2m.asCompletionResult(result, defaultRange);
            },
            resolveCompletionItem: provider.resolveCompletionItem ? async (item, token) => {
              const protocolItem = this.m2p.asCompletionItem(item);
              const resolvedItem = await provider.resolveCompletionItem(protocolItem, token);
              if (resolvedItem) {
                const resolvedCompletionItem = this.p2m.asCompletionItem(resolvedItem, item.range);
                overrideWithResolvedValue(item, resolvedCompletionItem);
              }
              return item;
            } : void 0
          };
        }
        registerHoverProvider(selector, provider) {
          const hoverProvider = this.createHoverProvider(provider);
          return this._monaco.languages.registerHoverProvider(selector, hoverProvider);
        }
        createHoverProvider(provider) {
          return {
            provideHover: async (model, position, token) => {
              const params = this.m2p.asTextDocumentPositionParams(model, position);
              const hover = await provider.provideHover(params, token);
              return hover && this.p2m.asHover(hover);
            }
          };
        }
        registerSignatureHelpProvider(selector, provider, ...triggerCharacters) {
          const signatureHelpProvider = this.createSignatureHelpProvider(provider, ...triggerCharacters);
          return this._monaco.languages.registerSignatureHelpProvider(selector, signatureHelpProvider);
        }
        createSignatureHelpProvider(provider, ...triggerCharacters) {
          const signatureHelpTriggerCharacters = [...provider.triggerCharacters || triggerCharacters || []];
          return {
            signatureHelpTriggerCharacters,
            signatureHelpRetriggerCharacters: provider.retriggerCharacters,
            provideSignatureHelp: async (model, position, token, context) => {
              const params = this.m2p.asTextDocumentPositionParams(model, position);
              const signatureHelp = await provider.provideSignatureHelp(params, token, this.m2p.asSignatureHelpContext(context));
              return signatureHelp && this.p2m.asSignatureHelpResult(signatureHelp);
            }
          };
        }
        registerDefinitionProvider(selector, provider) {
          const definitionProvider = this.createDefinitionProvider(provider);
          return this._monaco.languages.registerDefinitionProvider(selector, definitionProvider);
        }
        createDefinitionProvider(provider) {
          return {
            provideDefinition: async (model, position, token) => {
              const params = this.m2p.asTextDocumentPositionParams(model, position);
              const result = await provider.provideDefinition(params, token);
              return result && this.p2m.asDefinitionResult(result);
            }
          };
        }
        registerReferenceProvider(selector, provider) {
          const referenceProvider = this.createReferenceProvider(provider);
          return this._monaco.languages.registerReferenceProvider(selector, referenceProvider);
        }
        createReferenceProvider(provider) {
          return {
            provideReferences: async (model, position, context, token) => {
              const params = this.m2p.asReferenceParams(model, position, context);
              const result = await provider.provideReferences(params, token);
              return result && this.p2m.asReferences(result);
            }
          };
        }
        registerDocumentHighlightProvider(selector, provider) {
          const documentHighlightProvider = this.createDocumentHighlightProvider(provider);
          return this._monaco.languages.registerDocumentHighlightProvider(selector, documentHighlightProvider);
        }
        createDocumentHighlightProvider(provider) {
          return {
            provideDocumentHighlights: async (model, position, token) => {
              const params = this.m2p.asTextDocumentPositionParams(model, position);
              const result = await provider.provideDocumentHighlights(params, token);
              return result && this.p2m.asDocumentHighlights(result);
            }
          };
        }
        registerDocumentSymbolProvider(selector, provider) {
          const documentSymbolProvider = this.createDocumentSymbolProvider(provider);
          return this._monaco.languages.registerDocumentSymbolProvider(selector, documentSymbolProvider);
        }
        createDocumentSymbolProvider(provider) {
          return {
            provideDocumentSymbols: async (model, token) => {
              const params = this.m2p.asDocumentSymbolParams(model);
              const result = await provider.provideDocumentSymbols(params, token);
              return result && this.p2m.asDocumentSymbols(result);
            }
          };
        }
        registerCodeActionsProvider(selector, provider) {
          const codeActionProvider = this.createCodeActionProvider(provider);
          return this._monaco.languages.registerCodeActionProvider(selector, codeActionProvider);
        }
        createCodeActionProvider(provider) {
          return {
            provideCodeActions: async (model, range, context, token) => {
              const allDiagnostics = [];
              for (const diagnostic of this.extHostDiagnostics.getDiagnostics(model.uri.toString())) {
                if (range.intersectRanges(this.p2m.asRange(diagnostic.range))) {
                  const newLen = allDiagnostics.push(diagnostic);
                  if (newLen > _MonacoLanguages._maxCodeActionsPerFile) {
                    break;
                  }
                }
              }
              const params = this.m2p.asCodeActionParams(model, range, context, allDiagnostics);
              let result = await provider.provideCodeActions(params, token);
              return result && this.p2m.asCodeActionList(result);
            },
            resolveCodeAction: provider.resolveCodeAction ? async (codeAction, token) => {
              const params = this.m2p.asCodeAction(codeAction);
              const result = await provider.resolveCodeAction(params, token);
              if (result) {
                const resolvedCodeAction = this.p2m.asCodeAction(result);
                overrideWithResolvedValue(codeAction, resolvedCodeAction);
              }
              return codeAction;
            } : void 0
          };
        }
        registerCodeLensProvider(selector, provider) {
          const codeLensProvider = this.createCodeLensProvider(provider);
          return this._monaco.languages.registerCodeLensProvider(selector, codeLensProvider);
        }
        createCodeLensProvider(provider) {
          return {
            provideCodeLenses: async (model, token) => {
              const params = this.m2p.asCodeLensParams(model);
              const result = await provider.provideCodeLenses(params, token);
              return result && this.p2m.asCodeLensList(result);
            },
            resolveCodeLens: provider.resolveCodeLens ? async (model, codeLens, token) => {
              const protocolCodeLens = this.m2p.asCodeLens(codeLens);
              const result = await provider.resolveCodeLens(protocolCodeLens, token);
              if (result) {
                const resolvedCodeLens = this.p2m.asCodeLens(result);
                overrideWithResolvedValue(codeLens, resolvedCodeLens);
              }
              return codeLens;
            } : void 0
          };
        }
        registerDocumentFormattingEditProvider(selector, provider) {
          const documentFormattingEditProvider = this.createDocumentFormattingEditProvider(provider);
          return this._monaco.languages.registerDocumentFormattingEditProvider(selector, documentFormattingEditProvider);
        }
        createDocumentFormattingEditProvider(provider) {
          return {
            provideDocumentFormattingEdits: async (model, options, token) => {
              const params = this.m2p.asDocumentFormattingParams(model, options);
              const result = await provider.provideDocumentFormattingEdits(params, token);
              return result && this.p2m.asTextEdits(result);
            }
          };
        }
        registerDocumentRangeFormattingEditProvider(selector, provider) {
          const documentRangeFormattingEditProvider = this.createDocumentRangeFormattingEditProvider(provider);
          return this._monaco.languages.registerDocumentRangeFormattingEditProvider(selector, documentRangeFormattingEditProvider);
        }
        createDocumentRangeFormattingEditProvider(provider) {
          return {
            provideDocumentRangeFormattingEdits: async (model, range, options, token) => {
              const params = this.m2p.asDocumentRangeFormattingParams(model, range, options);
              const result = await provider.provideDocumentRangeFormattingEdits(params, token);
              return result && this.p2m.asTextEdits(result);
            }
          };
        }
        registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacter) {
          const onTypeFormattingEditProvider = this.createOnTypeFormattingEditProvider(provider, firstTriggerCharacter, ...moreTriggerCharacter);
          return this._monaco.languages.registerOnTypeFormattingEditProvider(selector, onTypeFormattingEditProvider);
        }
        createOnTypeFormattingEditProvider(provider, firstTriggerCharacter, ...moreTriggerCharacter) {
          const autoFormatTriggerCharacters = [firstTriggerCharacter].concat(moreTriggerCharacter);
          return {
            autoFormatTriggerCharacters,
            provideOnTypeFormattingEdits: async (model, position, ch, options, token) => {
              const params = this.m2p.asDocumentOnTypeFormattingParams(model, position, ch, options);
              const result = await provider.provideOnTypeFormattingEdits(params, token);
              return result && this.p2m.asTextEdits(result);
            }
          };
        }
        registerRenameProvider(selector, provider) {
          const renameProvider = this.createRenameProvider(provider);
          return this._monaco.languages.registerRenameProvider(selector, renameProvider);
        }
        createRenameProvider(provider) {
          return {
            provideRenameEdits: async (model, position, newName, token) => {
              const params = this.m2p.asRenameParams(model, position, newName);
              const result = await provider.provideRenameEdits(params, token);
              return result && this.p2m.asWorkspaceEdit(result);
            }
          };
        }
        registerDocumentLinkProvider(selector, provider) {
          const linkProvider = this.createDocumentLinkProvider(provider);
          return this._monaco.languages.registerLinkProvider(selector, linkProvider);
        }
        createDocumentLinkProvider(provider) {
          return {
            provideLinks: async (model, token) => {
              const params = this.m2p.asDocumentLinkParams(model);
              const result = await provider.provideDocumentLinks(params, token);
              return result && this.p2m.asDocumentLinks(result);
            },
            resolveLink: async (link, token) => {
              if (provider.resolveDocumentLink && (link.url === null || link.url === void 0)) {
                const documentLink = this.m2p.asDocumentLink(link);
                const result = await provider.resolveDocumentLink(documentLink, token);
                if (result) {
                  const resolvedLink = this.p2m.asDocumentLink(result);
                  overrideWithResolvedValue(link, resolvedLink);
                }
              }
              return link;
            }
          };
        }
        registerImplementationProvider(selector, provider) {
          const implementationProvider = this.createImplementationProvider(provider);
          return this._monaco.languages.registerImplementationProvider(selector, implementationProvider);
        }
        createImplementationProvider(provider) {
          return {
            provideImplementation: async (model, position, token) => {
              const params = this.m2p.asTextDocumentPositionParams(model, position);
              const result = await provider.provideImplementation(params, token);
              return result && this.p2m.asDefinitionResult(result);
            }
          };
        }
        registerTypeDefinitionProvider(selector, provider) {
          const typeDefinitionProvider = this.createTypeDefinitionProvider(provider);
          return this._monaco.languages.registerTypeDefinitionProvider(selector, typeDefinitionProvider);
        }
        createTypeDefinitionProvider(provider) {
          return {
            provideTypeDefinition: async (model, position, token) => {
              const params = this.m2p.asTextDocumentPositionParams(model, position);
              const result = await provider.provideTypeDefinition(params, token);
              return result && this.p2m.asDefinitionResult(result);
            }
          };
        }
        registerColorProvider(selector, provider) {
          const documentColorProvider = this.createDocumentColorProvider(provider);
          return this._monaco.languages.registerColorProvider(selector, documentColorProvider);
        }
        createDocumentColorProvider(provider) {
          return {
            provideDocumentColors: async (model, token) => {
              const textDocument = this.m2p.asTextDocumentIdentifier(model);
              const result = await provider.provideDocumentColors({ textDocument }, token);
              return result && this.p2m.asColorInformations(result);
            },
            provideColorPresentations: async (model, info, token) => {
              const textDocument = this.m2p.asTextDocumentIdentifier(model);
              const range = this.m2p.asRange(info.range);
              const result = await provider.provideColorPresentations({
                textDocument,
                color: info.color,
                range
              }, token);
              return result && this.p2m.asColorPresentations(result);
            }
          };
        }
        registerFoldingRangeProvider(selector, provider) {
          const foldingRangeProvider = this.createFoldingRangeProvider(provider);
          return this._monaco.languages.registerFoldingRangeProvider(selector, foldingRangeProvider);
        }
        createFoldingRangeProvider(provider) {
          return {
            provideFoldingRanges: async (model, context, token) => {
              const textDocument = this.m2p.asTextDocumentIdentifier(model);
              const result = await provider.provideFoldingRanges({
                textDocument
              }, token);
              return result && this.p2m.asFoldingRanges(result);
            }
          };
        }
        registerDocumentSemanticTokensProvider(selector, provider, legend) {
          const semanticTokensProvider = this.createSemanticTokensProvider(provider, legend);
          return this._monaco.languages.registerDocumentSemanticTokensProvider(selector, semanticTokensProvider);
        }
        createSemanticTokensProvider(provider, legend) {
          return {
            getLegend() {
              return legend;
            },
            onDidChange: provider.onDidChange,
            provideDocumentSemanticTokens: async (model, lastResultId, token) => {
              const textDocument = this.m2p.asTextDocumentIdentifier(model);
              const result = await provider.provideDocumentSemanticTokens({
                textDocument
              }, token);
              return result && this.p2m.asSemanticTokens(result);
            },
            releaseDocumentSemanticTokens: (resultId) => {
            }
          };
        }
        registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
          const rangeSemanticTokensProvider = this.createRangeSemanticTokensProvider(provider, legend);
          return this._monaco.languages.registerDocumentRangeSemanticTokensProvider(selector, rangeSemanticTokensProvider);
        }
        createRangeSemanticTokensProvider(provider, legend) {
          return {
            getLegend() {
              return legend;
            },
            provideDocumentRangeSemanticTokens: async (model, range, token) => {
              const textDocument = this.m2p.asTextDocumentIdentifier(model);
              const result = await provider.provideDocumentRangeSemanticTokens({
                textDocument,
                range: this.m2p.asRange(range)
              }, token);
              return result && this.p2m.asSemanticTokens(result);
            }
          };
        }
        registerInlayHintsProvider(selector, provider) {
          const inlayHintsProvider = this.createInlayHintsProvider(provider);
          return this._monaco.languages.registerInlayHintsProvider(selector, inlayHintsProvider);
        }
        createInlayHintsProvider(provider) {
          return {
            onDidChangeInlayHints: provider.onDidChangeInlayHints,
            provideInlayHints: async (model, range, token) => {
              const textDocument = this.m2p.asTextDocumentIdentifier(model);
              const result = await provider.provideInlayHints({
                textDocument,
                range: this.m2p.asRange(range)
              }, token);
              return result && this.p2m.asInlayHintList(result);
            },
            resolveInlayHint: async (hint, token) => {
              if (provider.resolveInlayHint) {
                const documentLink = this.m2p.asInlayHint(hint);
                const result = await provider.resolveInlayHint(documentLink, token);
                if (result) {
                  const resolvedInlayHint = this.p2m.asInlayHint(result);
                  overrideWithResolvedValue(hint, resolvedInlayHint);
                }
              }
              return hint;
            }
          };
        }
        matchModel(selector, model) {
          if (Array.isArray(selector)) {
            return selector.some((filter) => this.matchModel(filter, model));
          }
          if (services_1.TextDocumentFilter.is(selector)) {
            if (!!selector.language && selector.language !== model.languageId) {
              return false;
            }
            if (!!selector.scheme && selector.scheme !== model.uri.scheme) {
              return false;
            }
            if (!!selector.pattern && !testGlob(selector.pattern, model.uri.path)) {
              return false;
            }
            return true;
          } else if (typeof selector === "string") {
            return selector === model.languageId;
          } else {
            return false;
          }
        }
      };
      exports.MonacoLanguages = MonacoLanguages;
      MonacoLanguages._maxCodeActionsPerFile = 1e3;
    }
  });

  // node_modules/monaco-languageclient/lib/monaco-workspace.js
  var require_monaco_workspace = __commonJS({
    "node_modules/monaco-languageclient/lib/monaco-workspace.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MonacoWorkspace = void 0;
      var services_1 = require_services();
      var vscode_languageserver_textdocument_1 = require_main2();
      var disposable_1 = require_disposable4();
      var MonacoWorkspace = class {
        constructor(_monaco, p2m, m2p, _rootUri = null) {
          this._monaco = _monaco;
          this.p2m = p2m;
          this.m2p = m2p;
          this._rootUri = _rootUri;
          this.disposableCollection = new disposable_1.DisposableCollection();
          this.documents = /* @__PURE__ */ new Map();
          this.documentDisposables = /* @__PURE__ */ new Map();
          this.onDidOpenTextDocumentEmitter = new services_1.Emitter();
          this.onDidCloseTextDocumentEmitter = new services_1.Emitter();
          this.onDidChangeTextDocumentEmitter = new services_1.Emitter();
          for (const model of this._monaco.editor.getModels()) {
            this.addModel(model);
          }
          this.disposableCollection.push(this._monaco.editor.onDidCreateModel((model) => this.addModel(model)));
          this.disposableCollection.push(this._monaco.editor.onWillDisposeModel((model) => this.removeModel(model)));
          this.disposableCollection.push(this._monaco.editor.onDidChangeModelLanguage((event) => {
            this.removeModel(event.model);
            this.addModel(event.model);
          }));
        }
        dispose() {
          this.disposableCollection.dispose();
          for (const model of this._monaco.editor.getModels()) {
            this.removeModel(model);
          }
        }
        get rootUri() {
          return this._rootUri;
        }
        removeModel(model) {
          const uri = model.uri.toString();
          const document2 = this.documents.get(uri);
          if (document2) {
            this.documents.delete(uri);
            this.onDidCloseTextDocumentEmitter.fire(document2);
          }
          const disposable = this.documentDisposables.get(uri);
          if (disposable) {
            disposable.dispose();
            this.documentDisposables.delete(uri);
          }
        }
        addModel(model) {
          const uri = model.uri.toString();
          const document2 = this.setModel(uri, model);
          this.onDidOpenTextDocumentEmitter.fire(document2);
          this.documentDisposables.set(uri, model.onDidChangeContent((event) => this.onDidChangeContent(uri, model, event)));
        }
        onDidChangeContent(uri, model, event) {
          const textDocument = this.setModel(uri, model);
          const contentChanges = [];
          for (const change of event.changes) {
            const range = this.m2p.asRange(change.range);
            const rangeLength = change.rangeLength;
            const text = change.text;
            contentChanges.push({ range, rangeLength, text });
          }
          this.onDidChangeTextDocumentEmitter.fire({
            textDocument,
            contentChanges,
            isRedoing: event.isRedoing,
            isUndoing: event.isUndoing
          });
        }
        setModel(uri, model) {
          const document2 = vscode_languageserver_textdocument_1.TextDocument.create(uri, model.getLanguageId(), model.getVersionId(), model.getValue());
          this.documents.set(uri, document2);
          return document2;
        }
        get textDocuments() {
          return Array.from(this.documents.values());
        }
        get onDidOpenTextDocument() {
          return this.onDidOpenTextDocumentEmitter.event;
        }
        get onDidCloseTextDocument() {
          return this.onDidCloseTextDocumentEmitter.event;
        }
        get onDidChangeTextDocument() {
          return this.onDidChangeTextDocumentEmitter.event;
        }
        applyEdit(workspaceEdit) {
          const edit = this.p2m.asWorkspaceEdit(workspaceEdit);
          const models = edit.edits ? edit.edits.reduce((acc, currentEdit) => {
            const textEdit = currentEdit;
            acc[textEdit.resource.toString()] = this._monaco.editor.getModel(textEdit.resource);
            return acc;
          }, {}) : {};
          if (!Object.keys(models).map((uri) => models[uri]).every((model) => !!model)) {
            return Promise.resolve(false);
          }
          const editsByResource = edit.edits ? edit.edits.reduce((acc, currentEdit) => {
            const textEdit = currentEdit;
            const uri = textEdit.resource.toString();
            if (!(uri in acc)) {
              acc[uri] = [];
            }
            acc[uri].push({
              range: this._monaco.Range.lift(textEdit.edit.range),
              text: textEdit.edit.text
            });
            return acc;
          }, {}) : {};
          Object.keys(editsByResource).forEach((uri) => {
            models[uri].pushEditOperations(
              [],
              // Do not try and preserve editor selections.
              editsByResource[uri].map((resourceEdit) => {
                return {
                  identifier: { major: 1, minor: 0 },
                  range: resourceEdit.range,
                  text: resourceEdit.text,
                  forceMoveMarkers: true
                };
              }),
              () => []
            );
          });
          return Promise.resolve(true);
        }
      };
      exports.MonacoWorkspace = MonacoWorkspace;
    }
  });

  // node_modules/monaco-languageclient/lib/monaco-converter.js
  var require_monaco_converter = __commonJS({
    "node_modules/monaco-languageclient/lib/monaco-converter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtocolToMonacoConverter = exports.MonacoToProtocolConverter = exports.ProtocolInlayHint = exports.ProtocolCodeAction = exports.ProtocolCompletionItem = exports.ProtocolCodeLens = exports.ProtocolDocumentLink = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ls = tslib_1.__importStar(require_main5());
      var Is2 = tslib_1.__importStar(require_is4());
      var services_1 = require_services();
      var ProtocolDocumentLink;
      (function(ProtocolDocumentLink2) {
        function is(item) {
          return !!item && "data" in item;
        }
        ProtocolDocumentLink2.is = is;
      })(ProtocolDocumentLink = exports.ProtocolDocumentLink || (exports.ProtocolDocumentLink = {}));
      var ProtocolCodeLens;
      (function(ProtocolCodeLens2) {
        function is(item) {
          return !!item && "data" in item;
        }
        ProtocolCodeLens2.is = is;
      })(ProtocolCodeLens = exports.ProtocolCodeLens || (exports.ProtocolCodeLens = {}));
      var ProtocolCompletionItem;
      (function(ProtocolCompletionItem2) {
        function is(item) {
          return !!item && "data" in item;
        }
        ProtocolCompletionItem2.is = is;
      })(ProtocolCompletionItem = exports.ProtocolCompletionItem || (exports.ProtocolCompletionItem = {}));
      var ProtocolCodeAction;
      (function(ProtocolCodeAction2) {
        function is(item) {
          return !!item && "data" in item;
        }
        ProtocolCodeAction2.is = is;
      })(ProtocolCodeAction = exports.ProtocolCodeAction || (exports.ProtocolCodeAction = {}));
      var ProtocolInlayHint;
      (function(ProtocolInlayHint2) {
        function is(item) {
          return !!item && "data" in item;
        }
        ProtocolInlayHint2.is = is;
      })(ProtocolInlayHint = exports.ProtocolInlayHint || (exports.ProtocolInlayHint = {}));
      function isRangeReplace(v) {
        return v.insert !== void 0;
      }
      var MonacoToProtocolConverter = class {
        constructor(_monaco) {
          this._monaco = _monaco;
        }
        asPosition(lineNumber, column) {
          const line = lineNumber === void 0 || lineNumber === null ? void 0 : lineNumber - 1;
          const character = column === void 0 || column === null ? void 0 : column - 1;
          return {
            line,
            character
          };
        }
        asRange(range) {
          if (range === void 0) {
            return void 0;
          }
          if (range === null) {
            return null;
          }
          if (isRangeReplace(range)) {
            return this.asRange(range.insert);
          } else {
            const start = this.asPosition(range.startLineNumber, range.startColumn);
            const end = this.asPosition(range.endLineNumber, range.endColumn);
            return {
              start,
              end
            };
          }
        }
        asLocation(item) {
          if (!item) {
            return void 0;
          }
          const uri = item.uri.toString();
          const range = this.asRange(item.range);
          return {
            uri,
            range
          };
        }
        asTextDocumentIdentifier(model) {
          return {
            uri: model.uri.toString()
          };
        }
        asTextDocumentPositionParams(model, position) {
          return {
            textDocument: this.asTextDocumentIdentifier(model),
            position: this.asPosition(position.lineNumber, position.column)
          };
        }
        asCompletionParams(model, position, context) {
          return Object.assign(this.asTextDocumentPositionParams(model, position), {
            context: this.asCompletionContext(context)
          });
        }
        asCompletionContext(context) {
          return {
            triggerKind: this.asCompletionTriggerKind(context.triggerKind),
            triggerCharacter: context.triggerCharacter
          };
        }
        asSignatureHelpContext(context) {
          return {
            triggerKind: this.asSignatureHelpTriggerKind(context.triggerKind),
            triggerCharacter: context.triggerCharacter,
            isRetrigger: context.isRetrigger,
            activeSignatureHelp: this.asSignatureHelp(context.activeSignatureHelp)
          };
        }
        asSignatureHelp(signatureHelp) {
          if (signatureHelp === void 0) {
            return void 0;
          }
          return {
            signatures: signatureHelp.signatures.map((signatureInfo) => this.asSignatureInformation(signatureInfo)),
            activeParameter: signatureHelp.activeParameter,
            activeSignature: signatureHelp.activeSignature
          };
        }
        asSignatureInformation(signatureInformation) {
          return {
            documentation: this.asMarkupContent(signatureInformation.documentation),
            label: signatureInformation.label,
            parameters: signatureInformation.parameters.map((paramInfo) => this.asParameterInformation(paramInfo)),
            activeParameter: signatureInformation.activeParameter
          };
        }
        asParameterInformation(parameterInformation) {
          return {
            documentation: this.asMarkupContent(parameterInformation.documentation),
            label: parameterInformation.label
          };
        }
        asMarkupContent(markupContent) {
          if (markupContent === void 0) {
            return void 0;
          }
          if (typeof markupContent === "string") {
            return markupContent;
          }
          return {
            kind: services_1.MarkupKind.Markdown,
            value: markupContent.value
          };
        }
        asSignatureHelpTriggerKind(triggerKind) {
          switch (triggerKind) {
            case this._monaco.languages.SignatureHelpTriggerKind.ContentChange:
              return services_1.SignatureHelpTriggerKind.ContentChange;
            case this._monaco.languages.SignatureHelpTriggerKind.TriggerCharacter:
              return services_1.SignatureHelpTriggerKind.TriggerCharacter;
            default:
              return services_1.SignatureHelpTriggerKind.Invoke;
          }
        }
        asCompletionTriggerKind(triggerKind) {
          switch (triggerKind) {
            case this._monaco.languages.CompletionTriggerKind.TriggerCharacter:
              return services_1.CompletionTriggerKind.TriggerCharacter;
            case this._monaco.languages.CompletionTriggerKind.TriggerForIncompleteCompletions:
              return services_1.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
              return services_1.CompletionTriggerKind.Invoked;
          }
        }
        asCompletionItem(item) {
          var _a, _b;
          const result = { label: item.label };
          const protocolItem = ProtocolCompletionItem.is(item) ? item : void 0;
          if (item.detail) {
            result.detail = item.detail;
          }
          if (item.documentation) {
            if (typeof item.documentation === "string") {
              result.documentation = item.documentation;
            } else {
              result.documentation = this.asDocumentation((_a = protocolItem === null || protocolItem === void 0 ? void 0 : protocolItem.documentationFormat) !== null && _a !== void 0 ? _a : services_1.MarkupKind.Markdown, item.documentation);
            }
          }
          if (item.filterText) {
            result.filterText = item.filterText;
          }
          this.fillPrimaryInsertText(result, item);
          if (Is2.number(item.kind)) {
            result.kind = this.asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
          }
          if (item.sortText) {
            result.sortText = item.sortText;
          }
          if (item.additionalTextEdits) {
            result.additionalTextEdits = this.asTextEdits(item.additionalTextEdits);
          }
          if (item.command) {
            result.command = this.asCommand(item.command);
          }
          if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
          }
          if (item.command) {
            result.command = this.asCommand(item.command);
          }
          if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
          }
          if (protocolItem) {
            if (protocolItem.data !== void 0) {
              result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
              result.deprecated = protocolItem.deprecated;
            }
          }
          if (item.tags) {
            result.tags = (_b = item.tags) === null || _b === void 0 ? void 0 : _b.slice();
          }
          return result;
        }
        asCompletionItemKind(value, original) {
          if (original !== void 0) {
            return original;
          }
          switch (value) {
            case this._monaco.languages.CompletionItemKind.Method:
              return services_1.CompletionItemKind.Method;
            case this._monaco.languages.CompletionItemKind.Function:
              return services_1.CompletionItemKind.Function;
            case this._monaco.languages.CompletionItemKind.Constructor:
              return services_1.CompletionItemKind.Constructor;
            case this._monaco.languages.CompletionItemKind.Field:
              return services_1.CompletionItemKind.Field;
            case this._monaco.languages.CompletionItemKind.Variable:
              return services_1.CompletionItemKind.Variable;
            case this._monaco.languages.CompletionItemKind.Class:
              return services_1.CompletionItemKind.Class;
            case this._monaco.languages.CompletionItemKind.Struct:
              return services_1.CompletionItemKind.Struct;
            case this._monaco.languages.CompletionItemKind.Interface:
              return services_1.CompletionItemKind.Interface;
            case this._monaco.languages.CompletionItemKind.Module:
              return services_1.CompletionItemKind.Module;
            case this._monaco.languages.CompletionItemKind.Property:
              return services_1.CompletionItemKind.Property;
            case this._monaco.languages.CompletionItemKind.Event:
              return services_1.CompletionItemKind.Event;
            case this._monaco.languages.CompletionItemKind.Operator:
              return services_1.CompletionItemKind.Operator;
            case this._monaco.languages.CompletionItemKind.Unit:
              return services_1.CompletionItemKind.Unit;
            case this._monaco.languages.CompletionItemKind.Value:
              return services_1.CompletionItemKind.Value;
            case this._monaco.languages.CompletionItemKind.Constant:
              return services_1.CompletionItemKind.Constant;
            case this._monaco.languages.CompletionItemKind.Enum:
              return services_1.CompletionItemKind.Enum;
            case this._monaco.languages.CompletionItemKind.EnumMember:
              return services_1.CompletionItemKind.EnumMember;
            case this._monaco.languages.CompletionItemKind.Keyword:
              return services_1.CompletionItemKind.Keyword;
            case this._monaco.languages.CompletionItemKind.Text:
              return services_1.CompletionItemKind.Text;
            case this._monaco.languages.CompletionItemKind.Color:
              return services_1.CompletionItemKind.Color;
            case this._monaco.languages.CompletionItemKind.File:
              return services_1.CompletionItemKind.File;
            case this._monaco.languages.CompletionItemKind.Reference:
              return services_1.CompletionItemKind.Reference;
            case this._monaco.languages.CompletionItemKind.Customcolor:
              return services_1.CompletionItemKind.Color;
            case this._monaco.languages.CompletionItemKind.Folder:
              return services_1.CompletionItemKind.Folder;
            case this._monaco.languages.CompletionItemKind.TypeParameter:
              return services_1.CompletionItemKind.TypeParameter;
            case this._monaco.languages.CompletionItemKind.Snippet:
              return services_1.CompletionItemKind.Snippet;
            default:
              return value + 1;
          }
        }
        asDocumentation(format, documentation) {
          switch (format) {
            case services_1.MarkupKind.PlainText:
              return { kind: format, value: documentation };
            case services_1.MarkupKind.Markdown:
              return { kind: format, value: documentation.value };
            default:
              return `Unsupported Markup content received. Kind is: ${format}`;
          }
        }
        fillPrimaryInsertText(target, source) {
          let format = services_1.InsertTextFormat.PlainText;
          let text;
          let range;
          if (source.insertTextRules !== void 0 && (source.insertTextRules & this._monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet) === 0) {
            format = services_1.InsertTextFormat.Snippet;
            text = source.insertText;
          }
          target.insertTextFormat = format;
          text = source.insertText;
          if (source.range) {
            range = this.asRange(source.range);
          }
          target.insertTextFormat = format;
          if (source.fromEdit && text && range) {
            target.textEdit = { newText: text, range };
          } else {
            target.insertText = text;
          }
          target.insertTextMode = source.insertTextMode;
        }
        asTextEdit(edit) {
          const range = this.asRange(edit.range);
          return {
            range,
            newText: edit.text || ""
          };
        }
        asTextEdits(items) {
          if (!items) {
            return void 0;
          }
          return items.map((item) => this.asTextEdit(item));
        }
        asReferenceParams(model, position, options) {
          return {
            textDocument: this.asTextDocumentIdentifier(model),
            position: this.asPosition(position.lineNumber, position.column),
            context: { includeDeclaration: options.includeDeclaration }
          };
        }
        asDocumentSymbolParams(model) {
          return {
            textDocument: this.asTextDocumentIdentifier(model)
          };
        }
        asCodeLensParams(model) {
          return {
            textDocument: this.asTextDocumentIdentifier(model)
          };
        }
        asDiagnosticSeverity(value) {
          switch (value) {
            case this._monaco.MarkerSeverity.Error:
              return services_1.DiagnosticSeverity.Error;
            case this._monaco.MarkerSeverity.Warning:
              return services_1.DiagnosticSeverity.Warning;
            case this._monaco.MarkerSeverity.Info:
              return services_1.DiagnosticSeverity.Information;
            case this._monaco.MarkerSeverity.Hint:
              return services_1.DiagnosticSeverity.Hint;
          }
          return void 0;
        }
        asDiagnostic(marker) {
          const range = this.asRange(new this._monaco.Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn));
          const severity = this.asDiagnosticSeverity(marker.severity);
          const diag = services_1.Diagnostic.create(range, marker.message, severity, marker.code, marker.source);
          return diag;
        }
        asDiagnostics(markers) {
          if (markers === void 0 || markers === null) {
            return markers;
          }
          return markers.map((marker) => this.asDiagnostic(marker));
        }
        asCodeActionContext(context, diagnostics) {
          if (context === void 0 || context === null) {
            return context;
          }
          return services_1.CodeActionContext.create(diagnostics, Is2.string(context.only) ? [context.only] : void 0, void 0);
        }
        asCodeActionParams(model, range, context, diagnostics) {
          return {
            textDocument: this.asTextDocumentIdentifier(model),
            range: this.asRange(range),
            context: this.asCodeActionContext(context, diagnostics)
          };
        }
        asCommand(item) {
          if (item) {
            let args = item.arguments || [];
            return services_1.Command.create(item.title, item.id, ...args);
          }
          return void 0;
        }
        asCodeLens(item) {
          let result = services_1.CodeLens.create(this.asRange(item.range));
          if (item.command) {
            result.command = this.asCommand(item.command);
          }
          if (ProtocolCodeLens.is(item)) {
            if (item.data) {
              result.data = item.data;
            }
            ;
          }
          return result;
        }
        asFormattingOptions(options) {
          return { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        }
        asDocumentFormattingParams(model, options) {
          return {
            textDocument: this.asTextDocumentIdentifier(model),
            options: this.asFormattingOptions(options)
          };
        }
        asDocumentRangeFormattingParams(model, range, options) {
          return {
            textDocument: this.asTextDocumentIdentifier(model),
            range: this.asRange(range),
            options: this.asFormattingOptions(options)
          };
        }
        asDocumentOnTypeFormattingParams(model, position, ch, options) {
          return {
            textDocument: this.asTextDocumentIdentifier(model),
            position: this.asPosition(position.lineNumber, position.column),
            ch,
            options: this.asFormattingOptions(options)
          };
        }
        asRenameParams(model, position, newName) {
          return {
            textDocument: this.asTextDocumentIdentifier(model),
            position: this.asPosition(position.lineNumber, position.column),
            newName
          };
        }
        asDocumentLinkParams(model) {
          return {
            textDocument: this.asTextDocumentIdentifier(model)
          };
        }
        asDocumentLink(item) {
          let result = services_1.DocumentLink.create(this.asRange(item.range));
          if (item.url) {
            result.target = typeof item.url === "string" ? item.url : item.url.toString();
          }
          if (ProtocolDocumentLink.is(item) && item.data) {
            result.data = item.data;
          }
          if (item.tooltip) {
            result.tooltip = item.tooltip;
          }
          return result;
        }
        asCodeAction(item) {
          const result = { title: item.title };
          const protocolCodeAction = ProtocolCodeAction.is(item) ? item : void 0;
          if (Is2.number(item.kind)) {
            result.kind = item.kind;
          }
          if (item.diagnostics) {
            result.diagnostics = this.asDiagnostics(item.diagnostics);
          }
          if (item.edit) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
          }
          if (item.command) {
            result.command = this.asCommand(item.command);
          }
          if (item.isPreferred !== void 0) {
            result.isPreferred = item.isPreferred;
          }
          if (item.disabled) {
            result.disabled = { reason: item.disabled };
          }
          if (protocolCodeAction) {
            if (protocolCodeAction.data !== void 0) {
              result.data = protocolCodeAction.data;
            }
          }
          return result;
        }
        asInlayHintLabelPart(part) {
          return {
            value: part.label,
            command: this.asCommand(part.command),
            location: this.asLocation(part.location),
            tooltip: this.asMarkupContent(part.tooltip)
          };
        }
        asInlayHintLabel(label) {
          if (Array.isArray(label)) {
            return label.map((part) => this.asInlayHintLabelPart(part));
          }
          return label;
        }
        asInlayHint(item) {
          let result = services_1.InlayHint.create(this.asPosition(item.position.lineNumber, item.position.column), this.asInlayHintLabel(item.label), item.kind);
          if (ProtocolInlayHint.is(item)) {
            if (item.data) {
              result.data = item.data;
            }
            ;
          }
          return result;
        }
      };
      exports.MonacoToProtocolConverter = MonacoToProtocolConverter;
      var ProtocolToMonacoConverter = class {
        constructor(_monaco) {
          this._monaco = _monaco;
        }
        asResourceEdits(resource, edits, asMetadata, modelVersionId) {
          return edits.map((edit) => ({
            resource,
            edit: this.asTextEdit(edit),
            modelVersionId,
            metadata: services_1.AnnotatedTextEdit.is(edit) ? asMetadata(edit.annotationId) : void 0
          }));
        }
        asWorkspaceEditMetadata(changeAnnotation) {
          return {
            needsConfirmation: changeAnnotation.needsConfirmation === true,
            label: changeAnnotation.label,
            description: changeAnnotation.description
          };
        }
        asWorkspaceEdit(item) {
          if (!item) {
            return void 0;
          }
          const sharedMetadata = /* @__PURE__ */ new Map();
          if (item.changeAnnotations !== void 0) {
            for (const key of Object.keys(item.changeAnnotations)) {
              const metaData = this.asWorkspaceEditMetadata(item.changeAnnotations[key]);
              sharedMetadata.set(key, metaData);
            }
          }
          const asMetadata = (annotation) => {
            if (annotation === void 0) {
              return void 0;
            } else {
              return sharedMetadata.get(annotation);
            }
          };
          const edits = [];
          if (item.documentChanges) {
            item.documentChanges.forEach((change) => {
              if (ls.CreateFile.is(change)) {
                edits.push({
                  newUri: this._monaco.Uri.parse(change.uri),
                  options: change.options,
                  metadata: asMetadata(change.annotationId)
                });
              } else if (ls.RenameFile.is(change)) {
                edits.push({
                  oldUri: this._monaco.Uri.parse(change.oldUri),
                  newUri: this._monaco.Uri.parse(change.newUri),
                  options: change.options,
                  metadata: asMetadata(change.annotationId)
                });
              } else if (ls.DeleteFile.is(change)) {
                edits.push({
                  oldUri: this._monaco.Uri.parse(change.uri),
                  options: change.options,
                  metadata: asMetadata(change.annotationId)
                });
              } else if (ls.TextDocumentEdit.is(change)) {
                const resource = this._monaco.Uri.parse(change.textDocument.uri);
                const version = typeof change.textDocument.version === "number" ? change.textDocument.version : void 0;
                edits.push(...this.asResourceEdits(resource, change.edits, asMetadata, version));
              } else {
                console.error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
              }
            });
          } else if (item.changes) {
            for (const key of Object.keys(item.changes)) {
              const resource = this._monaco.Uri.parse(key);
              edits.push(...this.asResourceEdits(resource, item.changes[key], asMetadata));
            }
          }
          return {
            edits
          };
        }
        asTextEdit(edit) {
          if (!edit) {
            return void 0;
          }
          const range = this.asRange(edit.range);
          return {
            range,
            text: edit.newText
          };
        }
        asTextEdits(items) {
          if (!items) {
            return void 0;
          }
          return items.map((item) => this.asTextEdit(item));
        }
        asCodeLens(item) {
          if (!item) {
            return void 0;
          }
          const range = this.asRange(item.range);
          let result = { range };
          if (item.command) {
            result.command = this.asCommand(item.command);
          }
          if (item.data !== void 0 && item.data !== null) {
            result.data = item.data;
          }
          return result;
        }
        asCodeLensList(items) {
          if (!items) {
            return void 0;
          }
          return {
            lenses: items.map((codeLens) => this.asCodeLens(codeLens)),
            dispose: () => {
            }
          };
        }
        asCodeActionList(actions) {
          return {
            actions: actions.map((action) => this.asCodeAction(action)),
            dispose: () => {
            }
          };
        }
        asCodeAction(item) {
          if (services_1.Command.is(item)) {
            return {
              command: {
                id: item.command,
                title: item.title,
                arguments: item.arguments
              },
              title: item.title
            };
          }
          return {
            title: item.title,
            command: this.asCommand(item.command),
            edit: this.asWorkspaceEdit(item.edit),
            diagnostics: this.asDiagnostics(item.diagnostics),
            kind: item.kind,
            disabled: item.disabled ? item.disabled.reason : void 0,
            isPreferred: item.isPreferred,
            data: item.data
          };
        }
        asCommand(command) {
          if (!command) {
            return void 0;
          }
          return {
            id: command.command,
            title: command.title,
            arguments: command.arguments
          };
        }
        asDocumentSymbol(value) {
          const children = value.children && value.children.map((c) => this.asDocumentSymbol(c));
          return {
            name: value.name,
            detail: value.detail || "",
            kind: this.asSymbolKind(value.kind),
            tags: value.tags || [],
            range: this.asRange(value.range),
            selectionRange: this.asRange(value.selectionRange),
            children
          };
        }
        asDocumentSymbols(values) {
          if (services_1.DocumentSymbol.is(values[0])) {
            return values.map((s) => this.asDocumentSymbol(s));
          }
          return this.asSymbolInformations(values);
        }
        asSymbolInformations(values, uri) {
          if (!values) {
            return void 0;
          }
          return values.map((information) => this.asSymbolInformation(information, uri));
        }
        asSymbolInformation(item, uri) {
          const location = this.asLocation(uri ? Object.assign(Object.assign({}, item.location), { uri: uri.toString() }) : item.location);
          return {
            name: item.name,
            detail: "",
            containerName: item.containerName,
            kind: this.asSymbolKind(item.kind),
            tags: item.tags || [],
            range: location.range,
            selectionRange: location.range
          };
        }
        asSymbolKind(item) {
          if (item <= services_1.SymbolKind.TypeParameter) {
            return item - 1;
          }
          return this._monaco.languages.SymbolKind.Property;
        }
        asDocumentHighlights(values) {
          if (!values) {
            return void 0;
          }
          return values.map((item) => this.asDocumentHighlight(item));
        }
        asDocumentHighlight(item) {
          const range = this.asRange(item.range);
          const kind = Is2.number(item.kind) ? this.asDocumentHighlightKind(item.kind) : void 0;
          return { range, kind };
        }
        asDocumentHighlightKind(item) {
          switch (item) {
            case services_1.DocumentHighlightKind.Text:
              return this._monaco.languages.DocumentHighlightKind.Text;
            case services_1.DocumentHighlightKind.Read:
              return this._monaco.languages.DocumentHighlightKind.Read;
            case services_1.DocumentHighlightKind.Write:
              return this._monaco.languages.DocumentHighlightKind.Write;
          }
          return this._monaco.languages.DocumentHighlightKind.Text;
        }
        asReferences(values) {
          if (!values) {
            return void 0;
          }
          return values.map((location) => this.asLocation(location));
        }
        asDefinitionResult(item) {
          if (!item) {
            return void 0;
          }
          if (Is2.array(item)) {
            if (item.length == 0) {
              return void 0;
            } else if (services_1.LocationLink.is(item[0])) {
              let links = item;
              return links.map((location) => this.asLocationLink(location));
            } else {
              let locations = item;
              return locations.map((location) => this.asLocation(location));
            }
          } else {
            return this.asLocation(item);
          }
        }
        asLocation(item) {
          if (!item) {
            return void 0;
          }
          const uri = this._monaco.Uri.parse(item.uri);
          const range = this.asRange(item.range);
          return {
            uri,
            range
          };
        }
        asLocationLink(item) {
          if (!item) {
            return void 0;
          }
          let result = {
            uri: this._monaco.Uri.parse(item.targetUri),
            range: this.asRange(item.targetSelectionRange),
            originSelectionRange: this.asRange(item.originSelectionRange),
            targetSelectionRange: this.asRange(item.targetSelectionRange)
          };
          if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
          }
          return result;
        }
        asSignatureHelpResult(item) {
          if (!item) {
            return void 0;
          }
          let result = {};
          if (Is2.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
          } else {
            result.activeSignature = 0;
          }
          if (Is2.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
          } else {
            result.activeParameter = 0;
          }
          if (item.signatures) {
            result.signatures = this.asSignatureInformations(item.signatures);
          } else {
            result.signatures = [];
          }
          return {
            value: result,
            dispose: () => {
            }
          };
        }
        asSignatureInformations(items) {
          return items.map((item) => this.asSignatureInformation(item));
        }
        asSignatureInformation(item) {
          let result = { label: item.label };
          if (item.documentation) {
            result.documentation = this.asDocumentation(item.documentation);
          }
          if (item.parameters) {
            result.parameters = this.asParameterInformations(item.parameters);
          } else {
            result.parameters = [];
          }
          if (item.activeParameter) {
            result.activeParameter = item.activeParameter;
          }
          return result;
        }
        asParameterInformations(item) {
          return item.map((item2) => this.asParameterInformation(item2));
        }
        asParameterInformation(item) {
          let result = { label: item.label };
          if (item.documentation) {
            result.documentation = this.asDocumentation(item.documentation);
          }
          ;
          return result;
        }
        asHover(hover) {
          if (!hover) {
            return void 0;
          }
          return {
            contents: this.asHoverContent(hover.contents),
            range: this.asRange(hover.range)
          };
        }
        asHoverContent(contents) {
          if (Array.isArray(contents)) {
            return contents.map((content) => this.asMarkdownString(content));
          }
          return [this.asMarkdownString(contents)];
        }
        asDocumentation(value) {
          if (Is2.string(value)) {
            return value;
          }
          if (value.kind === services_1.MarkupKind.PlainText) {
            return value.value;
          }
          return this.asMarkdownString(value);
        }
        asMarkdownString(content) {
          if (services_1.MarkupContent.is(content)) {
            return {
              value: content.value
            };
          }
          if (Is2.string(content)) {
            return { value: content };
          }
          const { language, value } = content;
          return {
            value: "```" + language + "\n" + value + "\n```"
          };
        }
        asSeverity(severity) {
          if (severity === 1) {
            return this._monaco.MarkerSeverity.Error;
          }
          if (severity === 2) {
            return this._monaco.MarkerSeverity.Warning;
          }
          if (severity === 3) {
            return this._monaco.MarkerSeverity.Info;
          }
          return this._monaco.MarkerSeverity.Hint;
        }
        asDiagnostics(diagnostics) {
          if (!diagnostics) {
            return void 0;
          }
          return diagnostics.map((diagnostic) => this.asDiagnostic(diagnostic));
        }
        asDiagnostic(diagnostic) {
          return {
            code: typeof diagnostic.code === "number" ? diagnostic.code.toString() : diagnostic.code,
            severity: this.asSeverity(diagnostic.severity),
            message: diagnostic.message,
            source: diagnostic.source,
            startLineNumber: diagnostic.range.start.line + 1,
            startColumn: diagnostic.range.start.character + 1,
            endLineNumber: diagnostic.range.end.line + 1,
            endColumn: diagnostic.range.end.character + 1,
            relatedInformation: this.asRelatedInformations(diagnostic.relatedInformation),
            tags: diagnostic.tags
          };
        }
        asRelatedInformations(relatedInformation) {
          if (!relatedInformation) {
            return void 0;
          }
          return relatedInformation.map((item) => this.asRelatedInformation(item));
        }
        asRelatedInformation(relatedInformation) {
          return {
            resource: this._monaco.Uri.parse(relatedInformation.location.uri),
            startLineNumber: relatedInformation.location.range.start.line + 1,
            startColumn: relatedInformation.location.range.start.character + 1,
            endLineNumber: relatedInformation.location.range.end.line + 1,
            endColumn: relatedInformation.location.range.end.character + 1,
            message: relatedInformation.message
          };
        }
        asCompletionResult(result, defaultRange) {
          if (!result) {
            return {
              incomplete: false,
              suggestions: []
            };
          }
          if (Array.isArray(result)) {
            const suggestions = result.map((item) => this.asCompletionItem(item, defaultRange));
            return {
              incomplete: false,
              suggestions
            };
          }
          return {
            incomplete: result.isIncomplete,
            suggestions: result.items.map((item) => this.asCompletionItem(item, defaultRange))
          };
        }
        asCompletionItem(item, defaultRange) {
          const result = { label: item.label };
          if (item.detail) {
            result.detail = item.detail;
          }
          if (item.documentation) {
            result.documentation = this.asDocumentation(item.documentation);
            result.documentationFormat = Is2.string(item.documentation) ? void 0 : item.documentation.kind;
          }
          ;
          if (item.filterText) {
            result.filterText = item.filterText;
          }
          const insertText = this.asCompletionInsertText(item, defaultRange);
          result.insertText = insertText.insertText;
          result.range = insertText.range;
          result.fromEdit = insertText.fromEdit;
          if (insertText.isSnippet) {
            result.insertTextRules = this._monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet;
          }
          if (Is2.number(item.kind)) {
            let [itemKind, original] = this.asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
              result.originalItemKind = original;
            }
          }
          if (item.sortText) {
            result.sortText = item.sortText;
          }
          if (item.additionalTextEdits) {
            result.additionalTextEdits = this.asTextEdits(item.additionalTextEdits);
          }
          if (Is2.stringArray(item.commitCharacters)) {
            result.commitCharacters = item.commitCharacters.slice();
          }
          if (item.command) {
            result.command = this.asCommand(item.command);
          }
          if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
          }
          if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
          }
          if (item.data !== void 0) {
            result.data = item.data;
          }
          if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
          }
          if (item.insertTextMode) {
            result.insertTextMode = item.insertTextMode;
          }
          if (item.tags) {
            result.tags = item.tags;
          }
          return result;
        }
        asCompletionItemKind(value) {
          if (services_1.CompletionItemKind.Text <= value && value <= services_1.CompletionItemKind.TypeParameter) {
            switch (value) {
              case services_1.CompletionItemKind.Text:
                return [this._monaco.languages.CompletionItemKind.Text, void 0];
              case services_1.CompletionItemKind.Method:
                return [this._monaco.languages.CompletionItemKind.Method, void 0];
              case services_1.CompletionItemKind.Function:
                return [this._monaco.languages.CompletionItemKind.Function, void 0];
              case services_1.CompletionItemKind.Constructor:
                return [this._monaco.languages.CompletionItemKind.Constructor, void 0];
              case services_1.CompletionItemKind.Field:
                return [this._monaco.languages.CompletionItemKind.Field, void 0];
              case services_1.CompletionItemKind.Variable:
                return [this._monaco.languages.CompletionItemKind.Variable, void 0];
              case services_1.CompletionItemKind.Class:
                return [this._monaco.languages.CompletionItemKind.Class, void 0];
              case services_1.CompletionItemKind.Interface:
                return [this._monaco.languages.CompletionItemKind.Interface, void 0];
              case services_1.CompletionItemKind.Module:
                return [this._monaco.languages.CompletionItemKind.Module, void 0];
              case services_1.CompletionItemKind.Property:
                return [this._monaco.languages.CompletionItemKind.Property, void 0];
              case services_1.CompletionItemKind.Unit:
                return [this._monaco.languages.CompletionItemKind.Unit, void 0];
              case services_1.CompletionItemKind.Value:
                return [this._monaco.languages.CompletionItemKind.Value, void 0];
              case services_1.CompletionItemKind.Enum:
                return [this._monaco.languages.CompletionItemKind.Enum, void 0];
              case services_1.CompletionItemKind.Keyword:
                return [this._monaco.languages.CompletionItemKind.Keyword, void 0];
              case services_1.CompletionItemKind.Snippet:
                return [this._monaco.languages.CompletionItemKind.Snippet, void 0];
              case services_1.CompletionItemKind.Color:
                return [this._monaco.languages.CompletionItemKind.Color, void 0];
              case services_1.CompletionItemKind.File:
                return [this._monaco.languages.CompletionItemKind.File, void 0];
              case services_1.CompletionItemKind.Reference:
                return [this._monaco.languages.CompletionItemKind.Reference, void 0];
              case services_1.CompletionItemKind.Folder:
                return [this._monaco.languages.CompletionItemKind.Folder, void 0];
              case services_1.CompletionItemKind.EnumMember:
                return [this._monaco.languages.CompletionItemKind.EnumMember, void 0];
              case services_1.CompletionItemKind.Constant:
                return [this._monaco.languages.CompletionItemKind.Constant, void 0];
              case services_1.CompletionItemKind.Struct:
                return [this._monaco.languages.CompletionItemKind.Struct, void 0];
              case services_1.CompletionItemKind.Event:
                return [this._monaco.languages.CompletionItemKind.Event, void 0];
              case services_1.CompletionItemKind.Operator:
                return [this._monaco.languages.CompletionItemKind.Operator, void 0];
              case services_1.CompletionItemKind.TypeParameter:
                return [this._monaco.languages.CompletionItemKind.TypeParameter, void 0];
              default:
                return [value - 1, void 0];
            }
          }
          ;
          return [services_1.CompletionItemKind.Text, value];
        }
        asCompletionInsertText(item, defaultRange) {
          const isSnippet = item.insertTextFormat === services_1.InsertTextFormat.Snippet;
          if (item.textEdit) {
            if (services_1.TextEdit.is(item.textEdit)) {
              const range = this.asRange(item.textEdit.range);
              const value = item.textEdit.newText;
              return { isSnippet, insertText: value, range, fromEdit: true };
            } else {
              const range = {
                insert: this.asRange(item.textEdit.insert),
                replace: this.asRange(item.textEdit.replace)
              };
              const value = item.textEdit.newText;
              return { isSnippet, insertText: value, range, fromEdit: true };
            }
          }
          if (item.insertText) {
            return { isSnippet, insertText: item.insertText, fromEdit: false, range: defaultRange };
          }
          return { insertText: item.label, range: defaultRange, fromEdit: false, isSnippet: false };
        }
        asDocumentLinks(documentLinks) {
          const links = documentLinks.map((link) => this.asDocumentLink(link));
          return { links };
        }
        asDocumentLink(documentLink) {
          return {
            range: this.asRange(documentLink.range),
            url: documentLink.target,
            data: documentLink.data,
            tooltip: documentLink.tooltip
          };
        }
        asRange(range) {
          if (range === void 0) {
            return void 0;
          }
          if (range === null) {
            return null;
          }
          const start = this.asPosition(range.start);
          const end = this.asPosition(range.end);
          if (start instanceof this._monaco.Position && end instanceof this._monaco.Position) {
            return new this._monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column);
          }
          const startLineNumber = !start || start.lineNumber === void 0 ? void 0 : start.lineNumber;
          const startColumn = !start || start.column === void 0 ? void 0 : start.column;
          const endLineNumber = !end || end.lineNumber === void 0 ? void 0 : end.lineNumber;
          const endColumn = !end || end.column === void 0 ? void 0 : end.column;
          return { startLineNumber, startColumn, endLineNumber, endColumn };
        }
        asPosition(position) {
          if (position === void 0) {
            return void 0;
          }
          if (position === null) {
            return null;
          }
          const { line, character } = position;
          const lineNumber = line === void 0 ? void 0 : line + 1;
          const column = character === void 0 ? void 0 : character + 1;
          if (lineNumber !== void 0 && column !== void 0) {
            return new this._monaco.Position(lineNumber, column);
          }
          return { lineNumber, column };
        }
        asColorInformations(items) {
          return items.map((item) => this.asColorInformation(item));
        }
        asColorInformation(item) {
          return {
            range: this.asRange(item.range),
            color: item.color
          };
        }
        asColorPresentations(items) {
          return items.map((item) => this.asColorPresentation(item));
        }
        asColorPresentation(item) {
          return {
            label: item.label,
            textEdit: this.asTextEdit(item.textEdit),
            additionalTextEdits: this.asTextEdits(item.additionalTextEdits)
          };
        }
        asFoldingRanges(items) {
          if (!items) {
            return items;
          }
          return items.map((item) => this.asFoldingRange(item));
        }
        asFoldingRange(item) {
          return {
            start: item.startLine + 1,
            end: item.endLine + 1,
            kind: this.asFoldingRangeKind(item.kind)
          };
        }
        asFoldingRangeKind(kind) {
          if (kind) {
            switch (kind) {
              case services_1.FoldingRangeKind.Comment:
                return this._monaco.languages.FoldingRangeKind.Comment;
              case services_1.FoldingRangeKind.Imports:
                return this._monaco.languages.FoldingRangeKind.Imports;
              case services_1.FoldingRangeKind.Region:
                return this._monaco.languages.FoldingRangeKind.Region;
            }
            ;
          }
          return void 0;
        }
        asSemanticTokens(semanticTokens) {
          return {
            resultId: semanticTokens.resultId,
            data: Uint32Array.from(semanticTokens.data)
          };
        }
        asInlayHintLabelPart(part) {
          return {
            label: part.value,
            command: this.asCommand(part.command),
            location: this.asLocation(part.location),
            tooltip: part.tooltip && this.asMarkdownString(part.tooltip)
          };
        }
        asInlayHintLabel(label) {
          if (Array.isArray(label)) {
            return label.map((part) => this.asInlayHintLabelPart(part));
          }
          return label;
        }
        asInlayHint(inlayHint) {
          return {
            data: inlayHint.data,
            label: this.asInlayHintLabel(inlayHint.label),
            position: this.asPosition(inlayHint.position),
            kind: inlayHint.kind,
            paddingLeft: inlayHint.paddingLeft,
            paddingRight: inlayHint.paddingRight,
            tooltip: inlayHint.tooltip && this.asMarkdownString(inlayHint.tooltip)
          };
        }
        asInlayHintList(items) {
          if (!items) {
            return void 0;
          }
          return {
            hints: items.map((hint) => this.asInlayHint(hint)),
            dispose: () => {
            }
          };
        }
      };
      exports.ProtocolToMonacoConverter = ProtocolToMonacoConverter;
    }
  });

  // node_modules/monaco-languageclient/lib/monaco-services.js
  var require_monaco_services = __commonJS({
    "node_modules/monaco-languageclient/lib/monaco-services.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MonacoServices = void 0;
      var monaco_converter_1 = require_monaco_converter();
      var monaco_commands_1 = require_monaco_commands();
      var monaco_languages_1 = require_monaco_languages();
      var monaco_workspace_1 = require_monaco_workspace();
      var console_window_1 = require_console_window();
      var services_1 = require_services();
      var disposable_1 = require_disposable4();
      var MonacoServices;
      (function(MonacoServices2) {
        function create(_monaco, options = {}) {
          const m2p = new monaco_converter_1.MonacoToProtocolConverter(_monaco);
          const p2m = new monaco_converter_1.ProtocolToMonacoConverter(_monaco);
          return {
            commands: new monaco_commands_1.MonacoCommands(_monaco),
            languages: new monaco_languages_1.MonacoLanguages(_monaco, p2m, m2p),
            workspace: new monaco_workspace_1.MonacoWorkspace(_monaco, p2m, m2p, options.rootUri),
            window: new console_window_1.ConsoleWindow()
          };
        }
        MonacoServices2.create = create;
        function install(_monaco, options = {}) {
          const disposableCollection = new disposable_1.DisposableCollection();
          const services = create(_monaco, options);
          disposableCollection.push(services.workspace);
          disposableCollection.push(services_1.Services.install(services));
          return disposableCollection;
        }
        MonacoServices2.install = install;
        function get() {
          return services_1.Services.get();
        }
        MonacoServices2.get = get;
      })(MonacoServices = exports.MonacoServices || (exports.MonacoServices = {}));
    }
  });

  // node_modules/monaco-languageclient/lib/index.js
  var require_lib = __commonJS({
    "node_modules/monaco-languageclient/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_disposable4(), exports);
      tslib_1.__exportStar(require_services(), exports);
      tslib_1.__exportStar(require_connection5(), exports);
      tslib_1.__exportStar(require_monaco_language_client(), exports);
      tslib_1.__exportStar(require_monaco_commands(), exports);
      tslib_1.__exportStar(require_console_window(), exports);
      tslib_1.__exportStar(require_monaco_languages(), exports);
      tslib_1.__exportStar(require_monaco_workspace(), exports);
      tslib_1.__exportStar(require_monaco_services(), exports);
      tslib_1.__exportStar(require_monaco_converter(), exports);
    }
  });

  // node_modules/vscode-ws-jsonrpc/lib/disposable.js
  var import_vscode_jsonrpc = __toESM(require_main(), 1);

  // node_modules/vscode-ws-jsonrpc/lib/socket/socket.js
  var import_vscode_jsonrpc2 = __toESM(require_main(), 1);

  // node_modules/vscode-ws-jsonrpc/lib/socket/reader.js
  var import_vscode_jsonrpc3 = __toESM(require_main(), 1);
  var import_vscode_jsonrpc4 = __toESM(require_main(), 1);
  var WebSocketMessageReader = class extends import_vscode_jsonrpc4.AbstractMessageReader {
    socket;
    state = "initial";
    callback;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    events = [];
    constructor(socket) {
      super();
      this.socket = socket;
      this.socket.onMessage((message) => this.readMessage(message));
      this.socket.onError((error) => this.fireError(error));
      this.socket.onClose((code, reason) => {
        if (code !== 1e3) {
          const error = {
            name: "" + code,
            message: `Error during socket reconnect: code = ${code}, reason = ${reason}`
          };
          this.fireError(error);
        }
        this.fireClose();
      });
    }
    listen(callback) {
      if (this.state === "initial") {
        this.state = "listening";
        this.callback = callback;
        while (this.events.length !== 0) {
          const event = this.events.pop();
          if (event.message !== void 0) {
            this.readMessage(event.message);
          } else if (event.error !== void 0) {
            this.fireError(event.error);
          } else {
            this.fireClose();
          }
        }
      }
      return {
        dispose: () => {
          if (this.callback === callback) {
            this.state = "initial";
            this.callback = void 0;
          }
        }
      };
    }
    dispose() {
      super.dispose();
      this.state = "initial";
      this.callback = void 0;
      this.events.splice(0, this.events.length);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    readMessage(message) {
      if (this.state === "initial") {
        this.events.splice(0, 0, { message });
      } else if (this.state === "listening") {
        try {
          const data = JSON.parse(message);
          this.callback(data);
        } catch (err) {
          const error = {
            name: "400",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            message: `Error during message parsing, reason = ${typeof err === "object" ? err.message : "unknown"}`
          };
          this.fireError(error);
        }
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    fireError(error) {
      if (this.state === "initial") {
        this.events.splice(0, 0, { error });
      } else if (this.state === "listening") {
        super.fireError(error);
      }
    }
    fireClose() {
      if (this.state === "initial") {
        this.events.splice(0, 0, {});
      } else if (this.state === "listening") {
        super.fireClose();
      }
      this.state = "closed";
    }
  };

  // node_modules/vscode-ws-jsonrpc/lib/socket/writer.js
  var import_vscode_jsonrpc5 = __toESM(require_main(), 1);
  var import_vscode_jsonrpc6 = __toESM(require_main(), 1);
  var WebSocketMessageWriter = class extends import_vscode_jsonrpc6.AbstractMessageWriter {
    errorCount = 0;
    socket;
    constructor(socket) {
      super();
      this.socket = socket;
    }
    end() {
    }
    async write(msg) {
      try {
        const content = JSON.stringify(msg);
        this.socket.send(content);
      } catch (e) {
        this.errorCount++;
        this.fireError(e, msg, this.errorCount);
      }
    }
  };

  // node_modules/vscode-ws-jsonrpc/lib/socket/connection.js
  var import_vscode_jsonrpc7 = __toESM(require_main(), 1);
  function createWebSocketConnection(socket, logger) {
    const messageReader = new WebSocketMessageReader(socket);
    const messageWriter = new WebSocketMessageWriter(socket);
    const connection = (0, import_vscode_jsonrpc7.createMessageConnection)(messageReader, messageWriter, logger);
    connection.onClose(() => connection.dispose());
    return connection;
  }

  // node_modules/vscode-ws-jsonrpc/lib/logger.js
  var ConsoleLogger = class {
    error(message) {
      console.error(message);
    }
    warn(message) {
      console.warn(message);
    }
    info(message) {
      console.info(message);
    }
    log(message) {
      console.log(message);
    }
    debug(message) {
      console.debug(message);
    }
  };

  // node_modules/vscode-ws-jsonrpc/lib/connection.js
  function listen(options) {
    const { webSocket, onConnection } = options;
    const logger = options.logger || new ConsoleLogger();
    webSocket.onopen = () => {
      const socket = toSocket(webSocket);
      const connection = createWebSocketConnection(socket, logger);
      onConnection(connection);
    };
  }
  function toSocket(webSocket) {
    return {
      send: (content) => webSocket.send(content),
      onMessage: (cb) => {
        webSocket.onmessage = (event) => cb(event.data);
      },
      onError: (cb) => {
        webSocket.onerror = (event) => {
          if (Object.hasOwn(event, "message")) {
            cb(event.message);
          }
        };
      },
      onClose: (cb) => {
        webSocket.onclose = (event) => cb(event.code, event.reason);
      },
      dispose: () => webSocket.close()
    };
  }

  // client.js
  var import_monaco_languageclient = __toESM(require_lib());
  var import_normalize_url = __toESM(__require("normalize-url"));
  var monaco = __toESM(__require("monaco-editor"));
  function createLangClient(connection) {
    return new import_monaco_languageclient.MonacoLanguageClient({
      name: "Browser LSP Client",
      clientOptions: {
        documentSelector: ["javascript"],
        errorHandler: {
          error: () => import_monaco_languageclient.ErrorAction.Continue,
          closed: () => import_monaco_languageclient.CloseAction.Restart
        }
      },
      connectionProvider: {
        get: () => Promise.resolve(connection)
      }
    });
  }
  function connect() {
    const url = (0, import_normalize_url.default)("ws://localhost:3000");
    const ws = new WebSocket(url);
    listen({
      webSocket: ws,
      onConnection: (connection) => {
        const client = createLangClient((0, import_monaco_languageclient.createConnection)(connection));
        client.start();
        connection.onClose(() => client.stop());
      }
    });
  }
  window.startLSP = () => {
    const model = monaco.editor.createModel('console.log("hi")', "javascript");
    monaco.editor.create(document.getElementById("container"), { model });
    connect();
  };
})();
